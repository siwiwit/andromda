#set ($className = "WrappedMessageReceiver")
#if ($stringUtils.isNotBlank($webserviceTypesPackage))
package $webserviceTypesPackage;
#end

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.util.Base64;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.databinding.typemapping.SimpleTypeMapper;
import org.apache.axis2.description.AxisMessage;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.engine.ObjectSupplier;
import org.apache.axis2.receivers.AbstractInOutSyncMessageReceiver;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This Axis2 message reciever is used instead of the default {@link org.apache.axis2.rpc.receivers.RPCMessageReceiver}
 * because that one doesn't create responses that comply with the wrapped WSDL generated by AndroMDA.
 */
public class $className
    extends AbstractInOutSyncMessageReceiver
{
    private static Log log = LogFactory.getLog(${className}.class);

    /**
     * @see org.apache.axis2.receivers.AbstractInOutSyncMessageReceiver#invokeBusinessLogic(org.apache.axis2.context.MessageContext, org.apache.axis2.context.MessageContext)
     */
    @SuppressWarnings("unchecked")
    public void invokeBusinessLogic(
        MessageContext inMessage,
        MessageContext outMessage)
        throws AxisFault
    {
        Method method = null;
        try
        {
            // get the implementation class for the Web Service
            Object object = getTheImplementationObject(inMessage);
            final AxisOperation operation = inMessage.getOperationContext().getAxisOperation();
            final AxisService service = inMessage.getAxisService();
            final OMElement methodElement = inMessage.getEnvelope().getBody().getFirstElement();
            final AxisMessage inAxisMessage = operation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
            String messageNameSpace = null;
            QName elementQName;
            final String methodName = operation.getName().getLocalPart();
            for (final Method compareMethod : object.getClass().getMethods())
            {
                if (compareMethod.getName().equals(methodName))
                {
                    method = compareMethod;
                    break;
                }
            }
            Object responseObject = null;
            if (inAxisMessage != null)
            {
                if (inAxisMessage.getElementQName() == null)
                {
                    // method accept empty SOAPbody
                    responseObject =
                        method.invoke(
                            object,
                            new Object[0]);
                }
                else
                {
                    elementQName = inAxisMessage.getElementQName();
                    messageNameSpace = elementQName.getNamespaceURI();
                    OMNamespace namespace = methodElement.getNamespace();
                    if (messageNameSpace != null)
                    {
                        if (namespace == null)
                        {
                            throw new AxisFault("namespace mismatch require " + messageNameSpace + " found none");
                        }
                        if (!messageNameSpace.equals(namespace.getNamespaceURI()))
                        {
                            throw new AxisFault("namespace mismatch require " + messageNameSpace + " found " +
                                methodElement.getNamespace().getNamespaceURI());
                        }
                    }
                    else if (namespace != null)
                    {
                        throw new AxisFault("namespace mismatch. Axis Oepration expects non-namespace " +
                            "qualified element. But received a namespace qualified element");
                    }

                    responseObject = method.invoke(object, deserialize(methodElement, method,
                        service.getObjectSupplier(), service.getNameSpacesMap()));
                }
            }

            final SOAPFactory factory = getSOAPFactory(inMessage);

            final Map<String, OMNamespace> namespaces = new HashMap<String, OMNamespace>();
            OMNamespace targetNamespace = null;
            // Handling the response
            AxisMessage outAxisMessage = operation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
            final String targetNamespacePrefix = service.getSchematargetNamespacePrefix();
            if (service.isElementFormDefault() && outAxisMessage != null)
            {
                targetNamespace = factory.createOMNamespace(
                    outAxisMessage.getElementQName().getNamespaceURI(),
                    targetNamespacePrefix);
                namespaces.put(targetNamespacePrefix, targetNamespace);
            }

            final SOAPEnvelope envelope = factory.getDefaultEnvelope();

            final OMElement responseElement = factory.createOMElement(
                    getOperationResponseName(method),
                    targetNamespace);

            final OMNamespace xsiNamespace = factory.createOMNamespace(XSI_NS, XSI_PREFIX);
            namespaces.put(XSI_PREFIX,  xsiNamespace);
            responseElement.declareNamespace(xsiNamespace);

            final OMElement returnElement =
                getOMElement(
                    responseObject,
                    getOperationReturnName(method),
                    targetNamespace,
                    namespaces);

            responseElement.addChild(returnElement);
            envelope.getBody().addChild(responseElement);
            outMessage.setEnvelope(envelope);
        }
        catch (InvocationTargetException exception)
        {
            String message = null;
            Throwable cause = exception.getCause();
            if (cause != null)
            {
                message = cause.getMessage();
            }
            if (message == null)
            {
                message = "Exception occurred while trying to invoke service method " + method.getName();
            }
            log.error(
                message,
                exception);
            if (cause instanceof AxisFault)
            {
                throw (AxisFault)cause;
            }
            throw new AxisFault(message);
        }
        catch (Exception exception)
        {
            String message = "Exception occurred while trying to invoke service method " + method.getName();
            log.error(
                message,
                exception);
            throw new AxisFault(message, exception);
        }
    }

    private static final String CLASS = "class";

    private static final String RESPONSE = "Response";

    private static String getOperationResponseName(final Method method)
    {
        return method.getName() + RESPONSE;
    }

    private static final String RETURN = "Return";

    private static String getOperationReturnName(final Method method)
    {
        return method.getName() + RETURN;
    }

    private static String getArrayElementName(final Class componentType)
    {
        String elementName = TypeMappings.getSchemaType(componentType);
        if (StringUtils.isBlank(elementName))
        {
            elementName = StringUtils.uncapitalize(componentType.getName().replaceAll(
                ".*\\.",
            ""));
        }
        return elementName;
    }

    /**
     * Deserializes the arguments of <code>element</code> to the arguments of the given <code>method</code>.
     *
     * @param element the XML OMElement
     * @param method the method from which to deserialize the arguments.
     * @param objectSupplier the "object supplier" used to construct objects from given classes.
     * @param namespaces a map containing all available namespaces keyed by prefix.
     * @return the deserialized arguments.
     */
    public static Object[] deserialize(final OMElement element, final Method method,
        final ObjectSupplier objectSupplier, final Map<String, String> namespaces)
        throws Exception
    {
        int ctr = 0;
        final Class[] types = method.getParameterTypes();
        final Object[] arguments = new Object[types.length];
        for (final Iterator iterator = element.getChildElements(); iterator.hasNext(); ctr++)
        {
            final OMElement childElement = (OMElement)iterator.next();
            final Class type = types[ctr];
            arguments[ctr] = deserialize(childElement, type, objectSupplier, namespaces);
        }
        return arguments;
    }

    /**
     * Deserializes the given <code>element</code> to the given <code>type</code>.
     *
     * @param element the XML OMElement
     * @param type the java type.
     * @param objectSupplier the "object supplier" used to construct objects from given classes.
     * @param namespaces a map containing all available namespaces keyed by prefix.
     * @return the deserialized object.
     */
    public static Object deserialize(OMElement element, Class type, final ObjectSupplier objectSupplier,
        final Map<String, String> namespaces)
        throws Exception
    {
        Object bean = null;
        if (isSimpleType(type))
        {
             bean = getSimpleTypeObject(
                type,
                element);
        }
        else if (type == byte[].class)
        {
            bean = Base64.decode(element.getText());
        }
        else
        {
            if (type.isArray())
            {
                final Collection<Object> elements = new ArrayList<Object>();
                for (final Iterator iterator = element.getChildElements(); iterator.hasNext();)
                {
                    elements.add(deserialize((OMElement)iterator.next(), type.getComponentType(), objectSupplier, namespaces));
                }
                bean = elements.toArray((Object[])Array.newInstance(type.getComponentType(), 0));
            }
            else
            {
                try
                {
                    type = getAppropriateType(element, type, namespaces);
                    bean = objectSupplier.getObject(type);
                    final java.beans.PropertyDescriptor[] descriptors = PropertyUtils.getPropertyDescriptors(type);
                    for (int ctr = 0; ctr < descriptors.length; ctr++)
                    {
                        final java.beans.PropertyDescriptor descriptor = descriptors[ctr];
                        final String name = descriptor.getName();
                        if (!CLASS.equals(name))
                        {
                            final OMElement propertyElement = findElementByName(element, name);
                            if (propertyElement != null)
                            {
                                PropertyUtils.setProperty(bean, name, deserialize(propertyElement,
                                    descriptor.getPropertyType(), objectSupplier, namespaces));
                            }
                        }
                    }
                }
                catch (final Throwable throwable)
                {
                    throw new RuntimeException(throwable);
                }
            }
        }
        return bean;
    }

    /**
     * Finds an element having the given <code>name</code> from the child elements on the given
     * <code>element</code>.
     *
     * @param element the element to search.
     * @param name the name of the element to find.
     * @return the found element or null if one couldn't be found.
     */
    private static OMElement findElementByName(final OMElement element, final String name)
    {
        OMElement found = null;
        for (final Iterator iterator = element.getChildElements(); iterator.hasNext();)
        {
            final OMElement child = (OMElement)iterator.next();
            if (child.getLocalName().equals(name))
            {
                found = child;
                break;
            }
        }
        return found;
    }

    /**
     * Constructs and OMElement from the given bean
     *
     * @param bean the bean to introspect
     * @param elementName the name of the element
     * @param qualified whether or not the resulting document should be qualified
     * @param factory the SOAP factory instance used to create the OMElement
     * @param namespaces all namespace instances keyed by prefix.
     * @param targetNamespace the target namespace.
     */
    public static OMElement getOMElement(
        final Object bean,
        final String elementName,
        final OMNamespace targetNamespace,
        final Map<String, OMNamespace> namespaces)
    {
        final OMFactory factory = OMAbstractFactory.getOMFactory();
        return getOMElement(
            bean,
            elementName,
            factory,
            targetNamespace,
            namespaces,
            new ArrayList<Object>());
    }

    /**
     * The schema instance namespace.
     */
    private static final String XSI_NS = "http://www.w3.org/2001/XMLSchema-instance";

    /**
     * The prefix for the schema instance namespace.
     */
    private static final String XSI_PREFIX = "xsi";

    /**
     * The name of the xsi:type attribute.
     */
    private static final String TYPE = "type";

    /**
     * Used to seperate a namespace prefix and name in a QName.
     */
    private static final String NS_SEPARATOR = ":";

    /**
     * Constructs and OMElement from the given bean
     *
     * @param bean the bean to introspect
     * @param elementName the name of the element
     * @param qualified whether or not the resulting document should be qualified
     * @param factory the SOAP factory instance used to create the OMElement
     * @param targetNamespace the target namespace.
     * @param namespaces all namespace instances keyed by prefix.
     * @param evaluatingBeans the collection in which to keep the beans that are evaluating in order
     *        to prevent endless recursion.
     */
    private static OMElement getOMElement(
        final Object bean,
        final String elementName,
        final OMFactory factory,
        final OMNamespace targetNamespace,
        final Map<String, OMNamespace> namespaces,
        final Collection<Object> evaluatingBeans)
    {
        final OMElement element = factory.createOMElement(
                elementName,
                targetNamespace);
        if (bean != null && evaluatingBeans != null && !evaluatingBeans.contains(bean))
        {
            evaluatingBeans.add(bean);
            if (isSimpleType(bean))
            {
                element.addChild(
                    factory.createOMText(SimpleTypeMapper.getStringValue(bean)));
            }
            else if (bean instanceof byte[])
            {
                element.addChild(factory.createOMText(Base64.encode((byte[])bean)));
            }
            else
            {
                final Class beanType = bean.getClass();
                if (beanType.isArray())
                {
                    final String arrayComponentName = getArrayElementName(beanType.getComponentType());
                    for (int ctr = 0; ctr < Array.getLength(bean); ctr++)
                    {
                        element.addChild(
                            getOMElement(
                                Array.get(bean, ctr),
                                arrayComponentName,
                                factory,
                                targetNamespace,
                                namespaces,
                                evaluatingBeans));
                    }
                }
                else
                {
                    final String attributeValue = targetNamespace != null ?
                        targetNamespace.getPrefix() + NS_SEPARATOR + beanType.getSimpleName() : beanType.getSimpleName();
                    // - add the type attribute for complex types (lets the client know the appropriate type
                    //   when deserializing
                    element.addAttribute(TYPE, attributeValue, namespaces.get(XSI_PREFIX));
                    try
                    {
                        final java.util.Map properties = PropertyUtils.describe(bean);
                        for (final Iterator iterator = properties.keySet().iterator(); iterator.hasNext();)
                        {
                            final String name = (String)iterator.next();
                            if (!CLASS.equals(name))
                            {
                                final Object value = properties.get(name);
                                if (value != null)
                                {
                                    element.addChild(
                                        getOMElement(
                                            value,
                                            name,
                                            factory,
                                            targetNamespace,
                                            namespaces,
                                            evaluatingBeans));
                                }
                            }
                        }
                    }
                    catch (final Throwable throwable)
                    {
                        throw new RuntimeException(throwable);
                    }
                }
            }
            evaluatingBeans.remove(bean);
        }
        return element;
    }

    /**
     * The java package separator character.
     */
    private static final String PACKAGE_SEPARATOR = ".";

    /**
     * The xsi:type Qname.
     */
    private static final QName XSI_TYPE_QNAME = new QName(XSI_NS, TYPE);

    /**
     * Gets the appropriate type from checking the xsi:type (if present).  Currently
     * this just assumes any types in a hierarchy are in the same package.
     *
     * @param element the element from which to retrieve the type.
     * @param type the current type.
     * @param namespaces all namespace names keyed by prefix.
     * @return the appropriate type.
     * @throws ClassNotFoundException
     */
    private static Class getAppropriateType(final OMElement element, Class type,
        final Map<String, String> namespaces) throws ClassNotFoundException
    {
        final String xsiTypeName = element.getAttributeValue(XSI_TYPE_QNAME);
        if (xsiTypeName != null)
        {
            final String typeName = getLocalName(xsiTypeName);
            if (!typeName.equals(type.getSimpleName()))
            {
                // TODO: need to handle types that aren't in the same package (we should look up the
                // mapped class here by namespace instead of assuming the same package)
                type = Thread.currentThread().getContextClassLoader().loadClass(
                    type.getPackage().getName() + PACKAGE_SEPARATOR + typeName);
            }
        }
        return type;
    }

    /**
     * Strips the prefix from a type name in the given form: prefix:localName
     * to get the local name.
     *
     * @param typeName the type name with an optional prefix
     * @return the local name.
     */
    private static String getLocalName(final String typeName)
    {
        String localName;
        String[] names = typeName.split(NS_SEPARATOR);
        if (names.length > 1)
        {
            localName = names[1];
        }
        else
        {
            localName = names[0];
        }
        return localName;
    }

    /**
     * First delegate to the Axis2 simple type mapper, if that says
     * its simple, it is, otherwise check to see if the type is an enumeration (typesafe
     * or Java5 version).
     *
     * @param bean the bean to check.
     * @return true/false
     */
    private static boolean isSimpleType(final Object bean)
    {
        return isSimpleType(bean != null ? bean.getClass() : null);
    }

    /**
     * First delegate to the Axis2 simple type mapper, if that says
     * its simple, it is, otherwise check to see if the type is an enumeration (typesafe
     * or Java5 version).
     *
     * @param type the type to check.
     * @return true/false
     */
    private static boolean isSimpleType(final Class type)
    {
        return java.util.Calendar.class.isAssignableFrom(type) ||
               java.util.Date.class.isAssignableFrom(type) ||
               SimpleTypeMapper.isSimpleType(type) ||
               isEnumeration(type);
    }

    private static final String VALUE_OF = "valueOf";

    /**
     * Constructs a type object for the given type and element.
     *
     * @param type the class type to construct.
     * @param element the element containing the value.
     * @return the constructed object or null if one couldn't be constructed.
     * @throws Exception
     */
    @SuppressWarnings("unchecked")
    public static Object getSimpleTypeObject(Class type, OMElement element)
        throws Exception
    {
        Object object = SimpleTypeMapper.getSimpleTypeObject(type, element);
        if (object == null && type != null && element != null)
        {
            if (type.isEnum())
            {
                object = type.getMethod(
                    VALUE_OF, new Class[]{java.lang.String.class}).invoke(
                        type, element.getText());
            }
            else
            {
                final Method fromMethod = getEnumerationFromMethod(type);
                if (fromMethod != null)
                {
                    object = fromMethod.invoke(type, new Object[]{element.getText()});
                }
            }
        }
        return object;
    }

    private static final String FROM = "from";

    /**
     * Indicates whether or not the given type represents an enumeration.
     *
     * @param type the type to check.
     * @return true/false
     */
    private static boolean isEnumeration(final Class type)
    {
        return isEnumeration(type, getEnumerationFromMethod(type));
    }

    /**
     * Indicates whether or not the given type represents an enumeration by checking
     * whether the type is an actual "enum" class or the "fromMethod" is not null.
     *
     * @param type the type to check.
     * @param the "from" method used to construct a typesafe enumeration from it's simple type.
     * @return true/false
     */
    private static boolean isEnumeration(final Class type, final Method fromMethod)
    {
        boolean enumeration = false;
        if (type != null)
        {
            enumeration = type.isEnum();
            if (!enumeration)
            {
                enumeration = fromMethod != null;
            }
        }
        return enumeration;
    }

    /**
     * Gets the "from" method for a type safe enumeration.
     *
     * @param type the type.
     * @return the "from" method (i.e. fromString, etc).
     */
    private static Method getEnumerationFromMethod(final Class type)
    {
        Method fromMethod = null;
        if (type != null)
        {
            // - check for the typesafe enum pattern
            for (final Method method : type.getMethods())
            {
                if (method.getName().startsWith(FROM))
                {
                    final Class[] parameterTypes = method.getParameterTypes();
                    if (parameterTypes.length == 1)
                    {
                        final Class parameterType = parameterTypes[0];
                        if (method.getName().equals(FROM + parameterType.getSimpleName()))
                        {
                            fromMethod = method;
                            break;
                        }
                    }
                }
            }
        }
        return fromMethod;
    }
}