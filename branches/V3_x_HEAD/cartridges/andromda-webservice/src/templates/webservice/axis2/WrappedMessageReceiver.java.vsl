#set ($className = "WrappedMessageReceiver")
#if ($stringUtils.isNotBlank($webserviceTypesPackage))
package $webserviceTypesPackage;
#end

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import javax.xml.namespace.QName;

import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.util.Base64;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.databinding.typemapping.SimpleTypeMapper;
import org.apache.axis2.description.AxisMessage;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.receivers.AbstractInOutSyncMessageReceiver;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * This Axis2 message reciever is used instead of the default {@link org.apache.axis2.rpc.receivers.RPCMessageReceiver}
 * because that one doesn't create responses that comply with the wrapped WSDL generated by AndroMDA.
 */
public class $className
    extends AbstractInOutSyncMessageReceiver 
{
    private static Log log = LogFactory.getLog(${className}.class);

    /**
     * @see org.apache.axis2.receivers.AbstractInOutSyncMessageReceiver#invokeBusinessLogic(org.apache.axis2.context.MessageContext, org.apache.axis2.context.MessageContext)
     */
    public void invokeBusinessLogic(
        MessageContext inMessage,
        MessageContext outMessage)
        throws AxisFault
    {
        Method method = null;
        try
        {
            // get the implementation class for the Web Service
            Object obj = getTheImplementationObject(inMessage);

            Class ImplClass = obj.getClass();

            AxisOperation op = inMessage.getOperationContext().getAxisOperation();
            AxisService service = inMessage.getAxisService();
            OMElement methodElement = inMessage.getEnvelope().getBody().getFirstElement();
            AxisMessage inAxisMessage = op.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);
            String messageNameSpace = null;
            QName elementQName;
            String methodName = op.getName().getLocalPart();
            Method[] methods = ImplClass.getMethods();
            for (int i = 0; i < methods.length; i++)
            {
                if (methods[i].getName().equals(methodName))
                {
                    method = methods[i];
                    break;
                }
            }
            Object resObject = null;
            if (inAxisMessage != null)
            {
                if (inAxisMessage.getElementQName() == null)
                {
                    // method accept empty SOAPbody
                    resObject =
                        method.invoke(
                            obj,
                            new Object[0]);
                }
                else
                {
                    elementQName = inAxisMessage.getElementQName();
                    messageNameSpace = elementQName.getNamespaceURI();
                    OMNamespace namespace = methodElement.getNamespace();
                    if (messageNameSpace != null)
                    {
                        if (namespace == null)
                        {
                            throw new AxisFault("namespace mismatch require " + messageNameSpace + " found none");
                        }
                        if (!messageNameSpace.equals(namespace.getNamespaceURI()))
                        {
                            throw new AxisFault("namespace mismatch require " + messageNameSpace + " found " +
                                methodElement.getNamespace().getNamespaceURI());
                        }
                    }
                    else if (namespace != null)
                    {
                        throw new AxisFault("namespace mismatch. Axis Oepration expects non-namespace " +
                            "qualified element. But received a namespace qualified element");
                    }

                    Object[] objectArray =
                        RPCUtil.processRequest(
                            methodElement,
                            method,
                            inMessage.getAxisService().getObjectSupplier());
                    resObject =
                        method.invoke(
                            obj,
                            objectArray);
                }
            }

            SOAPFactory factory = getSOAPFactory(inMessage);

            // Handling the response
            AxisMessage outaxisMessage = op.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
            if (outaxisMessage != null)
            {
                messageNameSpace = outaxisMessage.getElementQName().getNamespaceURI();
            }

            OMNamespace ns = factory.createOMNamespace(
                    messageNameSpace,
                    service.getSchematargetNamespacePrefix());
            SOAPEnvelope envelope = factory.getDefaultEnvelope();

            OMElement responseElement = factory.createOMElement(
                    getOperationResponseName(method),
                    ns);

            // Java Beans
            final OMElement returnElement =
                getOMElement(
                    resObject,
                    getOperationReturnName(method),
                    service.isElementFormDefault(),
                    factory,
                    ns);

            responseElement.addChild(returnElement);
            envelope.getBody().addChild(responseElement);
            outMessage.setEnvelope(envelope);
        }
        catch (InvocationTargetException e)
        {
            String msg = null;
            Throwable cause = e.getCause();
            if (cause != null)
            {
                msg = cause.getMessage();
            }
            if (msg == null)
            {
                msg = "Exception occurred while trying to invoke service method " + method.getName();
            }
            log.error(
                msg,
                e);
            if (cause instanceof AxisFault)
            {
                throw (AxisFault)cause;
            }
            throw new AxisFault(msg);
        }
        catch (Exception e)
        {
            String msg = "Exception occurred while trying to invoke service method " + method.getName();
            log.error(
                msg,
                e);
            throw new AxisFault(msg, e);
        }
    }

    /**
     * Constructs and OMElement from the given bean
     *
     * @param bean the bean to introspect
     * @param elementName the name of the element
     * @param qualified whether or not the resulting document should be qualified
     * @param factory the SOAP factory instance used to create the OMElement
     * @param namespace the namespace to add to each element.
     */
    public static OMElement getOMElement(
        final Object bean,
        final String elementName,
        final boolean qualified,
        final SOAPFactory factory,
        final OMNamespace namespace)
    {
        return getOMElement(
            bean,
            elementName,
            qualified,
            factory,
            namespace,
            new ArrayList());
    }

    private static final String CLASS = "class";

    /**
     * Constructs and OMElement from the given bean
     *
     * @param bean the bean to introspect
     * @param elementName the name of the element\
     * @param qualified whether or not the resulting document should be qualified
     * @param factory the SOAP factory instance used to create the OMElement
     * @param namespace the namespace to add to each element.
     * @param evaluatingBeans the collection in which to keep the beans that are evaluating in order
     *        to prevent endless recursion.
     */
    private static OMElement getOMElement(
        final Object bean,
        final String elementName,
        final boolean qualified,
        final SOAPFactory factory,
        final OMNamespace namespace,
        final Collection evaluatingBeans)
    {
        final OMElement element = factory.createOMElement(
                elementName,
                namespace);
        if (bean != null && evaluatingBeans != null && !evaluatingBeans.contains(bean))
        {
            evaluatingBeans.add(bean);
            if (SimpleTypeMapper.isSimpleType(bean))
            {
                element.addChild(
                    factory.createOMText(SimpleTypeMapper.getStringValue(bean)));
            }
            else if (bean instanceof byte[])
            {
                element.addChild(factory.createOMText(Base64.encode((byte[])bean)));
            }
            else 
            {
                final Class beanType = bean.getClass();
                if (beanType.isArray())
                {
                    final String arrayComponentName = getArrayElementName(beanType.getComponentType());
                    for (int ctr = 0; ctr < Array.getLength(bean); ctr++)
                    {
                        element.addChild(
                            getOMElement(
                                Array.get(bean, ctr),
                                arrayComponentName,
                                qualified,
                                factory,
                                namespace,
                                evaluatingBeans));
                    }
                }    
                try
                {
                    final java.util.Map properties = PropertyUtils.describe(bean);
                    for (final Iterator iterator = properties.keySet().iterator(); iterator.hasNext();)
                    {
                        final String name = (String)iterator.next();
                        final java.beans.PropertyDescriptor descriptor =
                            org.apache.commons.beanutils.PropertyUtils.getPropertyDescriptor(
                                bean,
                                name);
                        if (descriptor != null)
                        {
                            final Object value = properties.get(name);
                            if (!CLASS.equals(name))
                            {
                                if (value != null)
                                {
                                    boolean addToDocument = true;
                                    if (value.getClass().isArray())
                                    {
                                        addToDocument = Array.getLength(value) > 0;
                                    }
                                    if (addToDocument)
                                    {
                                        element.addChild(
                                            getOMElement(
                                                value,
                                                name,
                                                qualified,
                                                factory,
                                                namespace,
                                                evaluatingBeans));
                                    }
                                }
                            }
                        }
                    }
                }
                catch (final Throwable throwable)
                {
                    throw new RuntimeException(throwable);
                }
            }
            evaluatingBeans.remove(bean);
        }
        return element;
    }

    private static final String RESPONSE = "Response";

    private static String getOperationResponseName(final Method method)
    {
        return method.getName() + RESPONSE;
    }

    private static final String RETURN = "Return";

    private static String getOperationReturnName(final Method method)
    {
        return method.getName() + RETURN;
    }

    private static String getArrayElementName(final Class componentType)
    {
        String elementName = TypeMappings.getSchemaType(componentType);
        if (StringUtils.isBlank(elementName))
        {
            elementName = StringUtils.uncapitalize(componentType.getName().replaceAll(
                ".*\\.",
            ""));
        }
        return elementName;
    }
}