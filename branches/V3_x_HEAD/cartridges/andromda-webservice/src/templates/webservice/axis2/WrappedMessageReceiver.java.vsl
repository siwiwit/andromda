#set ($className = "WrappedMessageReceiver")
#if ($stringUtils.isNotBlank($webserviceTypesPackage))
package $webserviceTypesPackage;
#end

import org.apache.axiom.om.OMAbstractFactory;
import org.apache.axiom.om.OMElement;
import org.apache.axiom.om.OMFactory;
import org.apache.axiom.om.OMNamespace;
import org.apache.axiom.om.util.Base64;
import org.apache.axiom.soap.SOAPEnvelope;
import org.apache.axiom.soap.SOAPFactory;
import org.apache.axis2.AxisFault;
import org.apache.axis2.context.MessageContext;
import org.apache.axis2.databinding.typemapping.SimpleTypeMapper;
import org.apache.axis2.description.AxisMessage;
import org.apache.axis2.description.AxisOperation;
import org.apache.axis2.description.AxisService;
import org.apache.axis2.engine.ObjectSupplier;
import org.apache.axis2.receivers.AbstractInOutSyncMessageReceiver;
import org.apache.axis2.wsdl.WSDLConstants;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.xml.namespace.QName;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

/**
 * This Axis2 message receiver is used instead of the default {@link org.apache.axis2.rpc.receivers.RPCMessageReceiver}
 * because that one doesn't create responses that comply with the wrapped WSDL generated by AndroMDA.
 *
 * @author <a href="chad@andromda.org">Chad Brandon</a>
 * @author <a href="wouter@andromda.org">Wouter Zoons</a>
 */
public class $className extends AbstractInOutSyncMessageReceiver
{
    private static Log log = LogFactory.getLog(${className}.class);

    /**
     * Finds the first occurrence of the method with the given name in the argument type.
     *
     * @param type the class to introspect
     * @param name the method's name
     * @return the method, or {@code null} if none could be found
     */
    private static Method findFirstMethodByName(Class type, String name)
    {
        Method namedMethod = null;

        for (int i = 0; i < type.getMethods().length && namedMethod == null; i++)
        {
            final Method method = type.getMethods()[i];
            if (method.getName().equals(name))
            {
                namedMethod = method;
            }
        }

        return namedMethod;
    }

    /**
     * @see org.apache.axis2.receivers.AbstractInOutSyncMessageReceiver#invokeBusinessLogic(org.apache.axis2.context.MessageContext, org.apache.axis2.context.MessageContext)
     */
    public void invokeBusinessLogic(MessageContext inMessage, MessageContext outMessage)
        throws AxisFault
    {
        // determine the target webservice instance
        final Object service = this.getTheImplementationObject(inMessage);

        // determine the SOAP operation which was called
        final AxisOperation axisServiceOperation = inMessage.getOperationContext().getAxisOperation();

        // search the corresponding method on the service class
        // the first method with a matching name will be taken; this is sufficient as we know there is no overloading
        // when using wrapped SOAP webservices
        final Method serviceOperation = findFirstMethodByName(service.getClass(), axisServiceOperation.getName().getLocalPart());

        // get the actual message that was sent to us
        final AxisMessage inAxisMessage = axisServiceOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE);

        try
        {
            if (inAxisMessage != null)
            {
                Object response;

                final AxisService axisService = inMessage.getAxisService();
                final OMElement methodElement = inMessage.getEnvelope().getBody().getFirstElement();

                if (inAxisMessage.getElementQName() == null)
                {
                    // accept an empty SOAP body
                    response = serviceOperation.invoke(service);
                }
                else
                {
                    final QName elementQName = inAxisMessage.getElementQName();
                    final String messageNamespace = elementQName.getNamespaceURI();
                    final OMNamespace namespace = methodElement.getNamespace();

                    if (messageNamespace != null)
                    {
                        if (namespace == null)
                        {
                            throw new AxisFault("Namespace mismatch: required " + messageNamespace + ", found none");
                        }
                        if (!messageNamespace.equals(namespace.getNamespaceURI()))
                        {
                            throw new AxisFault("Namespace mismatch: required " + messageNamespace + ", found " +
                                namespace.getNamespaceURI());
                        }
                    }
                    else if (namespace != null)
                    {
                        throw new AxisFault("Namespace mismatch: Axis operation expects non-namespace " +
                            "qualified element but received a namespace qualified element: " + namespace);
                    }

                    response = serviceOperation.invoke(service,
                        deserialize(methodElement, serviceOperation, axisService.getObjectSupplier()) );
                }

                // Handling the response
                final AxisMessage outAxisMessage = axisServiceOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE);

                if (outAxisMessage != null)
                {
                    final SOAPFactory soapFactory = getSOAPFactory(inMessage);

                    final String messageNamespace = outAxisMessage.getElementQName().getNamespaceURI();
                    final OMNamespace namespace = soapFactory.createOMNamespace(
                            messageNamespace, axisService.getSchematargetNamespacePrefix());
                    final SOAPEnvelope envelope = soapFactory.getDefaultEnvelope();

                    final OMElement responseElement;

                    // everything went well, just return the response
                    responseElement = soapFactory.createOMElement(serviceOperation.getName() + "Response", namespace);

                    final OMElement returnElement = createOMElement(response, serviceOperation.getName() + "Return",
                        namespace );

                    responseElement.addChild(returnElement);

                    envelope.getBody().addChild(responseElement);
                    outMessage.setEnvelope(envelope);
                }
            }
        }
        catch (InvocationTargetException serviceOperationExceptionWrapper)
        {
            final Throwable cause = serviceOperationExceptionWrapper.getCause();

            // the service operation threw an exception, we'll return it here
            final OMElement faultElement = createOMElement(cause, cause.getClass().getSimpleName(),
                inMessage.getEnvelope().getBody().getFirstElement().getNamespace() );
            throw new AxisFault(new QName(serviceOperation.getName()), cause.getMessage(), null, null, faultElement);
        }
        catch (Exception exception)
        {
            log.error("Exception occurred while trying to invoke service method " + serviceOperation.getName(), exception);
            throw AxisFault.makeFault(exception);
        }
    }

    private static final String CLASS = "class";

    private static String getArrayElementName(final Class componentType)
    {
        String elementName = TypeMappings.getSchemaType(componentType);
        if (StringUtils.isBlank(elementName))
        {
            elementName = StringUtils.uncapitalize(componentType.getName().replaceAll(".*\\.", ""));
        }
        return elementName;
    }

    /**
     * Deserializes the arguments of <code>element</code> to the arguments of the given <code>method</code>.
     *
     * @param element the XML OMElement
     * @param method the method from which to deserialize the arguments.
     * @param objectSupplier the "object supplier" used to construct objects from given classes.
     * @return the deserialized arguments.
     */
    public static Object[] deserialize(final OMElement element, final Method method, final ObjectSupplier objectSupplier)
    {
        int ctr = 0;
        final Class[] types = method.getParameterTypes();
        final Object[] arguments = new Object[types.length];
        for (final Iterator iterator = element.getChildElements(); iterator.hasNext(); ctr++)
        {
            final OMElement childElement = (OMElement)iterator.next();
            final Class type = types[ctr];
            arguments[ctr] = deserialize(childElement, type, objectSupplier);
        }
        return arguments;
    }

    /**
     * Deserializes the given <code>element</code> to the given <code>type</code>.
     *
     * @param element the XML OMElement
     * @param type the java type.
     * @param objectSupplier the "object supplier" used to construct objects from given classes.
     * @return the deserialized object.
     */
    public static Object deserialize(OMElement element, final Class type, final ObjectSupplier objectSupplier)
    {
        Object bean;
        if (isSimpleType(type))
        {
             bean = getSimpleTypeObject(type, element);
        }
        else if (type == byte[].class)
        {
            bean = Base64.decode(element.getText());
        }
        else
        {
            if (type.isArray())
            {
                final Collection<Object> elements = new ArrayList<Object>();
                for (final Iterator iterator = element.getChildElements(); iterator.hasNext();)
                {
                    elements.add(deserialize((OMElement)iterator.next(), type.getComponentType(), objectSupplier));
                }
                bean = elements.toArray((Object[])Array.newInstance(type.getComponentType(), 0));
            }
            else
            {
                try
                {
                    bean = objectSupplier.getObject(type);
                    final java.beans.PropertyDescriptor[] descriptors = PropertyUtils.getPropertyDescriptors(type);
                    for (final PropertyDescriptor descriptor : descriptors)
                    {
                        final String name = descriptor.getName();
                        if (!CLASS.equals(name))
                        {
                            final OMElement propertyElement = findElementByName(element, name);
                            if (propertyElement != null)
                            {
                                PropertyUtils.setProperty(bean, name,
                                    deserialize(propertyElement, descriptor.getPropertyType(), objectSupplier));
                            }
                        }
                    }
                }
                catch (final Throwable throwable)
                {
                    throw new RuntimeException(throwable);
                }
            }
        }
        return bean;
    }

    /**
     * Finds an element having the given <code>name</code> from the child elements on the given
     * <code>element</code>.
     *
     * @param element the element to search.
     * @param name the name of the element to find.
     * @return the found element or null if one couldn't be found.
     */
    private static OMElement findElementByName(final OMElement element, final String name)
    {
        OMElement found = null;
        for (final Iterator iterator = element.getChildElements(); iterator.hasNext();)
        {
            final OMElement child = (OMElement)iterator.next();
            if (child.getLocalName().equals(name))
            {
                found = child;
                break;
            }
        }
        return found;
    }

    /**
     * Constructs an OMElement from the given bean
     *
     * @param bean the bean to introspect
     * @param elementName the name of the element
     * @param namespace the namespace to add to each element.
     * @return the newly created element
     */
    public static OMElement createOMElement(
        final Object bean,
        final String elementName,
        final OMNamespace namespace)
    {
        return createOMElement(bean, elementName, OMAbstractFactory.getOMFactory(), namespace, new ArrayList<Object>());
    }

    /**
     * Constructs an OMElement from the given bean
     *
     * @param bean the bean to introspect
     * @param elementName the name of the element
     * @param factory the SOAP factory instance used to create the OMElement
     * @param namespace the namespace to add to each element.
     * @param evaluatingBeans the collection in which to keep the beans that are evaluating in order
     *        to prevent endless recursion.
     * @return the newly created element
     */
    private static OMElement createOMElement(
        final Object bean,
        final String elementName,
        final OMFactory factory,
        final OMNamespace namespace,
        final Collection<Object> evaluatingBeans)
    {
        final OMElement element = factory.createOMElement(elementName, namespace);

        if (bean != null && evaluatingBeans != null && !evaluatingBeans.contains(bean))
        {
            evaluatingBeans.add(bean);
            if (isSimpleType(bean))
            {
                element.addChild(factory.createOMText(SimpleTypeMapper.getStringValue(bean)));
            }
            else if (bean instanceof byte[])
            {
                element.addChild(factory.createOMText(Base64.encode((byte[])bean)));
            }
            else
            {
                final Class beanType = bean.getClass();
                if (beanType.isArray())
                {
                    final String arrayComponentName = getArrayElementName(beanType.getComponentType());
                    for (Object beanArrayElement : (Object[])bean)
                    {
                        element.addChild(createOMElement(beanArrayElement, arrayComponentName, factory, namespace, evaluatingBeans));
                    }
                }
                try
                {
                    final Map properties = describe(bean);

                    for (Object propertyKey : properties.keySet())
                    {
                        final String name = (String)propertyKey;
                        if (!CLASS.equals(name))
                        {
                            final Object value = properties.get(name);
                            if (value != null)
                            {
                                boolean addToDocument = true;
                                if (value.getClass().isArray())
                                {
                                    addToDocument = Array.getLength(value) > 0;
                                }
                                if (addToDocument)
                                {
                                    element.addChild(createOMElement(value, name, factory, namespace, evaluatingBeans));
                                }
                            }
                        }
                    }
                }
                catch (final Throwable throwable)
                {
                    throw new RuntimeException(throwable);
                }
            }
            evaluatingBeans.remove(bean);
        }
        return element;
    }

    /**
     * First delegate to the Axis2 simple type mapper, if that says
     * its simple, it is, otherwise check to see if the type is an enumeration (typesafe
     * or Java5 version).
     *
     * @param bean the bean to check.
     * @return true/false
     */
    private static boolean isSimpleType(final Object bean)
    {
        return isSimpleType(bean != null ? bean.getClass() : null);
    }

    /**
     * First delegate to the Axis2 simple type mapper, if that says
     * its simple, it is, otherwise check to see if the type is an enumeration (typesafe
     * or Java5 version).
     *
     * @param type the type to check.
     * @return true/false
     */
    private static boolean isSimpleType(final Class type)
    {
        return java.util.Calendar.class.isAssignableFrom(type) ||
               java.util.Date.class.isAssignableFrom(type) ||
               SimpleTypeMapper.isSimpleType(type) ||
               isEnumeration(type);
    }

    /**
     * Constructs a type object for the given type and element.
     *
     * @param type the class type to construct.
     * @param element the element containing the value.
     * @return the constructed object or null if one couldn't be constructed.
     * @throws IllegalArgumentException in case the element's text could not be mapped and invoked on an operation
     *  from the argument type
     */
    public static Object getSimpleTypeObject(Class type, OMElement element)
        throws IllegalArgumentException
    {
        Object object = SimpleTypeMapper.getSimpleTypeObject(type, element);
        if (object == null && type != null && element != null)
        {
            if (type.isEnum())
            {
                try
                {
                    object = type.getMethod("valueOf", String.class).invoke(type, element.getText());
                }
                catch (Exception e)
                {
                    log.fatal("Unable to call valueOf on enum: " + object);
                }
            }
            else
            {
                final Method fromMethod = getEnumerationFromMethod(type);
                if (fromMethod != null)
                {
                    try
                    {
                        object = fromMethod.invoke(type, element.getText());
                    }
                    catch (Exception e)
                    {
                        throw new IllegalArgumentException("Unable to call requested method on object", e);
                    }
                }
            }
        }
        return object;
    }

    /**
     * Indicates whether or not the given type represents an enumeration.
     *
     * @param type the type to check.
     * @return true/false
     */
    private static boolean isEnumeration(final Class type)
    {
        return isEnumeration(type, getEnumerationFromMethod(type));
    }

    /**
     * Indicates whether or not the given type represents an enumeration by checking
     * whether the type is an actual "enum" class or the "fromMethod" is not null.
     *
     * @param type the type to check.
     * @param fromMethod the "from" method used to construct a typesafe enumeration from it's simple type.
     * @return true/false
     */
    private static boolean isEnumeration(final Class type, final Method fromMethod)
    {
        boolean enumeration = false;
        if (type != null)
        {
            enumeration = type.isEnum();
            if (!enumeration)
            {
                enumeration = fromMethod != null;
            }
        }
        return enumeration;
    }

    /**
     * Gets the "from" method for a type safe enumeration.
     *
     * @param type the type.
     * @return the "from" method (i.e. fromString, etc).
     */
    private static Method getEnumerationFromMethod(final Class type)
    {
        Method fromMethod = null;
        if (type != null)
        {
            // - check for the typesafe enum pattern
            for (final Method method : type.getMethods())
            {
                if (method.getName().startsWith("from"))
                {
                    final Class[] parameterTypes = method.getParameterTypes();
                    if (parameterTypes.length == 1)
                    {
                        final Class parameterType = parameterTypes[0];
                        if (method.getName().equals("from" + parameterType.getSimpleName()))
                        {
                            fromMethod = method;
                            break;
                        }
                    }
                }
            }
        }
        return fromMethod;
    }

    /**
     * Returns a property map representing the accessible properties from the argument bean. Only properties
     * not declared by classes in the JDK will be considered (otherwise we could have used Jakarta Commons BeanUtils
     * to do this job for us).
     *
     * @param bean the bean to introspect
     * @return the property map
     * @throws RuntimeException in case an error occurred while retrieving a property value
     */
    private static Map<String, Object> describe(Object bean)
    {
        // the treemap will ensure us a predictable (alphabetical) order
        // that way the WSDL wouldn't change for no real reason
        final Map<String, Object> propertyMap = new TreeMap<String, Object>();

        // get all public methods
        final Method[] methods = bean.getClass().getMethods();

        for (Method method : methods)
        {
            // do not take methods from the JDK into account, we only want to consider those that have been modeled
            // (eg. this could happen for <<Exception>> types, which would extend java.lang.Exception)
            if (!method.getDeclaringClass().getName().startsWith("java."))
            {
                // decide whether or not this method is a getter
                int getterNameOffset;

                if (method.getName().startsWith("is"))
                {
                    getterNameOffset = 2;
                }
                else if (method.getName().startsWith("get"))
                {
                    getterNameOffset = 3;
                }
                else
                {
                    getterNameOffset = -1; // not a getter
                }

                if (getterNameOffset != -1 && method.getParameterTypes().length == 0 && !method.getReturnType().equals(Void.class))
                {
                    // deduce the property name by stripping the 'is' or 'get' prefix and uncapitalizing
                    final char[] methodNameCharacters = method.getName().toCharArray();
                    final char[] propertyNameCharacters = new char[methodNameCharacters.length - getterNameOffset];
                    System.arraycopy(methodNameCharacters, getterNameOffset, propertyNameCharacters, 0, propertyNameCharacters.length);
                    propertyNameCharacters[0] = Character.toLowerCase(propertyNameCharacters[0]);

                    final String propertyName = String.valueOf(propertyNameCharacters);

                    try
                    {
                        propertyMap.put(propertyName, method.invoke(bean));
                    }
                    catch (Exception e)
                    {
                        throw new RuntimeException("Unable to build property map for " + bean, e);
                    }
                }
            }
        }

        return propertyMap;
    }
}
