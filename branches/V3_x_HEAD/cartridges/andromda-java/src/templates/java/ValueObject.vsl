// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: ValueObject.vsl in andromda-java-cartridge.
//
#if ($stringUtils.isNotBlank($class.packageName))
package $class.packageName;
#end

/**
$class.getDocumentation(" * ")
 */
public#if($class.abstract) abstract#end class $class.name
#if($class.generalization)
    extends $class.generalization.fullyQualifiedName
#end
#if ($serializable)
    implements java.io.Serializable
#end
{
#if ($serializable)
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = ${class.serialVersionUID}L;

#end
##
##  default constructor
##
#if ($class.requiredConstructorParameters.size() > 0 || $class.allRequiredConstructorParameters.size() > $class.requiredConstructorParameters.size())
    public ${class.name}()
    {
#if($class.generalization)
        super();
#end
    }

#end
##
##  constructor taking only required properties
##
#if ($class.allProperties.size() > $class.allRequiredConstructorParameters.size() && ($class.allRequiredConstructorParameters.size() != 1 || !$class.allRequiredConstructorParameters.get(0).getterSetterTypeName.equals($class.fullyQualifiedName)))
    public ${class.name}(## no newline
#set ($comma = "")
#foreach ($property in $class.allRequiredConstructorParameters)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
)
    {
#if($class.generalization)
        super(## no newline
#set ($comma = "")
#foreach ($property in $class.generalization.allRequiredConstructorParameters)
${comma}${property.name}## no newline
#set ($comma = ", ")
#end
);
#end
#foreach ($property in $class.requiredConstructorParameters)
        this.${property.name} = ${property.name};
#end
    }

#end
##
##  constructor taking all properties
##
#if ($class.allProperties.size() != 1 || !$class.allProperties.get(0).getterSetterTypeName.equals($class.fullyQualifiedName))
    public ${class.name}(## no newline
#set ($comma = "")
#foreach ($property in $class.allProperties)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
)
    {
#if($class.generalization)
        super(## no newline
#set ($comma = "")
#foreach ($property in $class.generalization.allProperties)
${comma}${property.name}## no newline
#set ($comma = ", ")
#end
);
#end
#foreach ($property in $class.properties)
        this.${property.name} = ${property.name};
#end
    }

#end
    /**
     * Copies constructor from other ${class.name}
     *
     * @param otherBean, cannot be <code>null</code>
     * @throws java.lang.NullPointerException if the argument is <code>null</code>
     */
    public ${class.name}(${class.name} otherBean)
    {
        this(## no newline
#set ($comma = "")
#foreach ($property in $class.allProperties)
${comma}otherBean.${property.getterName}()## no newline
#set ($comma = ", ")
#end
);
    }

    /**
     * Copies all properties from the argument value object into this value object.
     */
    public void copy(${class.name} otherBean)
    {
        if (otherBean != null)
        {
#foreach ($property in $class.allProperties)
            this.${property.setterName}(otherBean.${property.getterName}());
#end
        }
    }

#foreach ($attribute in $class.attributes)
    private $attribute.getterSetterTypeName $attribute.name#if ($attribute.defaultValuePresent) = $attribute.defaultValue#end;

    /**
$attribute.getDocumentation("     * ")
     */
    public $attribute.getterSetterTypeName ${attribute.getterName}()
    {
        return this.${attribute.name};
    }

## - always have as public, having read-only causes too many issues when attempting to
##   use in other cartridges
    public void ${attribute.setterName}($attribute.getterSetterTypeName $attribute.name)
    {
        this.${attribute.name} = $attribute.name;
    }

#end
## Generate the relation methods.
#foreach ($associationEnd in $class.associationEnds)
#set ($target = $associationEnd.otherEnd)
#if ($target.navigable)
    private $target.getterSetterTypeName $target.name;

    /**
     * Get the $target.name
$target.getDocumentation("     * ")
     */
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

## - always have as public, having read-only causes too many issues when attempting to
##   use in other cartridges
    /**
     * Sets the $target.name
     */
    public void ${target.setterName}($target.getterSetterTypeName $target.name)
    {
        this.${target.name} = ${target.name};
    }

#end
#end
##
##
##      equality methods
##
##
## only render the macro in case there are properties to include
#if (!$class.properties.empty && $generateEqualPropertiesMethod)
    /**
     * Compares the properties of this instance to the properties of the argument. This method will return
     * {@code false} as soon as it detects that the argument is {@code null} or not of the same type as
     * (or a sub-type of) this instance's type.
     *
     * <p/>For array, collection or map properties the comparison will be done one level deep, in other words:
     * the elements will be compared using the {@code equals()} operation.
     *
     * <p/>Note that two properties will be considered equal when both values are {@code null}.
     *
     * @param thatObject the object containing the properties to compare against this instance
     * @return this method will return {@code true} in case the argument has the same type as this class, or is a
     *      sub-type of this class and all properties as found on this class have equal values when queried on that
     *      argument instance; in all other cases this method will return {@code false}
     */
    public boolean equalProperties(java.lang.Object thatObject)
    {
        if (thatObject == null || !this.getClass().isAssignableFrom(thatObject.getClass()))
        {
            return false;
        }

        final ${class.fullyQualifiedName} that = (${class.fullyQualifiedName})thatObject;

#if ($class.generalization)
        return super.equalProperties(that)
#set ($operator = "&& ")
#else
        return
#set ($operator = "")
#end
#foreach ($property in $class.properties)
## no identifiers and constants, the 'constant' feature is defined in NmsEntity (= read-only and static)
#if (!$property.constant && !$property.identifier)
            ${operator}equal(this.${property.getterName}(), that.${property.getterName}())
#set ($operator = "&& ")
#end
#end
        ;
    }

#if (!$class.generalization)
    /**
     * This is a convenient helper method which is able to detect whether or not two values are equal. Two values
     * are equal when they are both {@code null}, are arrays of the same length with equal elements or are
     * equal objects (this includes {@link java.util.Collection} and {@link java.util.Map} instances).
     *
     * <p/>Note that for array, collection or map instances the comparison runs one level deep.
     *
     * @param first the first object to compare, may be {@code null}
     * @param first the second object to compare, may be {@code null}
     * @return this method will return {@code true} in case both objects are equal as explained above;
     *      in all other cases this method will return {@code false}
     */
    protected static boolean equal(java.lang.Object first, java.lang.Object second)
    {
        final boolean equal;

        if (first == null)
        {
            equal = second == null;
        }
        else if (first.getClass().isArray() && (second != null) && second.getClass().isArray())
        {
            equal = java.util.Arrays.equals((java.lang.Object[])first, (java.lang.Object[])second);
        }
        else // note that the following also covers java.util.Collection and java.util.Map
        {
            equal = first.equals(second);
        }

        return equal;
    }

#end
#end
    // ${class.fullyQualifiedName} value-object java merge-point
}