<?xml version="1.0"?>

<document> 
	<properties>
    	<title>Developing Metafacades</title> 
    </properties>
  	<body> 
  		<section name="Take your time!">
  		    <p>
      		    Writing your own metafacades is a non-trivial task, if you do
      		    it for the first time. You should close the door and get yourself
      		    at least two days in a quiet atmosphere, reducing the context
      		    switches in your mind to a minimum. Otherwise, it might be
      		    a pain! :-)
            </p>
            <p>
                The next section assumes you have brewed a good cup of coffee
                (or tea or whatever) and have at least two hours of time
                Take a deep breath and start to prepare your working environment.
            </p>  		    
        </section>

  		<section name="Preparing the working environment">
  		    <p>
  		        First, make sure you have the correct directory structure
  		        on disk to keep all the artifacts you need to develop an
  		        AndroMDA cartridge. The easiest way to get such a correct
  		        directory structure is to copy an existing cartridge that
  		        already contains its own metafacades. A good example for
  		        this is the Hibernate cartridge.
  		    </p>
  		    <p>
  		        After you copied the cartridge, you will see a directory
  		        structure like this:
  		    </p>
  		    <source>
src/java
src/templates
src/uml
  		    </source>
  		    <p>
  		        Metafacades are generated from a UML model. Put this UML model 
  		        in a file into the <code>src/uml</code> directory. Open 
  		        MagicDraw and import the basic metafacades module which is 
  		        shipped with AndroMDA. These basic metafacades for UML are in 
  		        the model file <code>andromda/xml.zips/UMLMetafacadeModel-*.xml.zip</code> 
				located in the AndroMDA binary distribution.
  		        You import them using the "File, Import..." menu in MagicDraw. After the import, you should be 
  		        able to see the basic facade classes (like ClassifierFacade, 
  		        etc.) but MagicDraw should show them as read-only.
  		    </p>
  		    <p>
  		        The next step is to model your own metafacades.
  		    </p>
  		    
		</section>

  		<section name="Modeling rules for your own metafacades">
  		    <subsection name="Recap about how metafacades work">
      		    <p>
      		        Later, the user of your cartridge will load a model into 
      		        AndroMDA and will try to run your cartridge. At that time, the 
      		        metadata repository in AndroMDA will instantiate a metaobject 
      		        for each element of the user's model. After this, AndroMDA
      		        optionally instantiates a metafacade object that shields
      		        the metaobject.
                </p>
            </subsection>
            <subsection name="Terms used to distinguish classes">
                <p>
                    We choose the following terms when we speak about
                    metafacades:
                </p>
                <ul>
                    <li>A class of the metamodel is called a metaclass.</li>
                    <li>An instance of a metaclass is called a metaobject.</li>
                    <li>A class representing a metafacade is called a metafacade class.</li>
                </ul>
                <p>
                    So, don't confuse a metafacade class with a metaclass!
                </p>
            </subsection>
            <subsection name="Modeling rules">
                <p>
                    Now, there is a rule that tells you how to shield a metaclass
                    with a metafacade. A metafacade class must choose exactly one
                    of two ways to relate to a metaclass:
                </p>
                <ul>
                    <li>The metafacade class has a direct dependency on the metaclass.</li>
                    <li>The metafacade class specializes another metafacade
                        class and (in this case) must not have a dependency
                        to a metaclass (because the topmost of the superclasses of
                        the metafacade class already has the dependency).</li>
                </ul>        
                <p>
                    There are two rules how to add stereotypes to the classes:
                </p>
                <ul>
                    <li>The metaclass must have the stereotype "metaclass".</li>
                    <li>The metafacade class must have the stereotype "metafacade".</li>
                </ul>        
                <p>
                    That's it. No more rules for modeling metafacades.
                </p>
            </subsection>
            
		</section>

        <section name="What you will get from the metafacade model">
            <p>
                A metafacade can have attributes, operations and associations
                to other metafacade classes. It can also specialize another
                metafacade class. Let's talk about what it means if you add
                various things to a metafacade class.
            </p>
            <p>
                The code for the metafacades will be generated by the
                andromda-meta cartridge. (Cool: you use AndroMDA to develop a cartridge 
                that extends AndroMDA!). Each model element that you add to a 
                metafacade class will later be translated by andromda-meta into
                a bunch of Java elements. The following table shows you which
                model element will be translated to which Java element:
            </p>
            <table>
                <tr><th>Model element</th><th>Java element</th></tr>
                <tr><td>Attribute</td>
                    <td>Pair of abstract getter/setter</td>
                </tr>
                <tr><td>Operation</td>
                    <td>Abstract method</td>
                </tr>
                <tr><td>Association</td>
                    <td>Pair of abstract getter/setter</td>
                </tr>
                <tr><td>Dependency</td>
                    <td>Ignored except when the target of the dependency
                        is a metaclass. In that case, a constructor with
                        an argument of the metaclass type is generated.
                    </td>
                </tr>
                <tr><td>Specialization</td>
                    <td>Same constructor as in the dependency case except
                        that this constructor calls the "superfacade" constructor.
                    </td>
                </tr>
            </table>
            <p>
                A metaclass itself translates to three classes in Java:
            </p>
            <ul>
                <li>An interface with the method signatures of all
                    generated methods in the metafacade.</li>
                <li>A class with automatically generated plumbing logic.
                    This is called the "logic" class.</li>
                <li>An implementation class which is hand-written.</li>
            </ul>
            <p>
                To be continued...
            </p>
        </section>

  	</body> 
</document>
