<?xml version="1.0"?>

<document>

    <properties>
        <author email="mattes3@users.sourceforge.net">Matthias Bohlen</author>
        <author email="chdbrandon@yahoo.com">Chad Brandon</author>
        <title>AndroMDA Metafacades</title>
        <gennews>no</gennews>
    </properties>

    <body>

        <section name="AndroMDA Metafacades">
            <p class="std">
                <strong>AndroMDA Metafacades</strong> are facades that are used
                to provide access to models loaded by a repository.  These 
                "metafacades" shield us from the underlying meta model implementation.
                Meta models are MOF modules such as UML 1.4, UML 2.0, etc.  Metafacades
                are generated by the <a href="../andromda-meta-cartridge/index.html">andromda-meta-cartridge</a>.
            </p>
            <p>
                Metafacades (as explained below) are the object-oriented API that allows
                access to the model from within the templates. Using metafacades,
                the templates become much simpler and straightforward because
                the intelligence and responsibility for code transformation
                and generation is centralized in Java objects, not
                in the template script language.
            </p>
        </section>

        <section name="Introduction: The basics of metamodeling">
            <p> 
                The MOF repository instantiates a Java object for each element in your 
                model that you load into AndroMDA. The class of that object is 
                part of the UML metamodel. In MDA-speak, the instantiated graph
                of metamodel objects is called an "abstract syntax tree (AST)".
            </p>
            <p>
                Example: When you model the attribute of a class, an instance of 
                the metaclass "Attribute" is instantiated. The "birth:Date" attribute 
                of a model element "Person" will be instantiated as:
            </p>
            <ol>
                <li>
                    one object of class "Attribute" with 
                    its attribute "name" set to "birth"
                </li>
                <li>
                    one object of class "UMLClass" with its attribute 
                    "name" set to "Person" and a reference to the 
                    Attribute object that has the name "birth". 
                </li>
            </ol>
            <p>
                Look at this UML diagram to get the idea:
            </p>
            <img src="images/PersonExample.jpg" />
            <p>
                To see the complete UML metamodel, read 
                <a href="resources/UML14Metamodel.pdf">UML14Metamodel.pdf</a>.
                You will see the metamodel of UML 1.4, documented in UML itself.
                The "Attribute" class and all the other interesting metaclasses are 
                documented there.
            </p>
        </section>

        <section name="Metaclasses are 'data only'">
            <p> 
                Now that we have all these nice little AST objects representing our 
                model, we notice that they all have very little behaviour - they 
                are just data holders for the metainformation from our model. It 
                would certainly be nice to attach behaviour to them to support
                code generation. For example: 
                A <code>UMLClass</code> metaobject that represents an 
                <code><![CDATA[<<Entity>>]]></code> could validate itself and check 
                if it has at least one <code>Attribute</code> metaobject representing a 
                <code><![CDATA[<<PrimaryKey>>]]></code> - this would be plain,
                clear and simple, right? 
                Now, why don't we simply write a class <code>EntityClass</code> that 
                extends the class <code>UMLClass</code>? Just like this:
            </p> 
<pre>
    public class EntityClass extends UMLClass {
        public void validate() throws ... {
            // throw exception here if PrimaryKey not found...
        }
    }
</pre>
                <p>Another example:</p>
<pre>
    public class SpecialAttribute extends Attribute {
        public String getGetterName() {
            return "get" + uppercaseFirstLetter(getName());
        }
    }
</pre>
            <p> 
                We could then use the class <code>SpecialAttribute</code> 
                instead of the class <code>Attribute</code> and write
                <code>$att.getterName</code> in our
                template script. The template engine would call the
                <code>getGetterName()</code> method shown above.
            </p> 
            <p> 
                Nice, object-oriented way to do something, right? Reality
                is not that simple, though. Keep on reading...
            </p> 
        </section>
        
        <section name="Classes that cannot be extended">
            <p> 
                Well, extending metaclasses would be nice, indeed! However, 
                there is no source or JAR file for those classes because 
                Netbeans MDR instantiates them on the fly through byte code 
                generation (absolutely magic!).  
            </p> 
            <p> 
                For those of you who want to see the magic, here are two
                interesting links into the MDR source files:
            </p>
            <ul> 
                <li><a href="http://mdr.netbeans.org/source/browse/mdr/src/org/netbeans/mdr/util/ImplGenerator.java">
                  ImplGenerator.java
                </a></li> 
                <li><a href="http://mdr.netbeans.org/source/browse/mdr/src/org/netbeans/mdr/handlers/MDRClassLoader.java">
                   MDRClassLoader.java
                </a></li>
            </ul>
            <p>
                So what can we do here? Since inheritance is impossible
                and the interface of a UML metaobject is quite complex,
                we use the GoF facade pattern and shield that complexity
                behind a quite lean interface that can easily be understood.
                We also abstract from the particular version of a metamodel
                (e.g. UML 1.4, UML 1.3, UML 2.0, etc.) because we want to be
                independent of them when we process input from different CASE
                tools.
                Enter metamodel facades, or "metafacades" for short!
            </p>
        </section>
        
        <section name="Metamodel facades = metafacades">
            <p>
                This picture shows you how the AndroMDA metamodel facades are 
                related to the metaclass interfaces and their implementation in 
                bytecode:
            </p>
            <img src="images/FacadePrinciples.jpg" />
            <p>
                You can see that the facade hides the metaobject and
                enhances it with its own methods. The next figure shows
                how the templates interact with the metafacades and how
                the metafacades inside a cartridge relate to the basic
                metafacades that ship with the AndroMDA distribution (in
                the subdirectory "metafacades"):
            </p>
            <img src="images/FacadeLayer.jpg" />
            <p>
                Templates within a cartridge call metafacades. Those can
                be contained in the same cartridge or in the base metafacades
                package. The base metafacades define common interfaces for
                metafacades and implement these interfaces in
                separate classes which are specific for a certain version of
                the metamodel (UML in this case, but any metamodel like CWM, etc. will do).
            </p>
        </section>

        <section name="Almost a real world example: EJB metafacades">
            <p>
                Metafacades carry behaviour that supports code generation.
                The following picture shows you a concrete example for this:
                operations of metafacades used for EJB code generation.
            </p>
            <img src="images/EJBFacades.jpg" />
            <p>
                At the top of the diagram, you see a simplified version of
                the base metafacade <code>ClassifierFacade</code>. (By the way:
                Classifier is a metamodel superclass of UMLClass). You see
                that this facade supports a <code>getFullyQualifiedName()</code> method
                which is handy for templates: A template can invoke this method
                using the <code>$class.fullyQualifiedName</code> syntax. 
            </p>
            <p>
                You can also see the method <code>getAttributesAsList()</code>.
                This method returns a string that can be used for generating
                superclass constructor calls or <code>ejbCreate()</code> calls.
                For a class with attributes <code>a</code>
                and <code>b</code>, the method returns <code>"(a, b)"</code>.
            </p>
            <p>
                To be continued...
            </p>
        </section>

    </body>
</document>
