// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\FormImpl.java.vsl) on 07/30/2011 09:32:38-0300
package org.andromda.cartridges.jsf.tests.validation;

import java.io.Serializable;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.faces.application.FacesMessage;
import javax.faces.event.ActionEvent;
import javax.faces.event.FacesEvent;
import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import org.apache.commons.beanutils.PropertyUtils;

/**
 * 
 */
public class ValidationActivityFormImpl
    implements Serializable
{
    /**
     * Default constructor
     */
    public ValidationActivityFormImpl()
    {
        final DateFormat lenientDateTestDateFormatter = new SimpleDateFormat("dd/MMM/yyyy");
        lenientDateTestDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("lenientDateTest", lenientDateTestDateFormatter);
        final DateFormat strictDateTestDateFormatter = new SimpleDateFormat("strict dd/MM/yyyy");
        strictDateTestDateFormatter.setLenient(false);
        this.dateTimeFormatters.put("strictDateTest", strictDateTestDateFormatter);
        final DateFormat hiddenNotValidatedDateFormatter = new SimpleDateFormat("MM/dd/yyyy");
        hiddenNotValidatedDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("hiddenNotValidated", hiddenNotValidatedDateFormatter);
        // - setup the default Date.toString() formatter
        final DateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);
    }

    private transient FacesEvent event;

    /**
     * @param eventIn
     */
    public void setEvent(FacesEvent eventIn)
    {
        this.event = eventIn;
    }

    /**
     * @return ValueChangeEvent
     */
    public ValueChangeEvent getValueChangeEvent()
    {
        return this.event instanceof ValueChangeEvent
            ? (ValueChangeEvent)this.event : null;
    }

    /**
     * @return ActionEvent
     */
    public ActionEvent getActionEvent()
    {
        return this.event instanceof ActionEvent
            ? (ActionEvent)this.event : null;
    }

    // Action validation-activity-preloading formFields

    private String minlengthTest;

    /**
     * 
     * @return minlengthTest 
     */
    public String getMinlengthTest()
    {
        return this.minlengthTest;
    }

    /**
     * Keeps track of whether or not the value of minlengthTest has
     * be populated at least once.
     */
    private boolean minlengthTestSet = false;

    /**
     * Resets the value of the minlengthTestSet to false
     */
    public void resetMinlengthTestSet()
    {
        this.minlengthTestSet = false;
    }

    /**
     * Indicates whether or not the value for minlengthTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMinlengthTestSet()
    {
        return this.minlengthTestSet;
    }

    /**
     * 
     * @param minlengthTestIn 
     */
    public void setMinlengthTest(String minlengthTestIn)
    {
        this.minlengthTest = minlengthTestIn;
        this.minlengthTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] minlengthTestValueList;

    /**
     * Stores the labels
     */
    private Object[] minlengthTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMinlengthTestBackingList()
    {
        Object[] values = this.minlengthTestValueList;
        Object[] labels = this.minlengthTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return minlengthTestValueList
     */
    public Object[] getMinlengthTestValueList()
    {
        return this.minlengthTestValueList;
    }

    /**
     * @param minlengthTestValueListIn
     */
    public void setMinlengthTestValueList(Object[] minlengthTestValueListIn)
    {
        this.minlengthTestValueList = minlengthTestValueListIn;
    }

    /**
     * @return minlengthTestLabelList Object[]
     */
    public Object[] getMinlengthTestLabelList()
    {
        return this.minlengthTestLabelList;
    }

    /**
     * @param minlengthTestLabelListIn
     */
    public void setMinlengthTestLabelList(Object[] minlengthTestLabelListIn)
    {
        this.minlengthTestLabelList = minlengthTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMinlengthTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.minlengthTestValueList = null;
        this.minlengthTestLabelList = null;
        if (items != null)
        {
            this.minlengthTestValueList = new Object[items.size()];
            this.minlengthTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.minlengthTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.minlengthTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.minlengthTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String maxlengthTest;

    /**
     * 
     * @return maxlengthTest 
     */
    public String getMaxlengthTest()
    {
        return this.maxlengthTest;
    }

    /**
     * Keeps track of whether or not the value of maxlengthTest has
     * be populated at least once.
     */
    private boolean maxlengthTestSet = false;

    /**
     * Resets the value of the maxlengthTestSet to false
     */
    public void resetMaxlengthTestSet()
    {
        this.maxlengthTestSet = false;
    }

    /**
     * Indicates whether or not the value for maxlengthTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMaxlengthTestSet()
    {
        return this.maxlengthTestSet;
    }

    /**
     * 
     * @param maxlengthTestIn 
     */
    public void setMaxlengthTest(String maxlengthTestIn)
    {
        this.maxlengthTest = maxlengthTestIn;
        this.maxlengthTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] maxlengthTestValueList;

    /**
     * Stores the labels
     */
    private Object[] maxlengthTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMaxlengthTestBackingList()
    {
        Object[] values = this.maxlengthTestValueList;
        Object[] labels = this.maxlengthTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return maxlengthTestValueList
     */
    public Object[] getMaxlengthTestValueList()
    {
        return this.maxlengthTestValueList;
    }

    /**
     * @param maxlengthTestValueListIn
     */
    public void setMaxlengthTestValueList(Object[] maxlengthTestValueListIn)
    {
        this.maxlengthTestValueList = maxlengthTestValueListIn;
    }

    /**
     * @return maxlengthTestLabelList Object[]
     */
    public Object[] getMaxlengthTestLabelList()
    {
        return this.maxlengthTestLabelList;
    }

    /**
     * @param maxlengthTestLabelListIn
     */
    public void setMaxlengthTestLabelList(Object[] maxlengthTestLabelListIn)
    {
        this.maxlengthTestLabelList = maxlengthTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMaxlengthTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.maxlengthTestValueList = null;
        this.maxlengthTestLabelList = null;
        if (items != null)
        {
            this.maxlengthTestValueList = new Object[items.size()];
            this.maxlengthTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.maxlengthTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.maxlengthTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.maxlengthTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String patternTest;

    /**
     * 
     * @return patternTest 
     */
    public String getPatternTest()
    {
        return this.patternTest;
    }

    /**
     * Keeps track of whether or not the value of patternTest has
     * be populated at least once.
     */
    private boolean patternTestSet = false;

    /**
     * Resets the value of the patternTestSet to false
     */
    public void resetPatternTestSet()
    {
        this.patternTestSet = false;
    }

    /**
     * Indicates whether or not the value for patternTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isPatternTestSet()
    {
        return this.patternTestSet;
    }

    /**
     * 
     * @param patternTestIn 
     */
    public void setPatternTest(String patternTestIn)
    {
        this.patternTest = patternTestIn;
        this.patternTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] patternTestValueList;

    /**
     * Stores the labels
     */
    private Object[] patternTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getPatternTestBackingList()
    {
        Object[] values = this.patternTestValueList;
        Object[] labels = this.patternTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return patternTestValueList
     */
    public Object[] getPatternTestValueList()
    {
        return this.patternTestValueList;
    }

    /**
     * @param patternTestValueListIn
     */
    public void setPatternTestValueList(Object[] patternTestValueListIn)
    {
        this.patternTestValueList = patternTestValueListIn;
    }

    /**
     * @return patternTestLabelList Object[]
     */
    public Object[] getPatternTestLabelList()
    {
        return this.patternTestLabelList;
    }

    /**
     * @param patternTestLabelListIn
     */
    public void setPatternTestLabelList(Object[] patternTestLabelListIn)
    {
        this.patternTestLabelList = patternTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setPatternTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.patternTestValueList = null;
        this.patternTestLabelList = null;
        if (items != null)
        {
            this.patternTestValueList = new Object[items.size()];
            this.patternTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.patternTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.patternTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.patternTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String creditcardTest;

    /**
     * 
     * @return creditcardTest 
     */
    public String getCreditcardTest()
    {
        return this.creditcardTest;
    }

    /**
     * Keeps track of whether or not the value of creditcardTest has
     * be populated at least once.
     */
    private boolean creditcardTestSet = false;

    /**
     * Resets the value of the creditcardTestSet to false
     */
    public void resetCreditcardTestSet()
    {
        this.creditcardTestSet = false;
    }

    /**
     * Indicates whether or not the value for creditcardTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isCreditcardTestSet()
    {
        return this.creditcardTestSet;
    }

    /**
     * 
     * @param creditcardTestIn 
     */
    public void setCreditcardTest(String creditcardTestIn)
    {
        this.creditcardTest = creditcardTestIn;
        this.creditcardTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] creditcardTestValueList;

    /**
     * Stores the labels
     */
    private Object[] creditcardTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCreditcardTestBackingList()
    {
        Object[] values = this.creditcardTestValueList;
        Object[] labels = this.creditcardTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return creditcardTestValueList
     */
    public Object[] getCreditcardTestValueList()
    {
        return this.creditcardTestValueList;
    }

    /**
     * @param creditcardTestValueListIn
     */
    public void setCreditcardTestValueList(Object[] creditcardTestValueListIn)
    {
        this.creditcardTestValueList = creditcardTestValueListIn;
    }

    /**
     * @return creditcardTestLabelList Object[]
     */
    public Object[] getCreditcardTestLabelList()
    {
        return this.creditcardTestLabelList;
    }

    /**
     * @param creditcardTestLabelListIn
     */
    public void setCreditcardTestLabelList(Object[] creditcardTestLabelListIn)
    {
        this.creditcardTestLabelList = creditcardTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCreditcardTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.creditcardTestValueList = null;
        this.creditcardTestLabelList = null;
        if (items != null)
        {
            this.creditcardTestValueList = new Object[items.size()];
            this.creditcardTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.creditcardTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.creditcardTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.creditcardTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String emailTest;

    /**
     * 
     * @return emailTest 
     */
    public String getEmailTest()
    {
        return this.emailTest;
    }

    /**
     * Keeps track of whether or not the value of emailTest has
     * be populated at least once.
     */
    private boolean emailTestSet = false;

    /**
     * Resets the value of the emailTestSet to false
     */
    public void resetEmailTestSet()
    {
        this.emailTestSet = false;
    }

    /**
     * Indicates whether or not the value for emailTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isEmailTestSet()
    {
        return this.emailTestSet;
    }

    /**
     * 
     * @param emailTestIn 
     */
    public void setEmailTest(String emailTestIn)
    {
        this.emailTest = emailTestIn;
        this.emailTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] emailTestValueList;

    /**
     * Stores the labels
     */
    private Object[] emailTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getEmailTestBackingList()
    {
        Object[] values = this.emailTestValueList;
        Object[] labels = this.emailTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return emailTestValueList
     */
    public Object[] getEmailTestValueList()
    {
        return this.emailTestValueList;
    }

    /**
     * @param emailTestValueListIn
     */
    public void setEmailTestValueList(Object[] emailTestValueListIn)
    {
        this.emailTestValueList = emailTestValueListIn;
    }

    /**
     * @return emailTestLabelList Object[]
     */
    public Object[] getEmailTestLabelList()
    {
        return this.emailTestLabelList;
    }

    /**
     * @param emailTestLabelListIn
     */
    public void setEmailTestLabelList(Object[] emailTestLabelListIn)
    {
        this.emailTestLabelList = emailTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setEmailTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.emailTestValueList = null;
        this.emailTestLabelList = null;
        if (items != null)
        {
            this.emailTestValueList = new Object[items.size()];
            this.emailTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.emailTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.emailTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.emailTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private URL urlTest;

    /**
     * 
     * @return urlTest 
     */
    public URL getUrlTest()
    {
        return this.urlTest;
    }

    /**
     * Keeps track of whether or not the value of urlTest has
     * be populated at least once.
     */
    private boolean urlTestSet = false;

    /**
     * Resets the value of the urlTestSet to false
     */
    public void resetUrlTestSet()
    {
        this.urlTestSet = false;
    }

    /**
     * Indicates whether or not the value for urlTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isUrlTestSet()
    {
        return this.urlTestSet;
    }

    /**
     * 
     * @param urlTestIn 
     */
    public void setUrlTest(URL urlTestIn)
    {
        this.urlTest = urlTestIn;
        this.urlTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] urlTestValueList;

    /**
     * Stores the labels
     */
    private Object[] urlTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getUrlTestBackingList()
    {
        Object[] values = this.urlTestValueList;
        Object[] labels = this.urlTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return urlTestValueList
     */
    public Object[] getUrlTestValueList()
    {
        return this.urlTestValueList;
    }

    /**
     * @param urlTestValueListIn
     */
    public void setUrlTestValueList(Object[] urlTestValueListIn)
    {
        this.urlTestValueList = urlTestValueListIn;
    }

    /**
     * @return urlTestLabelList Object[]
     */
    public Object[] getUrlTestLabelList()
    {
        return this.urlTestLabelList;
    }

    /**
     * @param urlTestLabelListIn
     */
    public void setUrlTestLabelList(Object[] urlTestLabelListIn)
    {
        this.urlTestLabelList = urlTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setUrlTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.urlTestValueList = null;
        this.urlTestLabelList = null;
        if (items != null)
        {
            this.urlTestValueList = new Object[items.size()];
            this.urlTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.urlTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.urlTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.urlTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private int intRangeTest;

    /**
     * 
     * @return intRangeTest 
     */
    public int getIntRangeTest()
    {
        return this.intRangeTest;
    }

    /**
     * Keeps track of whether or not the value of intRangeTest has
     * be populated at least once.
     */
    private boolean intRangeTestSet = false;

    /**
     * Resets the value of the intRangeTestSet to false
     */
    public void resetIntRangeTestSet()
    {
        this.intRangeTestSet = false;
    }

    /**
     * Indicates whether or not the value for intRangeTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isIntRangeTestSet()
    {
        return this.intRangeTestSet;
    }

    /**
     * 
     * @param intRangeTestIn 
     */
    public void setIntRangeTest(int intRangeTestIn)
    {
        this.intRangeTest = intRangeTestIn;
        this.intRangeTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] intRangeTestValueList;

    /**
     * Stores the labels
     */
    private Object[] intRangeTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getIntRangeTestBackingList()
    {
        Object[] values = this.intRangeTestValueList;
        Object[] labels = this.intRangeTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return intRangeTestValueList
     */
    public Object[] getIntRangeTestValueList()
    {
        return this.intRangeTestValueList;
    }

    /**
     * @param intRangeTestValueListIn
     */
    public void setIntRangeTestValueList(Object[] intRangeTestValueListIn)
    {
        this.intRangeTestValueList = intRangeTestValueListIn;
    }

    /**
     * @return intRangeTestLabelList Object[]
     */
    public Object[] getIntRangeTestLabelList()
    {
        return this.intRangeTestLabelList;
    }

    /**
     * @param intRangeTestLabelListIn
     */
    public void setIntRangeTestLabelList(Object[] intRangeTestLabelListIn)
    {
        this.intRangeTestLabelList = intRangeTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setIntRangeTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.intRangeTestValueList = null;
        this.intRangeTestLabelList = null;
        if (items != null)
        {
            this.intRangeTestValueList = new Object[items.size()];
            this.intRangeTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.intRangeTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.intRangeTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.intRangeTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private float floatRangeTest;

    /**
     * 
     * @return floatRangeTest 
     */
    public float getFloatRangeTest()
    {
        return this.floatRangeTest;
    }

    /**
     * Keeps track of whether or not the value of floatRangeTest has
     * be populated at least once.
     */
    private boolean floatRangeTestSet = false;

    /**
     * Resets the value of the floatRangeTestSet to false
     */
    public void resetFloatRangeTestSet()
    {
        this.floatRangeTestSet = false;
    }

    /**
     * Indicates whether or not the value for floatRangeTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFloatRangeTestSet()
    {
        return this.floatRangeTestSet;
    }

    /**
     * 
     * @param floatRangeTestIn 
     */
    public void setFloatRangeTest(float floatRangeTestIn)
    {
        this.floatRangeTest = floatRangeTestIn;
        this.floatRangeTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] floatRangeTestValueList;

    /**
     * Stores the labels
     */
    private Object[] floatRangeTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFloatRangeTestBackingList()
    {
        Object[] values = this.floatRangeTestValueList;
        Object[] labels = this.floatRangeTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return floatRangeTestValueList
     */
    public Object[] getFloatRangeTestValueList()
    {
        return this.floatRangeTestValueList;
    }

    /**
     * @param floatRangeTestValueListIn
     */
    public void setFloatRangeTestValueList(Object[] floatRangeTestValueListIn)
    {
        this.floatRangeTestValueList = floatRangeTestValueListIn;
    }

    /**
     * @return floatRangeTestLabelList Object[]
     */
    public Object[] getFloatRangeTestLabelList()
    {
        return this.floatRangeTestLabelList;
    }

    /**
     * @param floatRangeTestLabelListIn
     */
    public void setFloatRangeTestLabelList(Object[] floatRangeTestLabelListIn)
    {
        this.floatRangeTestLabelList = floatRangeTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFloatRangeTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.floatRangeTestValueList = null;
        this.floatRangeTestLabelList = null;
        if (items != null)
        {
            this.floatRangeTestValueList = new Object[items.size()];
            this.floatRangeTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.floatRangeTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.floatRangeTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.floatRangeTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private double doubleRangeTest;

    /**
     * 
     * @return doubleRangeTest 
     */
    public double getDoubleRangeTest()
    {
        return this.doubleRangeTest;
    }

    /**
     * Keeps track of whether or not the value of doubleRangeTest has
     * be populated at least once.
     */
    private boolean doubleRangeTestSet = false;

    /**
     * Resets the value of the doubleRangeTestSet to false
     */
    public void resetDoubleRangeTestSet()
    {
        this.doubleRangeTestSet = false;
    }

    /**
     * Indicates whether or not the value for doubleRangeTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isDoubleRangeTestSet()
    {
        return this.doubleRangeTestSet;
    }

    /**
     * 
     * @param doubleRangeTestIn 
     */
    public void setDoubleRangeTest(double doubleRangeTestIn)
    {
        this.doubleRangeTest = doubleRangeTestIn;
        this.doubleRangeTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] doubleRangeTestValueList;

    /**
     * Stores the labels
     */
    private Object[] doubleRangeTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getDoubleRangeTestBackingList()
    {
        Object[] values = this.doubleRangeTestValueList;
        Object[] labels = this.doubleRangeTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return doubleRangeTestValueList
     */
    public Object[] getDoubleRangeTestValueList()
    {
        return this.doubleRangeTestValueList;
    }

    /**
     * @param doubleRangeTestValueListIn
     */
    public void setDoubleRangeTestValueList(Object[] doubleRangeTestValueListIn)
    {
        this.doubleRangeTestValueList = doubleRangeTestValueListIn;
    }

    /**
     * @return doubleRangeTestLabelList Object[]
     */
    public Object[] getDoubleRangeTestLabelList()
    {
        return this.doubleRangeTestLabelList;
    }

    /**
     * @param doubleRangeTestLabelListIn
     */
    public void setDoubleRangeTestLabelList(Object[] doubleRangeTestLabelListIn)
    {
        this.doubleRangeTestLabelList = doubleRangeTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setDoubleRangeTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.doubleRangeTestValueList = null;
        this.doubleRangeTestLabelList = null;
        if (items != null)
        {
            this.doubleRangeTestValueList = new Object[items.size()];
            this.doubleRangeTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.doubleRangeTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.doubleRangeTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.doubleRangeTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Integer intWrapperRangeTest;

    /**
     * 
     * @return intWrapperRangeTest 
     */
    public Integer getIntWrapperRangeTest()
    {
        return this.intWrapperRangeTest;
    }

    /**
     * Keeps track of whether or not the value of intWrapperRangeTest has
     * be populated at least once.
     */
    private boolean intWrapperRangeTestSet = false;

    /**
     * Resets the value of the intWrapperRangeTestSet to false
     */
    public void resetIntWrapperRangeTestSet()
    {
        this.intWrapperRangeTestSet = false;
    }

    /**
     * Indicates whether or not the value for intWrapperRangeTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isIntWrapperRangeTestSet()
    {
        return this.intWrapperRangeTestSet;
    }

    /**
     * 
     * @param intWrapperRangeTestIn 
     */
    public void setIntWrapperRangeTest(Integer intWrapperRangeTestIn)
    {
        this.intWrapperRangeTest = intWrapperRangeTestIn;
        this.intWrapperRangeTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] intWrapperRangeTestValueList;

    /**
     * Stores the labels
     */
    private Object[] intWrapperRangeTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getIntWrapperRangeTestBackingList()
    {
        Object[] values = this.intWrapperRangeTestValueList;
        Object[] labels = this.intWrapperRangeTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return intWrapperRangeTestValueList
     */
    public Object[] getIntWrapperRangeTestValueList()
    {
        return this.intWrapperRangeTestValueList;
    }

    /**
     * @param intWrapperRangeTestValueListIn
     */
    public void setIntWrapperRangeTestValueList(Object[] intWrapperRangeTestValueListIn)
    {
        this.intWrapperRangeTestValueList = intWrapperRangeTestValueListIn;
    }

    /**
     * @return intWrapperRangeTestLabelList Object[]
     */
    public Object[] getIntWrapperRangeTestLabelList()
    {
        return this.intWrapperRangeTestLabelList;
    }

    /**
     * @param intWrapperRangeTestLabelListIn
     */
    public void setIntWrapperRangeTestLabelList(Object[] intWrapperRangeTestLabelListIn)
    {
        this.intWrapperRangeTestLabelList = intWrapperRangeTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setIntWrapperRangeTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.intWrapperRangeTestValueList = null;
        this.intWrapperRangeTestLabelList = null;
        if (items != null)
        {
            this.intWrapperRangeTestValueList = new Object[items.size()];
            this.intWrapperRangeTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.intWrapperRangeTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.intWrapperRangeTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.intWrapperRangeTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Float floatWrapperRangeTest;

    /**
     * 
     * @return floatWrapperRangeTest 
     */
    public Float getFloatWrapperRangeTest()
    {
        return this.floatWrapperRangeTest;
    }

    /**
     * Keeps track of whether or not the value of floatWrapperRangeTest has
     * be populated at least once.
     */
    private boolean floatWrapperRangeTestSet = false;

    /**
     * Resets the value of the floatWrapperRangeTestSet to false
     */
    public void resetFloatWrapperRangeTestSet()
    {
        this.floatWrapperRangeTestSet = false;
    }

    /**
     * Indicates whether or not the value for floatWrapperRangeTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFloatWrapperRangeTestSet()
    {
        return this.floatWrapperRangeTestSet;
    }

    /**
     * 
     * @param floatWrapperRangeTestIn 
     */
    public void setFloatWrapperRangeTest(Float floatWrapperRangeTestIn)
    {
        this.floatWrapperRangeTest = floatWrapperRangeTestIn;
        this.floatWrapperRangeTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] floatWrapperRangeTestValueList;

    /**
     * Stores the labels
     */
    private Object[] floatWrapperRangeTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFloatWrapperRangeTestBackingList()
    {
        Object[] values = this.floatWrapperRangeTestValueList;
        Object[] labels = this.floatWrapperRangeTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return floatWrapperRangeTestValueList
     */
    public Object[] getFloatWrapperRangeTestValueList()
    {
        return this.floatWrapperRangeTestValueList;
    }

    /**
     * @param floatWrapperRangeTestValueListIn
     */
    public void setFloatWrapperRangeTestValueList(Object[] floatWrapperRangeTestValueListIn)
    {
        this.floatWrapperRangeTestValueList = floatWrapperRangeTestValueListIn;
    }

    /**
     * @return floatWrapperRangeTestLabelList Object[]
     */
    public Object[] getFloatWrapperRangeTestLabelList()
    {
        return this.floatWrapperRangeTestLabelList;
    }

    /**
     * @param floatWrapperRangeTestLabelListIn
     */
    public void setFloatWrapperRangeTestLabelList(Object[] floatWrapperRangeTestLabelListIn)
    {
        this.floatWrapperRangeTestLabelList = floatWrapperRangeTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFloatWrapperRangeTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.floatWrapperRangeTestValueList = null;
        this.floatWrapperRangeTestLabelList = null;
        if (items != null)
        {
            this.floatWrapperRangeTestValueList = new Object[items.size()];
            this.floatWrapperRangeTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.floatWrapperRangeTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.floatWrapperRangeTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.floatWrapperRangeTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Double doubleWrapperRangeTest;

    /**
     * 
     * @return doubleWrapperRangeTest 
     */
    public Double getDoubleWrapperRangeTest()
    {
        return this.doubleWrapperRangeTest;
    }

    /**
     * Keeps track of whether or not the value of doubleWrapperRangeTest has
     * be populated at least once.
     */
    private boolean doubleWrapperRangeTestSet = false;

    /**
     * Resets the value of the doubleWrapperRangeTestSet to false
     */
    public void resetDoubleWrapperRangeTestSet()
    {
        this.doubleWrapperRangeTestSet = false;
    }

    /**
     * Indicates whether or not the value for doubleWrapperRangeTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isDoubleWrapperRangeTestSet()
    {
        return this.doubleWrapperRangeTestSet;
    }

    /**
     * 
     * @param doubleWrapperRangeTestIn 
     */
    public void setDoubleWrapperRangeTest(Double doubleWrapperRangeTestIn)
    {
        this.doubleWrapperRangeTest = doubleWrapperRangeTestIn;
        this.doubleWrapperRangeTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] doubleWrapperRangeTestValueList;

    /**
     * Stores the labels
     */
    private Object[] doubleWrapperRangeTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getDoubleWrapperRangeTestBackingList()
    {
        Object[] values = this.doubleWrapperRangeTestValueList;
        Object[] labels = this.doubleWrapperRangeTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return doubleWrapperRangeTestValueList
     */
    public Object[] getDoubleWrapperRangeTestValueList()
    {
        return this.doubleWrapperRangeTestValueList;
    }

    /**
     * @param doubleWrapperRangeTestValueListIn
     */
    public void setDoubleWrapperRangeTestValueList(Object[] doubleWrapperRangeTestValueListIn)
    {
        this.doubleWrapperRangeTestValueList = doubleWrapperRangeTestValueListIn;
    }

    /**
     * @return doubleWrapperRangeTestLabelList Object[]
     */
    public Object[] getDoubleWrapperRangeTestLabelList()
    {
        return this.doubleWrapperRangeTestLabelList;
    }

    /**
     * @param doubleWrapperRangeTestLabelListIn
     */
    public void setDoubleWrapperRangeTestLabelList(Object[] doubleWrapperRangeTestLabelListIn)
    {
        this.doubleWrapperRangeTestLabelList = doubleWrapperRangeTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setDoubleWrapperRangeTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.doubleWrapperRangeTestValueList = null;
        this.doubleWrapperRangeTestLabelList = null;
        if (items != null)
        {
            this.doubleWrapperRangeTestValueList = new Object[items.size()];
            this.doubleWrapperRangeTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.doubleWrapperRangeTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.doubleWrapperRangeTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.doubleWrapperRangeTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date lenientDateTest;

    /**
     * 
     * @return lenientDateTest 
     */
    public Date getLenientDateTest()
    {
        return this.lenientDateTest;
    }

    /**
     * Keeps track of whether or not the value of lenientDateTest has
     * be populated at least once.
     */
    private boolean lenientDateTestSet = false;

    /**
     * Resets the value of the lenientDateTestSet to false
     */
    public void resetLenientDateTestSet()
    {
        this.lenientDateTestSet = false;
    }

    /**
     * Indicates whether or not the value for lenientDateTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isLenientDateTestSet()
    {
        return this.lenientDateTestSet;
    }

    /**
     * 
     * @param lenientDateTestIn 
     */
    public void setLenientDateTest(Date lenientDateTestIn)
    {
        this.lenientDateTest = lenientDateTestIn;
        this.lenientDateTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] lenientDateTestValueList;

    /**
     * Stores the labels
     */
    private Object[] lenientDateTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getLenientDateTestBackingList()
    {
        Object[] values = this.lenientDateTestValueList;
        Object[] labels = this.lenientDateTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return lenientDateTestValueList
     */
    public Object[] getLenientDateTestValueList()
    {
        return this.lenientDateTestValueList;
    }

    /**
     * @param lenientDateTestValueListIn
     */
    public void setLenientDateTestValueList(Object[] lenientDateTestValueListIn)
    {
        this.lenientDateTestValueList = lenientDateTestValueListIn;
    }

    /**
     * @return lenientDateTestLabelList Object[]
     */
    public Object[] getLenientDateTestLabelList()
    {
        return this.lenientDateTestLabelList;
    }

    /**
     * @param lenientDateTestLabelListIn
     */
    public void setLenientDateTestLabelList(Object[] lenientDateTestLabelListIn)
    {
        this.lenientDateTestLabelList = lenientDateTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setLenientDateTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.lenientDateTestValueList = null;
        this.lenientDateTestLabelList = null;
        if (items != null)
        {
            this.lenientDateTestValueList = new Object[items.size()];
            this.lenientDateTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.lenientDateTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.lenientDateTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.lenientDateTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date strictDateTest;

    /**
     * 
     * @return strictDateTest 
     */
    public Date getStrictDateTest()
    {
        return this.strictDateTest;
    }

    /**
     * Keeps track of whether or not the value of strictDateTest has
     * be populated at least once.
     */
    private boolean strictDateTestSet = false;

    /**
     * Resets the value of the strictDateTestSet to false
     */
    public void resetStrictDateTestSet()
    {
        this.strictDateTestSet = false;
    }

    /**
     * Indicates whether or not the value for strictDateTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isStrictDateTestSet()
    {
        return this.strictDateTestSet;
    }

    /**
     * 
     * @param strictDateTestIn 
     */
    public void setStrictDateTest(Date strictDateTestIn)
    {
        this.strictDateTest = strictDateTestIn;
        this.strictDateTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] strictDateTestValueList;

    /**
     * Stores the labels
     */
    private Object[] strictDateTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getStrictDateTestBackingList()
    {
        Object[] values = this.strictDateTestValueList;
        Object[] labels = this.strictDateTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return strictDateTestValueList
     */
    public Object[] getStrictDateTestValueList()
    {
        return this.strictDateTestValueList;
    }

    /**
     * @param strictDateTestValueListIn
     */
    public void setStrictDateTestValueList(Object[] strictDateTestValueListIn)
    {
        this.strictDateTestValueList = strictDateTestValueListIn;
    }

    /**
     * @return strictDateTestLabelList Object[]
     */
    public Object[] getStrictDateTestLabelList()
    {
        return this.strictDateTestLabelList;
    }

    /**
     * @param strictDateTestLabelListIn
     */
    public void setStrictDateTestLabelList(Object[] strictDateTestLabelListIn)
    {
        this.strictDateTestLabelList = strictDateTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setStrictDateTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.strictDateTestValueList = null;
        this.strictDateTestLabelList = null;
        if (items != null)
        {
            this.strictDateTestValueList = new Object[items.size()];
            this.strictDateTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.strictDateTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.strictDateTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.strictDateTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String requiredTest;

    /**
     * 
     * @return requiredTest 
     */
    public String getRequiredTest()
    {
        return this.requiredTest;
    }

    /**
     * Keeps track of whether or not the value of requiredTest has
     * be populated at least once.
     */
    private boolean requiredTestSet = false;

    /**
     * Resets the value of the requiredTestSet to false
     */
    public void resetRequiredTestSet()
    {
        this.requiredTestSet = false;
    }

    /**
     * Indicates whether or not the value for requiredTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isRequiredTestSet()
    {
        return this.requiredTestSet;
    }

    /**
     * 
     * @param requiredTestIn 
     */
    public void setRequiredTest(String requiredTestIn)
    {
        this.requiredTest = requiredTestIn;
        this.requiredTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] requiredTestValueList;

    /**
     * Stores the labels
     */
    private Object[] requiredTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getRequiredTestBackingList()
    {
        Object[] values = this.requiredTestValueList;
        Object[] labels = this.requiredTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return requiredTestValueList
     */
    public Object[] getRequiredTestValueList()
    {
        return this.requiredTestValueList;
    }

    /**
     * @param requiredTestValueListIn
     */
    public void setRequiredTestValueList(Object[] requiredTestValueListIn)
    {
        this.requiredTestValueList = requiredTestValueListIn;
    }

    /**
     * @return requiredTestLabelList Object[]
     */
    public Object[] getRequiredTestLabelList()
    {
        return this.requiredTestLabelList;
    }

    /**
     * @param requiredTestLabelListIn
     */
    public void setRequiredTestLabelList(Object[] requiredTestLabelListIn)
    {
        this.requiredTestLabelList = requiredTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setRequiredTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.requiredTestValueList = null;
        this.requiredTestLabelList = null;
        if (items != null)
        {
            this.requiredTestValueList = new Object[items.size()];
            this.requiredTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.requiredTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.requiredTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.requiredTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date hiddenNotValidated;

    /**
     * 
     * @return hiddenNotValidated 
     */
    public Date getHiddenNotValidated()
    {
        return this.hiddenNotValidated;
    }

    /**
     * Keeps track of whether or not the value of hiddenNotValidated has
     * be populated at least once.
     */
    private boolean hiddenNotValidatedSet = false;

    /**
     * Resets the value of the hiddenNotValidatedSet to false
     */
    public void resetHiddenNotValidatedSet()
    {
        this.hiddenNotValidatedSet = false;
    }

    /**
     * Indicates whether or not the value for hiddenNotValidated has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isHiddenNotValidatedSet()
    {
        return this.hiddenNotValidatedSet;
    }

    /**
     * 
     * @param hiddenNotValidatedIn 
     */
    public void setHiddenNotValidated(Date hiddenNotValidatedIn)
    {
        this.hiddenNotValidated = hiddenNotValidatedIn;
        this.hiddenNotValidatedSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] hiddenNotValidatedValueList;

    /**
     * Stores the labels
     */
    private Object[] hiddenNotValidatedLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getHiddenNotValidatedBackingList()
    {
        Object[] values = this.hiddenNotValidatedValueList;
        Object[] labels = this.hiddenNotValidatedLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return hiddenNotValidatedValueList
     */
    public Object[] getHiddenNotValidatedValueList()
    {
        return this.hiddenNotValidatedValueList;
    }

    /**
     * @param hiddenNotValidatedValueListIn
     */
    public void setHiddenNotValidatedValueList(Object[] hiddenNotValidatedValueListIn)
    {
        this.hiddenNotValidatedValueList = hiddenNotValidatedValueListIn;
    }

    /**
     * @return hiddenNotValidatedLabelList Object[]
     */
    public Object[] getHiddenNotValidatedLabelList()
    {
        return this.hiddenNotValidatedLabelList;
    }

    /**
     * @param hiddenNotValidatedLabelListIn
     */
    public void setHiddenNotValidatedLabelList(Object[] hiddenNotValidatedLabelListIn)
    {
        this.hiddenNotValidatedLabelList = hiddenNotValidatedLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setHiddenNotValidatedBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.hiddenNotValidatedValueList = null;
        this.hiddenNotValidatedLabelList = null;
        if (items != null)
        {
            this.hiddenNotValidatedValueList = new Object[items.size()];
            this.hiddenNotValidatedLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.hiddenNotValidatedValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.hiddenNotValidatedLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.hiddenNotValidatedLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String minLengthOnPasswordTest;

    /**
     * 
     * @return minLengthOnPasswordTest 
     */
    public String getMinLengthOnPasswordTest()
    {
        return this.minLengthOnPasswordTest;
    }

    /**
     * Keeps track of whether or not the value of minLengthOnPasswordTest has
     * be populated at least once.
     */
    private boolean minLengthOnPasswordTestSet = false;

    /**
     * Resets the value of the minLengthOnPasswordTestSet to false
     */
    public void resetMinLengthOnPasswordTestSet()
    {
        this.minLengthOnPasswordTestSet = false;
    }

    /**
     * Indicates whether or not the value for minLengthOnPasswordTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMinLengthOnPasswordTestSet()
    {
        return this.minLengthOnPasswordTestSet;
    }

    /**
     * 
     * @param minLengthOnPasswordTestIn 
     */
    public void setMinLengthOnPasswordTest(String minLengthOnPasswordTestIn)
    {
        this.minLengthOnPasswordTest = minLengthOnPasswordTestIn;
        this.minLengthOnPasswordTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] minLengthOnPasswordTestValueList;

    /**
     * Stores the labels
     */
    private Object[] minLengthOnPasswordTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMinLengthOnPasswordTestBackingList()
    {
        Object[] values = this.minLengthOnPasswordTestValueList;
        Object[] labels = this.minLengthOnPasswordTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return minLengthOnPasswordTestValueList
     */
    public Object[] getMinLengthOnPasswordTestValueList()
    {
        return this.minLengthOnPasswordTestValueList;
    }

    /**
     * @param minLengthOnPasswordTestValueListIn
     */
    public void setMinLengthOnPasswordTestValueList(Object[] minLengthOnPasswordTestValueListIn)
    {
        this.minLengthOnPasswordTestValueList = minLengthOnPasswordTestValueListIn;
    }

    /**
     * @return minLengthOnPasswordTestLabelList Object[]
     */
    public Object[] getMinLengthOnPasswordTestLabelList()
    {
        return this.minLengthOnPasswordTestLabelList;
    }

    /**
     * @param minLengthOnPasswordTestLabelListIn
     */
    public void setMinLengthOnPasswordTestLabelList(Object[] minLengthOnPasswordTestLabelListIn)
    {
        this.minLengthOnPasswordTestLabelList = minLengthOnPasswordTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMinLengthOnPasswordTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.minLengthOnPasswordTestValueList = null;
        this.minLengthOnPasswordTestLabelList = null;
        if (items != null)
        {
            this.minLengthOnPasswordTestValueList = new Object[items.size()];
            this.minLengthOnPasswordTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.minLengthOnPasswordTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.minLengthOnPasswordTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.minLengthOnPasswordTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    /**
     * Resets all the "isSet" flags.
     */
     public void resetIsSetFlags()
     {
         this.resetMinlengthTestSet();
         this.resetMaxlengthTestSet();
         this.resetPatternTestSet();
         this.resetCreditcardTestSet();
         this.resetEmailTestSet();
         this.resetUrlTestSet();
         this.resetIntRangeTestSet();
         this.resetFloatRangeTestSet();
         this.resetDoubleRangeTestSet();
         this.resetIntWrapperRangeTestSet();
         this.resetFloatWrapperRangeTestSet();
         this.resetDoubleWrapperRangeTestSet();
         this.resetLenientDateTestSet();
         this.resetStrictDateTestSet();
         this.resetRequiredTestSet();
         this.resetHiddenNotValidatedSet();
         this.resetMinLengthOnPasswordTestSet();
     }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String, DateFormat> dateTimeFormatters =
        new HashMap<String, DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String, DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private transient Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();


    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (this.jsfMessages != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        if (this.jsfMessages == null)
        {
            this.jsfMessages = new LinkedHashMap<String, FacesMessage>();
        }
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage: messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 5431702136769410306L;
}