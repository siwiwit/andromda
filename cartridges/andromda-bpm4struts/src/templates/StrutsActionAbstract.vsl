##
## Some global invariants
##
#set ($activityGraph = $class.useCase.stateMachine)
#set ($localForwardTransitions = $activityGraph.forwardTransitions)
#set ($choiceTransitions = $activityGraph.choiceTransitions)
#set ($actionStates = $activityGraph.actionStates)
#set ($choices = $activityGraph.choices)
#set ($objectFlowStates = $activityGraph.objectFlowStates)
##
## Package declaration and imports
##
package $class.packageName;

import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.actions.DispatchAction;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.lang.reflect.Method;

public abstract class $class.controllerAbstractClassName extends DispatchAction
{
#foreach ($choiceTransition in $choiceTransitions)
    protected final int $choiceTransition.guardName = $choiceTransition.guardValue.intValue();
#end

    public final ActionForward unspecified(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
#processTransition ( $activityGraph.initialState "        " )
    }

#foreach ($actionState in $actionStates)
    public final ActionForward $actionState.dispatchMethodName(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
        final String trigger = request.getParameter("trigger").toUpperCase();

#if ($actionState.triggerTransitionCount == 1)
#processTransition( $actionState.firstTriggerTransition )
#else
#foreach ($triggerTransition in $triggerTransitions)
        if ($triggerTransition.triggerName.equals(trigger))
#processTransition ( $triggerTransition "          " )
#end
        return null; // if this happens the page specified an illegal trigger: application bug!
#end
    }

#foreach ($choice in $choices)
    private ActionForward $choice.abstractMethodName(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
        final int choiceValue = $choice.implementationMethodName(mapping, ($class.formBean.fullyQualifiedName)form, request, response);

        switch(choiceValue)
        {
#foreach ($choiceTransition in $choice.choiceTransitions)
            case $choiceTransition.guardName :
#processTransition ( $choiceTransition "                " )
#end
            default :
                return null;
        }
    }

    protected abstract int $choice.implementationMethodName(ActionMapping mapping, $class.formBean.fullyQualifiedName form, HttpServletRequest request, HttpServletResponse response);

#end
#foreach ($objectFlowState in $objectFlowStates)
    private void $objectFlowState.implementationMethodName(ActionMapping mapping, $class.formBean.fullyQualifiedName form, HttpServletRequest request, HttpServletResponse response)
    {
        $objectFlowState.implementationMethodName(mapping, ($class.formBean.fullyQualifiedName)form, request, response);
#processTransition ( $objectFlowState.outgoingTransition "                " )
    }

    protected abstract void $objectFlowState.implementationMethodName(ActionMapping mapping, $class.formBean.fullyQualifiedName form, HttpServletRequest request, HttpServletResponse response);

#end

    /**
     * In some cases it may happen that a single client request is passed onto several controllers, Struts with Tiles
     * is an example: when requesting a page constructed with tiles each tile will receive the same client request.
     * <p>
     * In general this works fine, but with DispatchActions there is a side effect: all controllers will be requested
     * to dispatch to a specific method, and most of the time this method will only exist in one controller.
     * <p>
     * This method takes care of these cases by handling unfound dispatch methods by calling the
     * <code>unspecified()</code> method instead.
     */
    protected final Method getMethod(String s) throws NoSuchMethodException
    {
        Method method = null;

        try
        {
            method = super.getMethod(s);
        }
        catch (NoSuchMethodException e)
        {
            method = super.getMethod("unspecified");
        }

        return method;
    }
}
