##
## Some global invariants
##
#set ($stateMachine = $class.useCase.stateMachine)
#set ($choiceTransitions = $stateMachine.outgoingDecisionPointTransitions)
#set ($actionStates = $stateMachine.actionStates)
#set ($choices = $stateMachine.decisionPoints)
#set ($objectFlowStates = $stateMachine.objectFlowStates)
#set ($formBean = $class.formBean)
##
## Specific to this class
##
#set ($className = "$str.toJavaClassName($class.name)Abstract")
#set ($formBeanType = $class.formBean.name)
#if (!$formBeanType)
#set ($formBeanType = "ActionForm")
#end
##
## This small macro will handle the processing of the argument transition.
## Depending on this transition's target it will rendered different code:
##
## A guarded decision point
##   there is a method for each of these nodes, it will be called here
##
## ActionState & FinalState
##    it will render the action forward from the mapping for this target
##
## ObjectFlowState
##    there is a method for each object flow state, it will be called here
##
## Please note that any merge points are simply skipped, they do not add
## any specific logic.
##
#macro ( processTransition $transition $indent )
#set ($target = $transition.finalTarget)
#if ($target.guard)
${indent}return $str.toJavaMethodName($target.name)(mapping, form, request, response);
#elseif ($transform.isActionState($target) || $transform.isFinalState($target))
${indent}return mapping.findForward("$str.separate($target.name,".").toLowerCase()");
#elseif ($transform.isObjectFlowState($target) || $transform.isDecisionPoint($target))
${indent}return ${str.toJavaMethodName($target.name)}Abstract(mapping, form, request, response);
#else
// illegal modelelement : $target.name ($target)
#end
#end
##
## Package declaration and imports
##
package $class.packageName;

#if (($formBeanType != "ActionForm") && ($class.packageName != $class.formBean.packageName))
import $class.formBean.fullyQualifiedName;

#end
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.actions.DispatchAction;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.lang.reflect.Method;

/**
$class.getDocumentation(" ")
 */
public abstract class $className extends DispatchAction
{
#foreach ($choiceTransition in $choiceTransitions)
    protected final int $choiceTransition.guard.name.toUpperCase() = $velocityCount;
#end

    public final ActionForward unspecified(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
#processTransition ( $stateMachine.initialState.outgoing.iterator().next() "        " )
    }

#foreach ($actionState in $actionStates)
#set ($dispatchMethodName = "$str.toJavaMethodName($actionState.name)")
    /**
$actionState.getDocumentation("     ")
     */
    public final ActionForward ${dispatchMethodName}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
#if ($actionState.triggerTransitions.size() == 1)
#processTransition( $actionState.triggerTransitions.iterator().next() "        " )
#else
        String trigger = request.getParameter("trigger");
        if (trigger != null)
            trigger = trigger.toUpperCase();

#foreach ($triggerTransition in $actionState.triggerTransitions)
        if ("${triggerTransition.triggerName}".equals(trigger))
#processTransition ( $triggerTransition "            " )
#end
        return null; // if this happens the page specified an illegal trigger: application bug!
#end
    }

#end
#foreach ($choice in $choices)
#set ($choiceMethodNameParent = "$str.toJavaMethodName($choice.name)Abstract")
#set ($choiceMethodNameChild = "$str.toJavaMethodName($choice.name)")
    private ActionForward ${choiceMethodNameParent}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
        final int choiceValue = ${choiceMethodNameChild}(mapping, ($formBeanType)form, request, response);

        switch(choiceValue)
        {
#foreach ($choiceTransition in $choiceTransitions)
            case $choiceTransition.guard.name.toUpperCase() :
#processTransition ( $choiceTransition "                " )
#end
            default :
                return null;
        }
    }

    /**
$choice.getDocumentation("     ")
     */
    protected abstract int ${choiceMethodNameChild}(ActionMapping mapping, $formBeanType form, HttpServletRequest request, HttpServletResponse response);

#end
#foreach ($objectFlowState in $objectFlowStates)
#set ($stateMethodNameParent = "$str.toJavaMethodName($objectFlowState.name)Abstract")
#set ($stateMethodNameChild = "$str.toJavaMethodName($objectFlowState.name)")
    private ActionForward ${stateMethodNameParent}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
    {
        ${stateMethodNameChild}(mapping, ($formBeanType)form, request, response);
#processTransition ( $objectFlowState.outgoingTransition "        " )
    }

    /**
$objectFlowState.getDocumentation("     ")
     */
    protected abstract void ${stateMethodNameChild}(ActionMapping mapping, $formBeanType form, HttpServletRequest request, HttpServletResponse response);

#end

    /**
     * In some cases it may happen that a single client request is passed onto several controllers, Struts with Tiles
     * is an example: when requesting a page constructed with tiles each tile will receive the same client request.
     * <p>
     * In general this works fine, but with DispatchActions there is a side effect: all controllers will be requested
     * to dispatch to a specific method, and most of the time this method will only exist in one controller.
     * <p>
     * This method takes care of these cases by handling unfound dispatch methods by calling the
     * <code>unspecified()</code> method instead.
     */
    protected final Method getMethod(String s) throws NoSuchMethodException
    {
        Method method = null;

        try
        {
            method = super.getMethod(s);
        }
        catch (NoSuchMethodException e)
        {
            method = super.getMethod("unspecified");
        }

        return method;
    }
}
