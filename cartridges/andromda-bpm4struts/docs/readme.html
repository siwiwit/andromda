<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with jLaTeX2HTML 2002 (1.62) JA patch-1.4
patched version by:  Kenshi Muto, Debian Project.
LaTeX2HTML 2002 (1.62),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>AndroMDA
Business Process Modeling
for Struts</TITLE>
<META NAME="description" CONTENT="AndroMDA
Business Process Modeling
for Struts">
<META NAME="keywords" CONTENT="readme">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="jLaTeX2HTML v2002 JA patch-1.4">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="readme.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/share/latex2html/icons/nx_grp_g.png">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">
<BR>
<BR>
<BR>
<!--End of Navigation Panel-->

<P>

<P>

<P>
<H1 ALIGN="CENTER">AndroMDA
<BR>
Business Process Modeling
<BR>
for Struts</H1>
<P ALIGN="CENTER"><STRONG>Wouter Zoons, draftdog@users.sourceforge.net</STRONG></P>

<H3>Abstract:</H3>
<DIV>
This document describes how to use the Bpm4Struts Cartridge with AndroMDA<A NAME="tex2html1"
  HREF="#foot25"><SUP>1</SUP></A>. It describes how the application should be modeled, which stereotypes
to use, the advantages and possible issues. It is assumed the reader
knows at least the MDA<A NAME="tex2html2"
  HREF="#foot26"><SUP>2</SUP></A> basics and has a good understanding of Struts<A NAME="tex2html3"
  HREF="#foot27"><SUP>3</SUP></A>.

<P>
</DIV>
<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html35"
  HREF="readme.html">1 Foreword</A>
<LI><A NAME="tex2html36"
  HREF="readme.html#SECTION00030000000000000000">2 How to install</A>
<LI><A NAME="tex2html37"
  HREF="readme.html#SECTION00040000000000000000">3 How to use</A>
<LI><A NAME="tex2html38"
  HREF="readme.html#SECTION00050000000000000000">4 Features</A>
<UL>
<LI><A NAME="tex2html39"
  HREF="readme.html#SECTION00051000000000000000">4.1 Struts (PSM)</A>
<LI><A NAME="tex2html40"
  HREF="readme.html#SECTION00052000000000000000">4.2 UML (PIM)</A>
</UL>
<BR>
<LI><A NAME="tex2html41"
  HREF="readme.html#SECTION00060000000000000000">5 Modeling</A>
<UL>
<LI><A NAME="tex2html42"
  HREF="readme.html#SECTION00061000000000000000">5.1 From UML to Struts: An example use-case</A>
<LI><A NAME="tex2html43"
  HREF="readme.html#SECTION00062000000000000000">5.2 Starting from scratch: step by step</A>
</UL>
<BR>
<LI><A NAME="tex2html44"
  HREF="readme.html#SECTION00070000000000000000">6 UML model constraints</A>
<LI><A NAME="tex2html45"
  HREF="readme.html#SECTION00080000000000000000">7 Naming conventions</A>
<LI><A NAME="tex2html46"
  HREF="readme.html#SECTION00090000000000000000">8 Cartridge feature matrix</A>
<LI><A NAME="tex2html47"
  HREF="readme.html#SECTION000100000000000000000">About this document ...</A>
</UL>
<!--End of Table of Contents-->

<P>

<H1><A NAME="SECTION00020000000000000000">
1 Foreword</A>
</H1>

<P>
I have had a very hard time trying to explain the details described
in this document as the matter is more complicated than it seems at
first sight. Re-reading everything I realized people might have trouble
understanding certain sections. I recommend taking a look at the example
and trying one out for yourself. If something is not clear or you
think there are things that can be improved please send an email to
the andromda-devel@lists.sourceforge.net mailing list.

<P>

<H1><A NAME="SECTION00030000000000000000">
2 How to install</A>
</H1>

<P>
In order to install the cartridge you will need to copy andromda-bpm4struts.jar
to the cartridge directory in your AndroMDA installation. Copy to
a directory like this : ${andromda.install.path}/cartridges/andromda-bpm4struts/.

<P>
The cartridge will only work with an AndroMDA distribution of version
3.0 or higher.

<P>

<H1><A NAME="SECTION00040000000000000000">
3 How to use</A>
</H1>

<P>
In your Ant build.xml task you will need to have something like this:

<P>

<DL COMPACT>
<DT>
<DD>&lt;andromda&nbsp;basedir='${basedir}'&nbsp;...etc...&nbsp;&gt;

<P>
&nbsp;&nbsp;&lt;outlet&nbsp;cartridge='bpm4struts'&nbsp;outlet=''actions''&nbsp;dir='${path}'/&gt;

<P>
&nbsp;&nbsp;&lt;outlet&nbsp;cartridge='bpm4struts'&nbsp;outlet=''forms''&nbsp;dir='${path}'/&gt;

<P>
&nbsp;&nbsp;&lt;outlet&nbsp;cartridge='bpm4struts'&nbsp;outlet=''config''&nbsp;dir='${path}'/&gt;

<P>
&nbsp;&nbsp;&lt;outlet&nbsp;cartridge='bpm4struts'&nbsp;outlet=''pages''&nbsp;dir='${path}'/&gt;

<P>
&lt;/andromda&gt;
</DD>
</DL>
<P>

<H1><A NAME="SECTION00050000000000000000">
4 Features</A>
</H1>

<P>

<H2><A NAME="SECTION00051000000000000000">
4.1 Struts (PSM)</A>
</H2>

<P>
This cartridge will generate the most important files that you will
need to build your Struts application. Although not everything <I>can</I>
be generated we try to take over as much work as possible, therefore
one of the top requirements for this cartridge is: the user needs
only to write application specific business-process logic, the rest
should be generated from the model.

<P>
In the Struts MVC framework we consider the following elements:

<P>

<UL>
<LI>JSP pages, they represent the views. In each of these pages you will
need to code that particular part of the application, this is different
in every application.
</LI>
<LI>Form beans, they represent the models. There is no specific logic
in these beans as they are used as a common means of data transfer
to and from the view.
</LI>
<LI>Actions, they represent the controllers. An action contains the logic
to transfer data from the back-end to the front-end (the views). These
actions usually do not contain any business logic, instead they only
contain <I>process logic</I>, meaning they delegate to the business
objects (such as session facades). It is the responsibility of the
actions the control the flow of the application.
</LI>
<LI>Configuration. The Struts configuration file is written in XML and
describes which actions use which form beans and can forward control
to which pages or controllers. Information contained herein is directly
used in the controller classes.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00052000000000000000">
4.2 UML (PIM)</A>
</H2>

<P>
In order to be able to generate all these elements we will use a common
means of describing the application flow: UML. Please note that the
UML model will need to follow some strict guidelines, these are not
constraints but conventions. Respecting these guidelines in a strict
sense will avoid misinterpretation (by human-readers as well as machine-readers).
More on this later.

<P>
What do we have in UML that can help us model our application:

<P>

<UL>
<LI>Initial state. The start of the flow. There can be only one.
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="initial-state.gif"
 ALT="Image initial-state.gif">
</LI>
<LI>Final state. The end of the flow. There may be several ways the flow
ends (eg. succesful and unsuccesful).
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="final-state.gif"
 ALT="Image final-state.gif">
</LI>
<LI>Action states. An action state represents a condition of a modeled
entity for which some action is performed. What this action exactly
is supposed to be is undefined. Since we are modeling a Struts front-end
I thought it would be intuitive to represent actions triggered from
JSP pages this way<A NAME="tex2html4"
  HREF="#foot45"><SUP>4</SUP></A>.
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="action-state.gif"
 ALT="Image action-state.gif">
</LI>
<LI>Object flow states. These are states that represent a change of state
of an object, as opposed to action states there is no view directly
associated to an object flow state.
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="object-flow-state.gif"
 ALT="Image object-flow-state.gif">
</LI>
<LI>Transitions. Used to indicate a path between states. We have different
kinds of transitions:
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="transition.gif"
 ALT="Image transition.gif"> <IMG
 ALIGN="BOTTOM" BORDER="0" SRC="transition-triggered.gif"
 ALT="Image transition-triggered.gif"> <IMG
 ALIGN="BOTTOM" BORDER="0" SRC="transition-guarded.gif"
 ALT="Image transition-guarded.gif"> <IMG
 ALIGN="BOTTOM" BORDER="0" SRC="transition-triggered-guarded.gif"
 ALT="Image transition-triggered-guarded.gif">
</LI>
<LI>Merge points. A state should only have a single incoming and outgoing
transition, use merge points to bundle several incoming transitions
and merge them into a single transition.
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="merge.gif"
 ALT="Image merge.gif">
</LI>
<LI>Decision points. They are the opposite of merge points, a single incoming
transition is forked into several outgoing transitions. Which outgoing
transition is actually followed at run-time depends on the associated
decision process.
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="decision.gif"
 ALT="Image decision.gif">
</LI>
</UL>

<P>

<H1><A NAME="SECTION00060000000000000000">
5 Modeling</A>
</H1>

<P>
When modeling an application process flow in UML you should not take
into account that the end result will be implemented in Struts, it
could very well be you change your mind later on and decide to use
another technology. That's why you should think about modeling a front-end
rather than <I>web pages</I> or <I>GUI windows</I>.

<P>
First of all it is important to note that you will be modeling on
the level of each individual use-case, a use-case combines each unique
unit of process logic together. Typically application use-cases could
be: 'Login', 'Add item to basket', 'Send purchase order', ... You
would then model an activity graph for each such use-case. In order
to be able to interconnect the different use-case you would use state
charts, these will connect a use-case's final states to the initial
states of the next use-cases.

<P>

<H2><A NAME="SECTION00061000000000000000"></A><A NAME="Login_example"></A>
<BR>
5.1 From UML to Struts: An example use-case
</H2>

<P>
To show you the code generation process I decided to start from an
example. Consider the following well known use-case: 'Login'. A user
is presented to enter his name and password for verification, if verification
succeeds he can continue, otherwise he is prompted again. Here are
the diagrams for this use-case:

<P>
<IMG
 ALIGN="BOTTOM" BORDER="0" SRC="use-case-login.gif"
 ALT="Image use-case-login.gif"> <IMG
 ALIGN="BOTTOM" BORDER="0" SRC="class-diagram-login.gif"
 ALT="Image class-diagram-login.gif">
<BR>
What is not shown on these images is that the 'Login' use-case is
linked to the 'LoginController' class by means of a tagged value;
this is the reason the cartridge will know what classes to generate
from the model, more concretely what the attributes of the form are.
So exactly what is generated from these simple diagrams<A NAME="tex2html5"
  HREF="#foot61"><SUP>5</SUP></A> ? Let's take a look.

<P>

<H3><A NAME="SECTION00061100000000000000">
5.1.1 JSP pages</A>
</H3>

<P>
For every action state in the graph a corresponding JSP page is generated,
from these pages a call to the controller class is made.
<BR><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="view-jsp-page.gif"
 ALT="Image view-jsp-page.gif">
<BR>
Notice how the controller action is called with a parameter. In this
particular case there is only one trigger (it has not been named and
is therefore anonymous) so there will only be a single hyperlink or
submit button.

<P>

<H3><A NAME="SECTION00061200000000000000">
5.1.2 Action class</A>
</H3>

<P>
First of all we will have an action class generated from this use-case,
this class serves as the controller class. There will be an abstract
parent class as well as an implementation class. The latter is used
to code the link to the business objects, this is done manually.

<P>

<H4><A NAME="SECTION00061210000000000000">
5.1.2.1 Abstract Controller class</A>
</H4>

<P>
<IMG
 ALIGN="BOTTOM" BORDER="0" SRC="controller-abstract.gif"
 ALT="Image controller-abstract.gif">
<BR>
Notice how the model elements from the use-case's graph have been
transformed into Java code:

<P>

<UL>
<LI>super class: DispatchAction
<BR>
This allows us to bundle different controller calls that logically
belong together into one class, DispatchAction classes are designed
to do exactly that.
</LI>
<LI>constant fields
<BR>
These are derived from the transition guard names, they are the hash
code of the toUpperCase() conversion, these values are to be used
as return values in the implementation class' decision methods, these
return values are checked in this class.
</LI>
<LI>unspecified()
<BR>
When the controller is called without any specific target dispatch
method name it will simply start the use-case. In this case it will
call a forward that will return a JSP page.
</LI>
<LI>enterUsernameandPassword(...)
<BR>
This method is called from a JSP page, the model (form) is passed
to the controller and the it will be verified if the entered credentials
are valid. So after the user has entered his name and password, and
has submitted the form this method is called.
</LI>
<LI>userNameAndPasswordVerifies(...)
<BR>
You cannot see how this name is derived from the graph, but in fact
I named the decision point ``user name and password verifies ?'',
it's just not showing in the diagram. Note how the result of the verification
is used to determine how to proceed next. If the verification failed
the same forward that showed the JSP page is called again, otherwise
the user profile is loaded in the session and we continue.
</LI>
<LI>setUserProfileLoadedInSession(...)
<BR>
This method is responsible of loading and storing the user's profile
into the session, this could be a HttpSession or something else depending
on the technology you wish to use. Next, the final forward is called
to exit this use-case.
</LI>
</UL>
Please nottice there are some abstract methods being called, they
will need to be implemented by the user. They are described next.

<P>

<H4><A NAME="SECTION00061220000000000000">
5.1.2.2 Controller class implementation</A>
</H4>

<P>
<IMG
 ALIGN="BOTTOM" BORDER="0" SRC="controller-implementation.gif"
 ALT="Image controller-implementation.gif">
<BR>
The controller implementation obviously extends the abstract controller
class and implements the abstract methods.

<P>

<UL>
<LI>userNameAndPasswordVerifiesImpl(...)
<BR>
This method must be implemented to return one of constants defined
in the parent class (VERIFIED or NOT_VERIFIED). How this is done
depends on the business objects and is left to the user.
</LI>
<LI>setUserProfileLoadnSessionImpl(...)
<BR>
Load the user profile in the session, this too is left to the user
since it is not described in the UML model.
</LI>
</UL>

<P>

<H4><A NAME="SECTION00061230000000000000">
5.1.2.3 Model form</A>
</H4>

<P>
<IMG
 ALIGN="BOTTOM" BORDER="0" SRC="model-form.gif"
 ALT="Image model-form.gif">
<BR>
This is a simple Bean class, the trigger field is used to store the
'button' used to trigger the call to a controller class. All the other
fields represent the input fields that are used in the view (JSP).

<P>

<H4><A NAME="SECTION00061240000000000000">
5.1.2.4 Configuration</A>
</H4>

<P>
<IMG
 ALIGN="BOTTOM" BORDER="0" SRC="configuration.gif"
 ALT="Image configuration.gif">
<BR>
We can clearly see these distinct parts in the configuration file:

<P>

<UL>
<LI>&lt;form-beans&gt;
<BR>
For each use case the associated form bean is looked up and added
to the list here.
</LI>
<LI>&lt;global-exceptions&gt;
<BR>
To be ignored for the moment, it is possible to generate exception
handlers from the model but this is still under development.
</LI>
<LI>&lt;global-forwards&gt;
<BR>
For each use-case (or workflow for that matter) there will be a forward
here that provides the user with an entry point to the use-case. Notice
how we <I>redirect</I> instead of <I>forward</I>; this is done to
flush any remaining object in the request and start with a new, clean,
request.
</LI>
<LI>&lt;action-mappings&gt;
<BR>
For each use-case you will find an action mapping entry here, notice
the <I>parameter</I> attribute, it denotes the name of the request
parameter that will determine the dispatch method to call. You can
also see that the form bean (model) is put into the request scope
for this action, just as it should.
<BR>
Next, there are some forward, we have two different kinds of forwards.
The first one 'enter.username.and.password' is a forward used internally
by the use-case (if you recall, it is called when login fails, the
user is again presented the login page), therefore it forwards rather
than it redirects, this is to keep the form bean in the request<A NAME="tex2html6"
  HREF="#foot82"><SUP>6</SUP></A>. In this particular case this is no concern, but most of the time
it is better to forward than to redirect.
<BR>
The other forward represents the final state of the use-case, and
this time redirects to the next use-case. This forward is followed
when the user has succeeded to login. Because of the simplicity of
the UML model we do not have a next use-case (and this is in violation
with the correctness), I have indicated this by manually entering
the string '[next-use-case-controller-call-here]' at that location
in the code. In a correctly modeled application there would be a next
use-case, or it would be modeled the use-case would start over again.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00062000000000000000">
5.2 Starting from scratch: step by step</A>
</H2>

<P>
When you understand what happened in the short example you are ready
to try it for yourself, here's a small guide that will help you in
the process. This documentation comes with a sample UML project (modeled
in Poseidon 1.6), open that project while reading this section, you
will much better understand what is going on.

<P>

<H3><A NAME="SECTION00062100000000000000">
5.2.1 Define stereotypes</A>
</H3>

<P>
First of all make sure you are able to create your model with some
stereotypes, you will need to declare them first

<P>

<UL>
<LI>FrontEndWorkflow, to be applied on UseCase model elements
</LI>
<LI>FrontEndUseCase, also to be applied on UseCase model elements
</LI>
<LI>FrontEndController, to be applied on Class model elements
</LI>
<LI>FrontEndModel, to be applied on Class model elements
</LI>
<LI>FrontEndView, to be applied on ActionState model elements
</LI>
<LI>FrontEndExceptionHandler, to be applied on Class model elements<A NAME="tex2html7"
  HREF="#foot89"><SUP>7</SUP></A>
</LI>
</UL>

<P>

<H3><A NAME="SECTION00062200000000000000">
5.2.2 Identify and model application workflows</A>
</H3>

<P>
You will then need to model the application workflow on the highest
level, we call this <I>coarse-grain</I> modeling. Basically this comes
down to modeling the interconnection of different use-cases.

<P>
Create a UseCase for each workflow, tag this UseCase with the 'FrontEndWorkflow'
stereotype. Add a state graph to this UseCase (you will do this by
selecting diagram in your CASE tool, do not confuse state graphs with
activity graphs). Model the workflow in this graph.

<P>
Each state in this workflow will need to be modeled as a individuel
UseCase, these are described next.

<P>

<H3><A NAME="SECTION00062300000000000000">
5.2.3 Model each workflow state as a use-case</A>
</H3>

<P>
For each state you will create another UseCase model element, this
time you will add an activity graph to that UseCase, in there you
will model the activity on a lower level, this is called <I>fine-grain</I>
modeling. When modeling such as use-case you will need to tag each
ActionState with the 'FrontEndView' stereotype. The Login UseCase
(see <A HREF="readme.html#Login_example">5.1</A>) is such an example. Each such UseCase needs
a tagged value that links it to a Class, this is to tell the cartridge
which object handles the process control. You do this by using a tag
like this, where obviously the right-hand argument is a fully qualified
name of a class in the UML model:

<P>

<DL COMPACT>
<DT>
<DD>ControllerClass&nbsp;=&nbsp;org.sample.LoginController
</DD>
</DL>Also, do not forget to give this UseCase the 'FrontEndUseCase' stereotype.

<P>

<H3><A NAME="SECTION00062400000000000000">
5.2.4 Create a controller Class for each use-case</A>
</H3>

<P>
That's all, simply create the class with the name and the package
specified in the tagged value of the UseCase. Use the 'FrontEndController'
stereotype here.

<P>

<H3><A NAME="SECTION00062500000000000000">
5.2.5 Optionally create a model Class for each use-case</A>
</H3>

<P>
If you wish to use forms with your controller you can optionally define
a class that will be used as the form bean, you may add attributes
to this class, they will be taken into account by the code generation
process. Do not forget to make an association between the controller
class and this class. Adding more than one model class to a controller
class may give undefined results. Use the 'FrontEndModel' stereotype
here.

<P>

<H1><A NAME="SECTION00070000000000000000">
6 UML model constraints</A>
</H1>

<P>
Most CASE tools allow a very flexible way of modeling your applications,
this is a good thing. However, as a UML model is independent from
any implementation technology sometimes this freedom imposes some
issues. Therefore this section explains the model constraints you
will need to respect when modeling.

<P>
I decided the most efficient way of explaining these constraints would
be to use an EBNF-like syntax, the '::=' shows what state vertex may
follow, the '|' means 'or', x+ (where x is a number) means at least
x times.

<P>

<DL COMPACT>
<DT>
<DD><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="model-constraints-ebnf.gif"
 ALT="Image model-constraints-ebnf.gif">
</DD>
</DL>What is most important here is that a triggered decision point can
only occur right after an action state, the reason for this is that
a trigger corresponds to a button an a page, and since pages are generated
from action states it is pretty easy to see that having triggers on
other transitions would be confusing. As an example simply try to
find out which trigger belongs to which action state if you have modeled
several decision points between your action states and triggers.

<P>
Also important is that you can only have guarded transitions combined
on a decision point, the reason is that while UML allows guards on
any transition this is difficult to translate into a Struts front-end.
Strictly speaking a guard is evaluated after that transition's trigger
has been called, but what happens if the guard fails ? Do we display
an error, do we re-start the use-case, ... ? A simple and straightforward
solution is to not apply guards as strictly as they are modeled in
UML, concretely this means we will never evaluate guards individually,
but we will evaluate a single decision point where the guards are
possible outcomes. The guard representing the resulting outcome corresponds
to the transition that will then be followed.

<P>

<DL COMPACT>
<DT>
<DD><P>
</DD>
</DL>
<P>

<H1><A NAME="SECTION00080000000000000000">
7 Naming conventions</A>
</H1>

<P>
The following rules describe the conversion from names in the UML
model's graphs to names in the generated code. You are free to use
any name for your model elements, except for classes, you should give
them the name you want in the generated code.

<P>
This means action states, use-cases, ... can have any name, the cartridge
will take care of it.

<P>

<H4><A NAME="SECTION00080010000000000000">
7.0.0.1 Web files and forwards</A>
</H4>

<P>
All non alphanumeric characters will be discarded and be replaced
by a hyphen, all characters will be converted to lowercase. Example

<P>

<DL COMPACT>
<DT>
<DD>this&nbsp;&nbsp;&nbsp;:&nbsp;enter&nbsp;name&nbsp;&amp;&nbsp;number&nbsp;!

<P>
becomes:&nbsp;enter-name-number
</DD>
</DL>
<P>

<H4><A NAME="SECTION00080020000000000000">
7.0.0.2 Java file names</A>
</H4>

<P>
All non alphanumeric characters will be discarded, the character following
such discarded character will be uppercased. This first character
will also be uppercased. Example

<P>

<DL COMPACT>
<DT>
<DD>this&nbsp;&nbsp;&nbsp;:&nbsp;enter&nbsp;name&nbsp;&amp;&nbsp;number&nbsp;!

<P>
becomes:&nbsp;EnterNameNumber
</DD>
</DL>
<P>

<H1><A NAME="SECTION00090000000000000000">
8 Cartridge feature matrix</A>
</H1>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><I>PIM ModelElement</I></TD>
<TD ALIGN="CENTER"><I>Aspect</I></TD>
<TD ALIGN="CENTER"><I>PSM Feature</I>
<BR>
UseCase</TD>
</TR>
</TABLE>
<H1><A NAME="SECTION000100000000000000000">
About this document ...</A>
</H1>
 <STRONG>AndroMDA
<BR>
Business Process Modeling
<BR>
for Struts</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002 (1.62)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>,
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>,
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-no_subdir -split 0 -show_section_numbers /tmp/lyx_tmpdir5282kR42Z9/lyx_tmpbuf0/readme.tex</TT>
<P>
The translation was initiated by draftdog on 2003-10-27
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot25">... AndroMDA</A><A
 HREF="readme.html#tex2html1"><SUP>1</SUP></A></DT>
<DD>http://andromda.sourceforge.net

</DD>
<DT><A NAME="foot26">... MDA</A><A
 HREF="readme.html#tex2html2"><SUP>2</SUP></A></DT>
<DD>http://www.omg.org/mda

</DD>
<DT><A NAME="foot27">... Struts</A><A
 HREF="readme.html#tex2html3"><SUP>3</SUP></A></DT>
<DD>http://jakarta.apache.org

</DD>
<DT><A NAME="foot45">... way</A><A
 HREF="readme.html#tex2html4"><SUP>4</SUP></A></DT>
<DD>There already has been some discussion on the AndroMDA mailing list
about whether or not JSP pages should be generated from action states.
I will not discuss that here now, but there are both advantages and
disadvantages of taking this approach.

</DD>
<DT><A NAME="foot61">... diagrams</A><A
 HREF="readme.html#tex2html5"><SUP>5</SUP></A></DT>
<DD>Please note that this diagram represents a graphical UML data structure,
AndroMDA generates from this data structure rather than from the diagram.

</DD>
<DT><A NAME="foot82">... request</A><A
 HREF="readme.html#tex2html6"><SUP>6</SUP></A></DT>
<DD>Or more correct: to avoid the creation of a new request, in which
there would be a new form bean instance.

</DD>
<DT><A NAME="foot89">... elements</A><A
 HREF="readme.html#tex2html7"><SUP>7</SUP></A></DT>
<DD>Ignore this one for now.

</DD>
</DL><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/share/latex2html/icons/nx_grp_g.png">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
draftdog
2003-10-27
</ADDRESS>
</BODY>
</HTML>
