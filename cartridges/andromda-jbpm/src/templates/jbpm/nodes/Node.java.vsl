##
##
##
#set ($generatedFile = "${node.nodeClassName}.java")
#if ($stringUtils.isNotBlank($node.nodePackageName))
#set ($generatedFile = "$stringUtils.replace($node.nodePackageName,'.','/')/$generatedFile")
package $node.nodePackageName;

#end
#set ($nodeInterfaceName = $node.processDefinition.nodeInterfaceName)
/**
 * The node representing the $node.name state in the <em>$node.processDefinition.name</em> process.
 */
public final class $node.nodeClassName implements $nodeInterfaceName
{
    private org.jbpm.graph.exe.Token token = null;

    /**
     * Constructs a new node using the specific process instance token. This constructor is package private
     * because it is not supposed to be instantiated by other regular classes.
     *
     * @param token the token for which this node is constructed
     */
    ${node.nodeClassName}(final org.jbpm.graph.exe.Token token)
    {
        this.token = token;
    }

    /**
     * This node is associated with a specific process instance and this method return the root token
     * for that instance.
     *
     * @return the token with which this node has been associated (constructed)
     */
    public org.jbpm.graph.exe.Token getToken()
    {
        return this.token;
    }

    /**
     * Returns the identifier for the underlying process instance. This method is a conveniece method as it
     * is perfectly equivalent to <code>new java.lang.Long(getToken().getProcessInstance().getId())</code>.
     *
     * @return the identifier for the proces instance to which this node is associated
     */
    public java.lang.Long getProcessInstanceId()
    {
        return new java.lang.Long(this.token.getProcessInstance().getId());
    }

#if ($node.finalState)
    /**
     * Ends the process instance.
     */
    public void endProcess()
    {
        this.token.end();
        this.token.getProcessInstance().end();
    }

#elseif ($node.taskNode)
#if (!$node.tasks.empty)
    /**
     * Returns true if all tasks for this node are ended.
     *
     * @return true if this node does not have any tasks that have not yet been finished, false otherwise
     */
    public boolean isTasksFinished()
    {
        return !this.token.getProcessInstance().getTaskMgmtInstance().hasUnfinishedTasks(this.token);
    }

#end
#foreach ($task in $node.tasks)
#set ($taskName = $stringUtils.upperCamelCaseName($task.name))
    /**
     * Starts this node's <em>$task.name</em> task.
     */
    public void start${taskName}()
    {
        final org.jbpm.taskmgmt.exe.TaskInstance task = this.get${taskName}Task();
        if (task != null)
        {
            task.start();
        }
    }

    /**
     * Finishes this node's <em>$task.name</em> task.
     */
    public void finish${taskName}()
    {
        final org.jbpm.taskmgmt.exe.TaskInstance task = this.get${taskName}Task();
        if (task != null)
        {
            task.end();
        }
    }

    /**
     * Checks whether or not this node's <em>$task.name</em> task has been finished.
     *
     * @return true if this node's $task.name has been finished, false otherwise
     */
    public boolean is${taskName}Finished()
    {
        final org.jbpm.taskmgmt.exe.TaskInstance task = this.get${taskName}Task();
        return task == null ? true : task.hasEnded();
    }

#set ($taskField = "task${taskName}")
    private org.jbpm.taskmgmt.exe.TaskInstance $taskField = null;

    org.jbpm.taskmgmt.exe.TaskInstance get${taskName}Task()
    {
        if (this.$taskField == null)
        {
            final java.util.Collection tasks = this.token.getProcessInstance().getTaskMgmtInstance().getTaskInstances();
            for (final java.util.Iterator taskIterator = tasks.iterator(); taskIterator.hasNext() && this.$taskField == null;)
            {
                final org.jbpm.taskmgmt.exe.TaskInstance taskInstance = (org.jbpm.taskmgmt.exe.TaskInstance)taskIterator.next();
                if ("$task.name".equals(taskInstance.getName()))
                {
                    this.$taskField = taskInstance;
                }
            }
        }
        return this.$taskField;
    }

#end
#end
#if ($node.outgoing.size() == 1)
#set ($transition = $node.outgoing.iterator().next())
#set ($target = $transition.target)
    /**
     * Signals the process to leave this node and proceed to the next one.
#if ($node.initialState)
     * Calling this method will make the process leave the start state and enter the first node.
#end
#if ($target.outgoing.size()>1)
     * Since this transition leads into a node that will split it up into different transitions
     * this method returns the {@link $nodeInterfaceName} instead of a concrete implementing class type.
#end
     *
     * @return the next node in the process
     */
#if ($target.outgoing.size()>1)
    public $nodeInterfaceName signal()
#else
    public $target.nodeClassName signal()
#end
    {
        this.token.signal();
#if ($target.outgoing.size()>1)
        $nodeInterfaceName targetNode = null;
        final java.lang.String nodeName = this.token.getNode().getName();

#foreach ($targetNode in $transition.possibleTargetNodes)
        if ("$targetNode.name".equals(nodeName)) targetNode = new ${targetNode.nodeClassName}(this.token); else
#end
        throw new IllegalArgumentException("No matching node could be found for target token: " + nodeName);

        return targetNode;
#else
        return new ${target.nodeClassName}(this.token);
#end
    }

#else
#foreach ($transition in $node.outgoing)
#set ($target = $transition.target)
    /**
     * Signals the process to leave this node via the <em>$transition.name</em> transition and proceed to the next one.
#if ($target.outgoing.size()>1)
     * Since this transition leads into a node that will split it up into different transitions
     * this method returns the {@link $nodeInterfaceName} instead of a concrete implementing class type.
#end
     *
     * @return the next node in the process after following the <em>$transition.name</em> transition
     */
#if ($target.outgoing.size()>1)
    public $nodeInterfaceName signal$stringUtils.upperCamelCaseName($transition.name)()
#else
    public $transition.target.nodeClassName signal$stringUtils.upperCamelCaseName($transition.name)()
#end
    {
        this.token.signal("$transition.name");
#if ($target.outgoing.size()>1)
        $nodeInterfaceName targetNode = null;
        final java.lang.String nodeName = this.token.getNode().getName();

#foreach ($targetNode in $transition.possibleTargetNodes)
        if ("$targetNode.name".equals(nodeName)) targetNode = new ${targetNode.nodeClassName}(this.token); else
#end
        throw new IllegalArgumentException("No matching node could be found for target token: " + nodeName);

        return targetNode;
#else
        return new ${transition.target.nodeClassName}(this.token);
#end
    }

#end
#end
}