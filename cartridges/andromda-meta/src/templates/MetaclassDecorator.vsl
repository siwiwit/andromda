#set ($packagename = $class.package.fullyQualifiedName)
package $packagename;

#macro ( generateDocumentation $item $indent)
#foreach ( $tgv in $item.taggedValues )
#if ($tgv.tag == "documentation")
#set ($paras = $tgv.value.formatHTMLStringAsParagraphs())
#foreach ( $par in $paras )
${indent}*
${indent}* <p>
#foreach ( $line in $par.lines )
${indent}* $line
#end
${indent}* </p>
#end
#end
#end
#end

## calculate metaclass and superclass
#set ($decoratedMetaclass = $transform.getMetaclass($class))
#set ($decoratedMetaclassTypeName = $decoratedMetaclass.fullyQualifiedName)
##
#set ($superclass = $class.superclass)
#if ($superclass)
    #set ($superclassName = "${superclass.fullyQualifiedName}Impl")
#else
    #if ($decoratedMetaclassTypeName != "org.omg.uml.foundation.core.ModelElement" && $decoratedMetaclassTypeName != "org.omg.uml.UmlPackage")
    	#set ($superclassName = "ModelElementDecoratorImpl")
    #else
    	#set ($superclassName = "DecoratorBase")
    #end
#end
##
/**
#generateDocumentation ($class " ")
 *
 * Metaclass decorator for $decoratedMetaclassTypeName
 *
#foreach ( $tgv in $class.taggedValues )
#if ($tgv.tag != "documentation")
#if ($tgv.tag == "---")
    #set ($tag = "")
#else
    #set ($tag = $tgv.tag)
#end
 * $tag    $tgv.value
#end
#end
 *
 */
public abstract class ${class.name}
       extends    $superclassName
       implements $decoratedMetaclassTypeName
{
    // -------- link to decorated metaobject ----------
    
    protected $decoratedMetaclassTypeName  metaObject;

    public ${class.name} ($decoratedMetaclassTypeName metaObject)
    {
        super (metaObject);
        this.metaObject = metaObject;
    }
    
#set ($allMethods = $transform.getMethodMap($decoratedMetaclassTypeName))
##
    // --------------- attributes ---------------------
#foreach ( $att in $class.attributes )
#set ($atttypename = $att.type.fullyQualifiedName)

   /**
#generateDocumentation ($att "    ")
    *
    */
    public abstract $atttypename ${att.getterName}();
#set ($allMethods = $transform.excludeSimpleGetter($allMethods, $atttypename, $att.name))
#end


    // ---------------- real business methods ----------------------

#foreach ( $op in $class.operations)
   /**
#generateDocumentation ($op "    ")
    *
    */
    $op.visibility abstract $op.type.fullyQualifiedName ${op.signature};
    
#set ($allMethods = $transform.excludeUMLOperation($allMethods, $op))
#end
    // ------------- relations ------------------
    
#foreach ( $assoc in $class.associationLinks )
#set ($adata = $transform.getAssociationData($assoc))
#if ($adata.target.navigable == "true")
##
#set ($sourcetype = $adata.source.type)
#set ($targettype = $adata.target.type)
#if ($targettype.stereotypeName == "Decorator")
## if a decorator is the target of the association, replace by decorated interface type!
## this will make it possible to override methods in the base interface.
#foreach ( $dep in $targettype.dependencies )
    #set ($class2 = $dep.targetType)
    #if ($class2.stereotypeName == "metaclass")
        #set ($targettype = $class2)
    #end
#end
#end

#set ($targettypename = $targettype.fullyQualifiedName)
##
#set ($trn = $adata.target.roleName)
#set ($utrn = $str.upperCaseFirstLetter($trn))
##
#if ($adata.isOne2Many() || $adata.isMany2Many())
    protected abstract java.util.Collection handleGet${utrn}();
    
   /**
#generateDocumentation ($adata.target.end "    ")
##    * multiplicity:     $adata.multiplicities
##    * source navigable: $adata.source.navigable
##    * target navigable: $adata.target.navigable
    *
    */
    public java.util.Collection get${utrn}()
    {
        return decoratedElements(handleGet${utrn}());
    }
#set ($allMethods = $transform.excludeSimpleGetter($allMethods, "java.util.Collection", $trn))
#end
#if ($adata.isOne2One() || $adata.isMany2One())
    protected abstract org.omg.uml.foundation.core.ModelElement handleGet${utrn}();

   /**
#generateDocumentation ($adata.target.end "    ")
##    * multiplicity:     $adata.multiplicities
##    * source navigable: $adata.source.navigable
##    * target navigable: $adata.target.navigable
    *
    */
    public ${targettypename} get${utrn}()
    {
        return (${targettypename}) decoratedElement(handleGet${utrn}());
    }
#set ($allMethods = $transform.excludeSimpleGetter($allMethods, $targettypename, $trn))
#end

    // ------------------------------------------------------------

#end
#end

## superclass should already implement the decorating methods.
## we need not repeat them here!
#if ($superclass)
    // decorating methods not implemented here. 
    // they are already in ${superclassName}
    // or in a superclass of that.
#else
    // ---------------- decorating methods ----------------------
    
##
## The calls to "transform.exclude..." above have excluded all those
## methods from the list that shall not delegate to the metaobject 
## but shall be implemented in this decorator itself.
##
## So, now we can generate the source code for delegation in a quite
## straightforward way.
##
#foreach ($dm in $transform.sortMethodsFlat($allMethods))
    // from $dm.parentInterfaceName
    $dm.getDeclaration(true)
    {
#if ($dm.hasReturnType())
        return metaObject.${dm.getMethodCall()};
#else
        metaObject.${dm.getMethodCall()};
#end    
    }

#end
#end
}
