//
// Attention: generated code (by MetafacadeLogic.vsl) - do not modify!
//
#set ($packagename = $class.package.fullyQualifiedName)
package $packagename;

## calculate metaclass and superclass
#if ($class.metaclassDirectDependency)
#set ($shieldedMetaclassTypeName = $class.metaclass.fullyQualifiedName)
#else
#set ($shieldedMetaclassTypeName = "java.lang.Object")
#end
##
#set ($superclass = $class.generalization)
##
/**
 * MetafacadeLogic for $class.fullyQualifiedInterfaceName
 *
 * @see $class.fullyQualifiedInterfaceName
 */
public abstract class ${class.name}Logic
       extends        org.andromda.core.metafacade.MetafacadeBase
       implements     $class.fullyQualifiedInterfaceName
{
    protected $shieldedMetaclassTypeName metaObject;
#if ($superclass)
    private $superclass.fullyQualifiedInterfaceName super_;
#end

    public ${class.name}Logic ($shieldedMetaclassTypeName metaObject, java.lang.String context) {
        super (metaObject, getContext(context));
#if ($superclass)
        this.super_ =
           (${superclass.fullyQualifiedInterfaceName})
            org.andromda.core.metafacade.MetafacadeFactory
                .getInstance()
                .createFacadeImpl(
                    "${superclass.fullyQualifiedInterfaceName}",
                    metaObject,
                    getContext(context));
#end
        this.metaObject = metaObject;
    }

    /**
     * Gets the context for this metafacade logic instance.
     */
    private static String getContext(String context) {
    	if (context == null) {
            context = "${class.fullyQualifiedInterfaceName}";
        }
        return context;
    }

##

#set ($atts = $class.attributes)
#if ($atts.size() > 0)
    // --------------- attributes ---------------------
#foreach ( $att in $atts )
##
#set ($memberTypeName = $att.type.fullyQualifiedName)
#set ($methodName = $att.getterName)
#set ($memberName = "a_$att.name")## prefixed with a_ to indicate attribute member (to avoid collisions with other members)
#set ($handleMethodName = "handle$str.upperCaseFirstLetter($methodName)")
#set ($typedArgumentList = "")
##
   /**
	* @see ${memberTypeName}#${methodName}()
    */
    public abstract $memberTypeName ${handleMethodName}($typedArgumentList);

    private boolean ${memberName}Set = false;
    private $memberTypeName $memberName;

    private void ${handleMethodName}PreCondition()
    {
    }

    private void ${handleMethodName}PostCondition()
    {
    }

    public final $memberTypeName ${methodName}()
    {
        if (${memberName}Set) return $memberName;
        ${handleMethodName}PreCondition();
        $memberName = ${handleMethodName}($typedArgumentList);
        ${memberName}Set = true;
        ${handleMethodName}PostCondition();
        return $memberName;
    }

#end
#end

#set ($ops = $class.operations)
#if ($ops.size() > 0)
    // ---------------- real business methods ----------------------

#foreach ( $op in $ops)
#set ($memberTypeName = $op.type.fullyQualifiedName)
#set ($methodName = $op.name)
#set ($memberName = "m_$methodName")## prefixed with m_ to indicate method member (to avoid collisions with other members)
#set ($handleMethodName = "handle$str.upperCaseFirstLetter($methodName)")
#set ($typedArgumentList = $op.typedArgumentList)

    $op.visibility abstract $memberTypeName ${handleMethodName}($typedArgumentList);

    private boolean ${memberName}Set = false;
    private $memberTypeName $memberName;

    private void ${handleMethodName}PreCondition()
    {
    }

    private void ${handleMethodName}PostCondition()
    {
    }

    public final $memberTypeName ${methodName}($typedArgumentList)
    {
        if (${memberName}Set) return $memberName;
        ${handleMethodName}PreCondition();
        $memberName = ${handleMethodName}($op.argumentNames);
        ${memberName}Set = true;
        ${handleMethodName}PostCondition();
        return $memberName;
    }

#end
#end
##
#set ($assocEnds = $class.associationEnds)
#if ($assocEnds.size() > 0)
    // ------------- relations ------------------

#foreach ( $assocEnd in $assocEnds )
#if ($assocEnd.otherEnd.navigable)
##
#set ($memberTypeName = $assocEnd.getterSetterTypeName)
#set ($methodName = "get$str.upperCaseFirstLetter($assocEnd.otherEnd.name)")
#set ($memberName = "r_$methodName")## prefixed with r_ to indicate relation member (to avoid collisions with other members)
#set ($handleMethodName = "handle$str.upperCaseFirstLetter($methodName)")
#set ($typedArgumentList = "")
##
    private boolean ${memberName}Set = false;
    private $memberTypeName $memberName;

    private void ${handleMethodName}PreCondition()
    {
    }

    private void ${handleMethodName}PostCondition()
    {
    }

#if ($assocEnd.one2Many || $assocEnd.many2Many)
    protected abstract java.util.Collection ${handleMethodName}($typedArgumentList);
#else
    protected abstract java.lang.Object ${handleMethodName}($typedArgumentList);
#end

    public final $memberTypeName ${methodName}()
    {
        if (${memberName}Set) return $memberName;
        ${handleMethodName}PreCondition();
#if ($assocEnd.one2Many || $assocEnd.many2Many)
        $memberName = ($memberTypeName)shieldedElements(${handleMethodName}($typedArgumentList));
#else
        $memberName = ($memberTypeName)shieldedElement(${handleMethodName}($typedArgumentList));
#end
        ${memberName}Set = true;
        ${handleMethodName}PostCondition();
        return ($memberTypeName)$memberName;
    }

#end
#end
#end
##
#if ($superclass)
    // ----------- delegates to "superclass" ------------

#foreach ( $method in $superclass.getMethodDataForPSM(true) )
    // from ${method.interfaceName}
	${method.buildMethodDeclaration(true)} {
#if ($method.hasReturnType())
        return super_.${method.buildMethodCall()};
#else
        super_.${method.buildMethodCall()};
#end
	}
#end
#end
##
}
