/* Autogenerated by AndroMDA - do not edit */
## Include global definitions definitions. ##
#parse("templates/EJB.vm")
## Define project specific properties and macros ##
#set ($tablename = $str.toDatabaseAttributeName($entityname, '_'))
##
## Global macro definitions. Normally, these do not need to be changed ##
#macro ( firstJavadocParagraph $item $case $default)
#set ( $parIter = false )
#foreach ( $tgv in $item.taggedValues )
#if ( $tgv.tag == "documentation" && !$parIter)
#set ($parIter = $transform.formatHTMLStringAsParagraphs($tgv.value).iterator())
#end
#end
#set ($text = "")
#if ($parIter && $parIter.hasNext())
#foreach ($line in ${parIter.next().lines} )
#set ($text = "$text $line")
#end
#set ($text = ${text.trim()})
#end
#if ($text == "")
#set ($text = "$default")
#end
#if ($case == "upper")
$str.upperCaseFirstLetter($text)
#elseif ($case == "lower")
$str.lowerCaseFirstLetter($text)
#else
$text
#end
#end
##
#macro ( remainingJavadocParagraphs $item $indent)
#set ($skip = true)
#foreach ( $tgv in $item.taggedValues )
#if ($tgv.tag == "documentation")
#set ($paras = $transform.formatHTMLStringAsParagraphs($tgv.value))
#foreach ( $par in $paras )
#if ($skip)
#set ($skip = false)
#else
${indent}*
${indent}* <p>
#foreach ( $line in $par.lines )
${indent}* $line
#end
${indent}* </p>
#end
#end
#end
#end
#end
##
#macro ( generateDocumentation $item $indent)
#foreach ( $tgv in $item.taggedValues )
#if ($tgv.tag == "documentation")
#set ($paras = $transform.formatHTMLStringAsParagraphs($tgv.value))
#foreach ( $par in $paras )
${indent}*
${indent}* <p>
#foreach ( $line in $par.lines )
${indent}* $line
#end
${indent}* </p>
#end
#end
#end
#end
##
##
#macro (copyTaggedValues $item $indent $exclude)
#foreach ( $tgv in $class.taggedValues )
#if ($tgv.tag.startsWith("@") && ! $exclude.contains($tgv.tag))
${indent}* $tgv.tag $tgv.value
#end
#end
#end

##################################################################################
##                         The actual template starts here                      ##
##################################################################################
package $packagename;

/**
 * Autogenerated EJB implementation class for #firstJavadocParagraph(${class} "lower" "the $entityname entity bean.")
#remainingJavadocParagraphs($class " ")
 *
#if ($class.isAbstract())
 * @ejb.bean generate="false"
#else
 * @ejb.bean generate="true"
#end
 *     name="$entityname"
 *     type="CMP" cmp-version="2.x"
 *     view-type="local"
 *     local-jndi-name = "ejb/${transform.replace($transform.findFullyQualifiedName($class),'.','/')}/Local"
#if (!$transform.hasComplexPrimaryKey($class))
 *     primkey-field = "$transform.getSimplePkField($class).name"
#end
 *
 * @ejb.interface generate="false" local-class="${packagename}.${entityname}"
 * @ejb.home generate="false" local-class="${packagename}.${entityname}LocalHome"
 * @ejb.pk generate = "false" class = "$pkclassname"
 *
## Only generate persistence tags for concrete EJBs.
#if(!$class.isAbstract())
 * @ejb.persistence table-name="$tablename"
 *
## Project specific stuff: Generate an environment entry for the 
## primary key sequence if this entity is a concrete EJB and has an IntegerIdPk
#if ($pkclassname == "de.tivano.labdb.datalayer.IntegerIdPK")
 * @ejb.env-entry 
 *     name = "PrimaryKeySequence"
 *     type = "java.lang.String"
 *     value = "${tablename}_SEQ"
 *
#end
#end
## Generate environment entries for all static, readonly attributes stereotyped
## as <<EnvEntry>>
#foreach($att in $transform.getStaticAttributes($class))
#if ($transform.getStereotype($att) == "EnvEntry")
#set ($value = $att.initialValue.body)
## Add string delimiters if they are not already present
#if (!$value.startsWith('"') || !$value.endsWith('"'))
#set ($value = "$value")
#end
 * @ejb.env-entry 
 *     name = "$att.name"
 *     type = "$transform.getFullyQualifiedName($att.type)"
 *     value = $value
 *
#end
#end
#foreach ( $dep in $class.dependencies )
#if ($transform.getStereotype($dep.id) == "EntityRef" || $transform.getStereotype($dep.id) == "ServiceRef")
#set ($myClass = $transform.findClassById($dep.targetType))
#set ($viewtype = $transform.findTagValue($myClass.taggedValues, "@andromda.ejb.viewType"))
#if (!$viewtype || $viewtype == "")
#set ($viewtype = $transform.getEjbRefViewType(${myClass}))
#end
 *
 * @ejb.ejb-ref 
 *     ejb-name="${myClass.name}" 
 *     view-type="$viewtype" 
 *     ref-name="ejb/${transform.replace($transform.findFullyQualifiedName($myClass),'.','/')}"
#end
#if ($transform.getStereotype($dep.id) == "ResourceRef")
#set ($myClass = $transform.findClassById($dep.targetType))
#set ($jndiRef = $transform.findTagValue($dep.id, "@andromda.ejb.resource-ref.jndi-name"))
#set ($resAuth = $transform.findTagValue($dep.id, "@andromda.ejb.resource-ref.res-auth"))
#if (!$resAuth)
#set ($resAuth = "Container")
#end
#set ($resName = $dep.name)
#if (!$resName || $resName == "")
#set ($resName = $myClass.name)
#end
 *
 * @ejb.resource-ref 
 *     res-ref-name="resource/$resName" 
 *     res-type="${transform.findFullyQualifiedName($myClass)}" 
 *     res-auth="$resAuth"
#if ($jndiRef)
 *
 * @jboss.resource-ref 
 *     res-ref-name = "resource/$resName" 
 *     jndi-name = "$jndiRef" 
#end
#end
#end
#foreach ( $op in $class.operations )
#if ($transform.getStereotype($op.id) == "FinderMethod")
#set($querystring = "")
#set($querystring = $transform.findTagValue($op.taggedValues, "@andromda.ejb.query"))
#if($querystring == "")
#set($querystring = "SELECT DISTINCT OBJECT(c) FROM $class.name AS c")
#if($op.parameters.size() >0 )
#set($querystring = "${querystring} WHERE")
#foreach($prm in $op.parameters)
#set($querystring="${querystring} c.$prm.name = ?$velocityCount")
#if($velocityCount != $op.parameters.size())
#set($querystring = "${querystring} AND")
#end
#end
#end
#end
#if($transform.findTagValue($op.taggedValues, "@andromda.ejb.query.dialect") == "JBossQL")
 *
 * @ejb.finder signature="${transform.findFullyQualifiedName($op.getType())} ${transform.getOperationSignature($op)}"
 *             query="This finder method is only supported on the JBoss application server"
 * @jboss.query signature="${transform.findFullyQualifiedName($op.getType())} ${transform.getOperationSignature($op)}"
 *             query="$querystring"
#else
 *
 * @ejb.finder signature="${transform.findFullyQualifiedName($op.getType())} ${transform.getOperationSignature($op)}"
 *             query="$querystring"
#end
#end##if op.stereotype = "FinderMethod"
#end##foreach operation
#copyTaggedValues($class " " [ "@andromda.ejb.viewType", "@andromda.ejb.transactionType",  "@andromda.ejb.noSyntheticCreateMethod" ])
 *
 */
public abstract class ${entityname}Bean 
       extends $beanparentclass
       implements javax.ejb.EntityBean
{
    // ----------- constant definitions --------------------
#foreach($att in $transform.getStaticAttributes($class))
#if ($transform.getStereotype($att) != "EnvEntry")
#set ($attType = $transform.getFullyQualifiedName($att.type))
#set ($ATT_NAME = $str.toDatabaseAttributeName($att.name, '_'))
    private static final $attType $ATT_NAME = $att.initialValue.body;
#end
#end
    
    // -- accessors for environment entries and constants --
#foreach($att in $transform.getStaticAttributes($class))
#set($attType = $transform.getFullyQualifiedName($att.type))
#set($AttName = $str.upperCaseFirstLetter($att.name))
#set ($visibility = $transform.getVisibility($att))

    /**
#if($transform.getStereotype($att) == "EnvEntry")
     * Get #firstJavadocParagraph(${att} "lower" "the <em>${att.name}</em> environment entry")
#else
#set ($ATT_NAME = $str.toDatabaseAttributeName($att.name, '_'))
     * Get #firstJavadocParagraph(${att} "lower" "the <code>$ATT_NAME</code> constant")
#end
#remainingJavadocParagraphs($att "     ")
     *
## Only expose the method to the component interface if it is public.
#if($visibility == "public")
     * @ejb.interface-method
#end
     */
    $visibility $attType get$AttName(){
#if($transform.getStereotype($att) == "EnvEntry")
        javax.naming.InitialContext initialContext = null;
        try {
            initialContext = new javax.naming.InitialContext();
            return (${attType}) initialContext.lookup("java:comp/env/$att.name");
        } catch (javax.naming.NamingException cause) {
            RuntimeException ex = new IllegalStateException(
                "Cannot access environment entry \"$att.name\".");
            // In order to set the exception cause on JDK 1.4
            // and stay JDK 1.3 compatible nonetheless, we need
            // a bit of reflection magic here...
            try {
                java.lang.reflect.Method initCause =
                  ex.getClass().getMethod("initCause", 
                                        new Class[] {Throwable.class});
                initCause.invoke(ex, new Object[] { cause });
            } catch (Throwable t) {
               // Ignore any errors here - we simply make do without the cause
            }
            throw ex;
        } finally {
            try {
                if (initialContext != null) { initialContext.close(); }
            } catch (javax.naming.NamingException ignore) {
                // Silently ignore naming exceptions at cleanup time
            }
        }
#else
        return $ATT_NAME;
#end
    }
## If the attribute is public, expose it to the home interface as well
#if($visibility == "public")

    /**
     * Home interface method for accessing {@link #get$AttName}.
     * @ejb.home-method
     * @see #get$AttName
     */
     public $attType ejbHomeGet$AttName() {
         return get$AttName();
     }
#end
#end

    // --------------- attributes ---------------------
#foreach ( $att in $transform.getInstanceAttributes($class))
#set($attType = $transform.getFullyQualifiedName($att.type))    
#set($AttName = $str.upperCaseFirstLetter($att.name))
#set ($transactionType = $transform.findTagValue($att, "@andromda.ejb.transactionType", true))
#set ($visibility = $transform.getVisibility($att))
    /**
     * Get #firstJavadocParagraph(${att} "lower" "the ${att.name} property")
#remainingJavadocParagraphs($att "     ")
     *
#if ($transform.getStereotype($att) == "PrimaryKey")
     * @ejb.pk-field
#end
     * @ejb.persistence
     *     column-name="${str.toDatabaseAttributeName(${att.name}, "_")}"
     *       jdbc-type="${transform.findAttributeJDBCType($att)}"
     *        sql-type="${transform.findAttributeSQLType($att)}"
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     *
## Only expose the method to the interfaces if it is public. The method
## visibility must be public because of CMP semantics
#if($visibility == "public")
     * @ejb.interface-method 
#end
     */
    public abstract $attType get$AttName();

    /**
     * Set #firstJavadocParagraph(${att} "lower" "the ${att.name} property")
     * @param value the new value
## We need to generate a public set method even for readonly or proteced
## attributes because of CMP semantics. 
## But we don't need to expose it on the interface
#if($visibility == "public" && !$transform.isReadOnly($att))
     * @ejb.interface-method 
#end     
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     */
    public abstract void set$AttName($attType value);
    
#end

    // ------------- CMR relations ------------------
## If the class is abstract, generate abstract methods for all CMR relations so that they
## are accessible in the *BeanImpl class
#if ($class.isAbstract())
#foreach ( $assoc in $transform.getEntityRelations($class) )
#if(!($transform.findTagValue($assoc.source.association, "@andromda.ejb.generateCMR") == "false"))
#set ($assocname = $transform.findEjbRelationName($assoc, $entityname))
#set ($TargetRoleName = ${str.upperCaseFirstLetter($assoc.target.roleName)})
#set ($targetTypeName = $transform.getRelationTargetType($assoc))

   /**
    * Get #firstJavadocParagraph(${assoc.target} "lower" "the ${assoc.target.roleName}")
#remainingJavadocParagraphs($assoc.target "    ")
    * @ejb.interface-method 
    */
    public abstract $targetTypeName get$TargetRoleName();

   /**
    * Set #firstJavadocParagraph(${assoc.target} "lower" "the ${assoc.target.roleName}")
#if(!$transform.isReadOnly($assoc.target))
    * @ejb.interface-method 
#end
    */
    public abstract void set$TargetRoleName($targetTypeName ${assoc.target.roleName});
#end
#end ## foreach

#end
## Generate the real CMR methods.
#foreach ( $assoc in $transform.findEntityRelationsForSource($class) )
## relations not flagged as CMR are generated below under business methods
#if(!($transform.findTagValue($assoc.source.association, "@andromda.ejb.generateCMR") == "false"))
#set ($assocname = $transform.findEjbRelationName($assoc, $entityname))
#set ($TargetRoleName = ${str.upperCaseFirstLetter($assoc.target.roleName)})
#set ($transactionType = $transform.findTagValue($assoc.source.association, "@andromda.ejb.transactionType"))
#set ($targetTypeName = $transform.getRelationTargetType($assoc))

   /**
    * Get #firstJavadocParagraph(${assoc.target} "lower" "the ${assoc.target.roleName}")
#remainingJavadocParagraphs($assoc.target "    ")
    *
    * @ejb.interface-method 
    * @ejb.relation
    *    name="$assocname"
    *    role-name="$assocname:$assoc.source.roleName"
    *    target-ejb="$assoc.target.participant.name"
#if ($assoc.source.navigable == "false")
    *    target-role-name="$assocname:$assoc.target.roleName"
#if ($assoc.isMany2One() || $assoc.isMany2Many())
    *    target-multiple="true"
#end
#end
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    *
#if ($assoc.isMany2One() || $assoc.isOne2One())
#set ($pkfields = $transform.findPkFields($assoc.target.participant))
#set ($pkfieldCount = $pkfields.size())
#if (!$pkfields.isEmpty())
#foreach ($pkfield in $pkfields)
#if ($pkfieldCount == 1)
#set ($fkName = $assoc.target.roleName)
#else
#set ($fkName = "${assoc.target.roleName}${str.upperCaseFirstLetter($pkfield.name)}")
#end
    * @jboss.relation 
    *     fk-column = "${str.toDatabaseAttributeName($fkName, "_")}"
    *     related-pk-field = "$pkfield.name"
#end
#else
    * @jboss.auto-key-fields
#end
#else
    * @jboss.auto-key-fields
#end
    */
    public abstract $targetTypeName get$TargetRoleName();

   /**
    * Set #firstJavadocParagraph(${assoc.target} "lower" "the ${assoc.target.roleName}")
#if(!$transform.isReadOnly($assoc.target))
    * @ejb.interface-method 
#end
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract void set$TargetRoleName($targetTypeName ${assoc.target.roleName});
#end
#end ## foreach 

    // ---------------- business and select methods  ----------------------
## Generate business methods for relations flagged as non-CMR even when the class
## is abstract. That way, we can implement them in the base class
#foreach ( $assoc in $transform.getEntityRelations($class) )
#if($transform.findTagValue($assoc.source.association, "@andromda.ejb.generateCMR") == "false")
#set ($transactionType = $transform.findTagValue($assoc.source.association, "@andromda.ejb.transactionType"))
#set ($targetTypeName = $transform.getRelationTargetType($assoc))
#set ($TargetRoleName = ${str.upperCaseFirstLetter($assoc.target.roleName)})

   /**
    * Get #firstJavadocParagraph(${assoc.target} "lower" "the ${assoc.target.roleName}")
#remainingJavadocParagraphs($assoc.target "    ")
    *
    * @ejb.interface-method 
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract $targetTypeName get$TargetRoleName();

   /**
    * Set #firstJavadocParagraph(${assoc.target} "lower" "the ${assoc.target.roleName}")
    * @ejb.interface-method 
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract void set$TargetRoleName($targetTypeName ${assoc.target.roleName});
#end
#end ## foreach 

#foreach ( $op in $class.operations)
#if ($transform.getStereotype($op.id) != "FinderMethod" && $transform.getStereotype($op.id) != "CreateMethod" && $transform.getStereotype($op.id) != "SelectMethod")
#set ($transactionType = $transform.findTagValue($op, "@andromda.ejb.transactionType", true))
#set ($msig = $transform.getOperationSignature($op))
#set ($interfaceType = "interface")
#set ($visibility = $transform.getVisibility($op))
#set ($exceptions = "")
#set ($exceptions = $transform.findTagValue($op.taggedValues, "@andromda.java.throws"))
#if ($exceptions == "")
#set ($exceptions = $transform.findFullyQualifiedName($defaultException))
#end
## Public static methods are exposed on the home 
## interface instead of the component interface
#if ($visibility == "public" && $transform.isStatic($op)) 
#set ($interfaceType = "home")
#set ($msig = "ejbHome${str.upperCaseFirstLetter($msig)}")
#end
   /**
#generateDocumentation ($op "    ")
    *
## Only public methods have transactions and are exported to the interfaces
#if ($visibility == "public")
    * @ejb.${interfaceType}-method 
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
#end
    */
#set ($returntype = $transform.findFullyQualifiedName($op.getType()))
#if ($exceptions == "")
    $visibility abstract $returntype ${msig};    
#else
    $visibility abstract $returntype ${msig}
        throws $exceptions;
#end
#end
#if ($transform.getStereotype($op.id) == "SelectMethod")
#set($querystring = "")
#set($querystring = $transform.findTagValue($op.taggedValues, "@andromda.ejb.query"))
#if($querystring == "")
#set($querystring = "SELECT DISTINCT OBJECT(c) FROM $class.name AS c")
#if($op.parameters.size() >0 )
#set($querystring = "${querystring} WHERE")
#foreach($prm in $op.parameters)
#set($querystring="${querystring} c.$prm.name = ?$velocityCount")
#if($velocityCount != $op.parameters.size())
#set($querystring = "${querystring} AND")
#end
#end
#end
#end
#set ($returntype = $transform.findFullyQualifiedName($op.getType()))
   /**
#generateDocumentation ($op "    ")
    *
    * @ejb.select query="$querystring"
    */
    public abstract $returntype $transform.getOperationSignature($op) 
    throws javax.ejb.FinderException;
#end##if op.stereotype = "SelectMethod"

#end

    // ---------------- create methods --------------------
## Handle explicitly defined create methods. Since we can't know 
## what the user intended to do with the arbitrary parameters to these methods,
## we generate an abstract ejbCreateImpl() and delegate the implementation to 
## the user.
#foreach ( $op in $class.operations)
#if ($transform.getStereotype($op.id) == "CreateMethod")
#set ($transactionType = $transform.findTagValue($op, "@andromda.ejb.transactionType", true))

    /**
#if (!$class.isAbstract())
     * Implementation for the 
     * {@link #ejbCreate($transform.getOperationParameterTypeNames($op))} 
     * create method.
#else
     * Implementation for create methods in derived classes. This method will be called from
     * the autogenerated  <code>ejbCreate($transform.getOperationParameterTypeNames($op))</code> 
     * methods in concrete subclasses of this abstract EJB.
#end
     *
     * This extra implementation method is necessary to avoid 
     * problems with different primary key classes.
	 *     
     */
    protected abstract void ejbCreateImpl($transform.getOperationTypedParameterList($op))
           throws javax.ejb.CreateException;

    public void ejbPostCreate($transform.getOperationTypedParameterList($op)) {
    }
#end    
#end
#if (!$class.isAbstract())
#foreach ( $op in $transform.getAllCreateMethods($class.id))

    /**
#generateDocumentation ($op "    ")
     *
     */
    public $pkclassname ejbCreate($transform.getOperationTypedParameterList($op))
           throws javax.ejb.CreateException {
       ejbCreateImpl($transform.getOperationParameterNames($op));
       return null;
    }
#end
#end

## Autogenerate a create method implementation with all attributes.
#set ($allAttributes = $transform.filterByVisibility($transform.getAllInstanceAttributes($class.id), "public"))
#set ($inheritedAttributes = $transform.filterByVisibility($transform.getInheritedInstanceAttributes($class.id), "public"))
#set ($instanceAttributes = $transform.filterByVisibility($transform.getInstanceAttributes($class.id), "public"))

    /**
     * Implementation for the create method with all CMP attributes.
     * This method calls the super class implementation for inherited
     * CMP fields and sets all CMP fields defined in this class to the
     * values provided by the parameters. Override this method in the
     * implementation class if you need different behaviour.
     *
     * This extra implementation method is necessary to avoid 
     * problems with different primary key classes.
	 *     
#foreach($att in $allAttributes)
     * @param $att.name Value for #firstJavadocParagraph(${att} "lower" "the ${att.name} property")
#end
     */
    protected void ejbCreateImpl($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!$inheritedAttributes.isEmpty())
        super.ejbCreateImpl($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
#foreach ( $att in $instanceAttributes)
        set${str.upperCaseFirstLetter(${att.name})}(${att.name});
#end
    }

## Only generate create method for the value object for concrete EJBs 
#if (!$class.isAbstract())
    /**
     * Create method with data from an attributes interface
     * @param value the value object
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP 
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $pkclassname ejbCreate(${entityname}Attr value)
           throws javax.ejb.CreateException
    {
        ejbCreateImpl(#foreach($att in $allAttributes)value.get$str.upperCaseFirstLetter($att.name)()#if($velocityCount != $allAttributes.size()),
                      #end#end);
        return null;
    }

    public void ejbPostCreate(${entityname}Attr value)
           throws javax.ejb.CreateException {
    }
#end
    
## Only generate create methods with all CMP and CMR fields for concrete EJBs, 
## and only if it is not explicitly switched off
#if (!$class.isAbstract() && !$transform.findTagValue($class, "@andromda.ejb.noSyntheticCreateMethod"))
    /**
     * Create method with all CMP attribute values.
#foreach($att in $allAttributes)
     * @param $att.name Value for #firstJavadocParagraph(${att} "lower" "the ${att.name} property")
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP 
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $pkclassname ejbCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
        ejbCreateImpl($transform.getAttributesAsList($allAttributes, false, true));
        return null;
    }
#end

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!$inheritedAttributes.isEmpty())
        // Call postCreate method for the super type
        super.ejbPostCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
    }
#set ($relations = $transform.findEntityRelationsForSource($class))
#if (!$relations.isEmpty())
#if (!$class.isAbstract() && !$transform.findTagValue($class, "@andromda.ejb.noSyntheticCreateMethod"))
    /**
     * Create method with all CMP attribute values and CMR relations.
#foreach($att in $allAttributes)
     * @param $att.name Value for #firstJavadocParagraph(${att} "lower" "the ${att.name} property")
#end
#foreach ($rel in $relations)
     * @param $rel.target.roleName Value for #firstJavadocParagraph(${rel.target} "lower" "the ${rel.target.roleName} relation role")
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP 
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $pkclassname ejbCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.isEmpty()), #end#foreach ($rel in $relations)${transform.getRelationTargetType($rel)} $rel.target.roleName#if($velocityCount != $relations.size()), #end#end)
           throws javax.ejb.CreateException
    {
        // Call ejbCreate method for the CMP attributes
        ejbCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Relations cannot be set in ejbCreate() - this is done in ejbPostCreate()
        return null;
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.isEmpty()), #end#foreach ($rel in $relations)${transform.getRelationTargetType($rel)} $rel.target.roleName#if($velocityCount != $relations.size()), #end#end)
           throws javax.ejb.CreateException
    {
        // Call postCreate method for the CMP attributes
        ejbPostCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Set the CMR relations
#foreach ($rel in $relations)
        set${str.upperCaseFirstLetter($rel.target.roleName)}($rel.target.roleName);
#end
    }
#end
#end
    // ---------------- accessor methods for bean references ---------------

#foreach ( $dep in $class.dependencies )
#set ($viewtype = "")
#if ($transform.getStereotype($dep.id) == "EntityRef" || $transform.getStereotype($dep.id) == "ServiceRef")
#set ($referencedClass = $transform.findClassById($dep.targetType))
#set ($viewtype = $transform.findTagValue($referencedClass.taggedValues, "@andromda.ejb.viewType"))
#if ($viewtype == "")
#set ($viewtype = $transform.getEjbRefViewType($referencedClass))
#end
#if ($viewtype == "local")
#set ($homeInterfaceName = "${referencedClass.name}LocalHome")
#set ($fqHomeInterfaceName = "${transform.findFullyQualifiedName($referencedClass)}LocalHome")
    /**
     * Get the local home interface of the ${referencedClass.name} bean.
     * The home interface is obtained from the initial context 
     * by looking up the bean reference name.
     * @return local home interface for ${referencedClass.name}. 
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            // Local homes shouldn't be narrowed, as there is no RMI involved.
            ${fqHomeInterfaceName} home = 
                (${fqHomeInterfaceName}) initialContext.lookup("java:comp/env/ejb/${transform.replace($transform.findFullyQualifiedName($referencedClass),'.','/')}");
            return home;
        } finally {
            initialContext.close();
        }
    }
#end
#if ($viewtype == "remote")
#set ($homeInterfaceName = "${referencedClass.name}Home")
#set ($fqHomeInterfaceName = "${transform.findFullyQualifiedName($referencedClass)}Home")
    /**
     * Get the remote home interface of the ${referencedClass.name} bean.
     * The home interface is obtained from the initial context 
     * by looking up the bean reference name.
     * @return remote home interface for ${referencedClass.name}. Lookup using bean ref name.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            Object home = 
                 initialContext.lookup("java:/comp/env/ejb/${transform.replace($transform.findFullyQualifiedName($referencedClass),'.','/')}");
            return ($fqHomeInterfaceName) 
                   javax.rmi.PortableRemoteObject.narrow(home, 
                   ${fqHomeInterfaceName}.class);
        } finally {
            initialContext.close();
        }
    }
#end
#end
#if ($transform.getStereotype($dep.id) == "ResourceRef")
#set ($referencedClass = $transform.findClassById($dep.targetType))
#set ($resClassName = "${transform.findFullyQualifiedName($referencedClass)}")
#set ($resName = $dep.name)
#if (!$resName || $resName == "")
#set ($resName = $referencedClass.name)
#end
    /**
     * Get the ${resName} resource. 
     * The resource is obtained by looking up
     * <code>java:/comp/env/resource/$resName</code> in JNDI
     * @return the ${resName} resource
     */
    protected static ${resClassName} get${str.upperCaseFirstLetter($resName)}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            Object resource = 
                 initialContext.lookup("java:/comp/env/resource/$resName");
            return ($resClassName) resource;
        } finally {
            initialContext.close();
        }
    }
#end
#end

    // ---------------- getter and setter for value objects ---------------

## Getter for value objects are only generated for concrete EJBs to avoid 
## signature and instantiation problems. Setters can be safely generated
## even for abstract entities
#if (!$class.isAbstract())    
    /** 
     * Get a value object for this entity. 
     * @ejb.interface-method     
     * @ejb.transaction type="Required"
     * @return a new value object.
     */
    public ${entityname}Value getValueObject() {
#set ($attr = $transform.filterByVisibility($transform.getAllInstanceAttributes($class.id), "public"))
        return new ${entityname}Value(
#foreach($att in $attr)
               get${str.upperCaseFirstLetter($att.name)}()#if($velocityCount != $attr.size()),
               #end#end);
    }
#end
    
    /**
     * Set the CMP fields from the attributes interface. Primary key fields are ignored.
     * @ejb.interface-method     
     * @ejb.transaction type="Required"
     * @param value the value object
     */
    public void setValueObject(${entityname}Attr value) {
#set ($superclass = $transform.getGeneralization($class.id))
## call the super class method if there is a super class and it is an entity
#if($superclass && $transform.getStereotype($superclass) == "Entity")
        super.setValueObject(value);
#end
## Set attributes that are defined in this class, but exclude PK fields.
#set ($pkfieldNames = $transform.findPkFieldNames($class))
#foreach ($att in $transform.getInstanceAttributes($class))
#if (!$pkfieldNames.contains($att.name))
#if ($transform.getVisibility($att) == "public")
#set ($AttName = ${str.upperCaseFirstLetter($att.name)})
        set$AttName(value.get$AttName());
#end
#end
#end
    }
}
