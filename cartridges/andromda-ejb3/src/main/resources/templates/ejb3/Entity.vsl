// license-header java merge-point
/* Autogenerated by AndroMDA (Entity.vsl) - do not edit */
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end

#set ($identifier = $entity.identifiers.iterator().next())
/**
 * Autogenerated POJO EJB3 super class for ${entity.entityName} containing the 
 * bulk of the entity implementation.
 *
 * This is an abstract super class and autogenerated by AndroMDA using the EJB3
 * cartridge.
 *
 * DO NOT MODIFY this class.
 *
$entity.getDocumentation(" * ")
 *
 */

#if ($entity.embeddableSuperclass)
@javax.persistence.EmbeddableSuperclass#if ($entity.accessType)(access = javax.persistence.AccessType.${entity.accessType})#end

#else
@javax.persistence.Entity#if ($entity.accessType)(access = javax.persistence.AccessType.${entity.accessType})#end

@javax.persistence.EntityListener(${entity.fullyQualifiedEntityListenerName}.class)
@javax.persistence.Table(name = "${entity.tableName}")
#**##if ($entity.requiresSpecializationMapping)
@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.${entity.inheritanceStrategy}, discriminatorType = javax.persistence.DiscriminatorType.${entity.discriminatorType}#if ($entity.discriminatorValue), discriminatorValue = "${entity.discriminatorValue}"#end)
#*  *##if ($entity.inheritanceSingleTable || $entity.inheritanceJoined)
@javax.persistence.DiscriminatorColumn(name = "${entity.discriminatorColumn}"#if ($entity.discriminatorColumnDefinition), columnDefinition = "${entity.discriminatorColumnDefinition}"#end#if ($entity.discriminatorLength > 0), length = ${entity.discriminatorLength}#end)
#*  *##end
#**##elseif ($entity.requiresGeneralizationMapping)
@javax.persistence.Inheritance#if ($entity.discriminatorValue)(discriminatorValue = "${entity.discriminatorValue}")#end

#**##end
#end
public abstract class ${entity.entityName}
#if($entity.generalization)
    extends ${entity.generalization.fullyQualifiedName}
#end
    implements java.io.Serializable
{

    private static final long serialVersionUID = ${entity.serialVersionUID}L;

    // ----------- constant definitions -------------
#foreach($constant in $entity.getConstants(true))
    @javax.persistence.Transient
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#end

    // ----------- attribute definitions ------------
#foreach ( $attribute in $entity.attributes)
    private $attribute.type.fullyQualifiedName $attribute.name;
#end

    // --------- relationship definitions -----------
#foreach ($associationEnd in $entity.allEntityRelations)
#**##if ($associationEnd.one2Many || $associationEnd.many2Many)
    private $associationEnd.relationType<${associationEnd.otherEnd.type.name}> ${associationEnd.otherEnd.name};
#**##else
    private $associationEnd.relationType ${associationEnd.otherEnd.name};
#**##end
#end

    // --------------- constructors -----------------
    
    public ${entity.entityName}()
    { 
        // default null constructor
    }
    
## Autogenerate a constructor implementation with all attributes.
#set ($allAttributes = $transform.filterByVisibility($entity.allInstanceAttributes, "public"))
#set ($inheritedAttributes = $transform.filterByVisibility($entity.inheritedInstanceAttributes, "public"))
#set ($instanceAttributes = $transform.filterByVisibility($entity.instanceAttributes, "public"))

    /**
     * Implementation for the main constructor with all POJO attributes.
     * This method sets all POJO fields defined in this class to the
     * values provided by the parameters.
     *
#foreach($attribute in $transform.filterUpdatableAttributes($allAttributes))
     * @param $attribute.name Value for the ${attribute.name} property
#end
     */
    public ${entity.entityName}($transform.getAttributesAsList($allAttributes, true, true)) 
    {
#if(!$inheritedAttributes.empty)
        super($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
#foreach ($attribute in $transform.filterUpdatableAttributes($instanceAttributes))
        ${attribute.setterName}(${attribute.name});
#end
    }

#set ($relations = $entity.allEntityRelations)
#if (!$relations.empty)
#**##if ($entity.syntheticCreateMethodAllowed)
    /**
     * Constructor with all POJO attribute values and CMR relations.
#*  *##foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the $attribute.name property
#*  *##end
#*  *##foreach ($relation in $relations)
     * @param $relation.otherEnd.name Value for the ${relation.otherEnd.name} relation role
#*  *##end
     */
    public ${entity.entityName}($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.empty), #end#foreach ($relation in $relations)#if ($relation.one2Many || $relation.many2Many)${relation.relationType}<${relation.otherEnd.type.name}> $relation.otherEnd.name#else${relation.relationType} $relation.otherEnd.name#end#if($velocityCount != $relations.size()), #end#end)
    {
        // Call suitable class constructor
        this($transform.getAttributesAsList($allAttributes, false, true));
        
        // Set the CMR relations
#*  *##foreach ($relation in $relations)
        ${relation.otherEnd.setterName}($relation.otherEnd.name);
#*  *##end
    }
#**##end
#end

#foreach ($operation in $entity.getCreateMethods(true))
#**##set ($opArguments = $transform.getArgumentsAsList(${operation.argumentNames}))
    /**
     * Explicitly defined constuctor with specified args list.
$operation.getDocumentation("    * ")
#**##foreach($attribute in $opArguments)
     * @param $attribute Value for the $attribute property
#**##end
     */
    public ${entity.entityName}(${operation.typedArgumentList}) 
    {
#**##foreach($attribute in $opArguments)
        this.${attribute} = $attribute;
#**##end
    }
#end

    // --------- accessors for constants ----------
#foreach($constant in $entity.getConstants(true))
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
     *
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }
#end

    // -------- attribute getters/setters ----------
#foreach ($attribute in $entity.attributes)
#**##set ($visibility = $attribute.visibility)
    /**
     * Get the $attribute.name property.
$attribute.getDocumentation("     * ")
     * @return $attribute.type.fullyQualifiedName The value of ${attribute.name}
     */
#**##if ($attribute.identifier)
#*  *##if ($attribute.sequenceGeneratorType || $attribute.tableGeneratorType)
    @javax.persistence.TableGenerator(name = "${attribute.generatorName}"#if ($attribute.sequenceGeneratorType), sequenceName = "${attribute.generatorSourceName}"#elseif ($attribute.tableGeneratorType), tableName = "${attribute.generatorSourceName}"#end,#if ($attribute.tableGeneratorType) pkColumnValue = "${attribute.generatorPkColumnValue}",#end#if ($attribute.sequenceGeneratorType) initialValue = ${attribute.generatorInitialValue},#end allocationSize = ${attribute.generatorAllocationSize})
#*  *##end
    @javax.persistence.Id(generate = javax.persistence.GeneratorType.${attribute.generatorType}#if ($attribute.sequenceGeneratorType || $attribute.tableGeneratorType), generator = "${attribute.generatorName}"#end)
#**##end
#**##if ($attribute.version)
    @javax.persistence.Version
#**##end
#**##if ($attribute.transient)
    @javax.persistence.Transient
#**##end
#**##if ($attribute.lobType)
## LOB type is specified - also sepcify FetchType if set to EAGER since default fetch type for LOB annotation is LAZY
    @javax.persistence.Lob(type = javax.persistence.LobType.${attribute.lobType}#if ($attribute.eager), fetch = javax.persistence.FetchType.EAGER#end)
#**##end
#**##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#**##end
    @javax.persistence.Column(name = "${attribute.columnName}"#if ($attribute.unique), unique = ${attribute.unique}#end#if (!$attribute.columnNullable), nullable = ${attribute.columnNullable}#end#if ($attribute.columnLength), length = ${attribute.columnLength}#end#if ($attribute.columnDefinition), columnDefinition = "${attribute.columnDefinition}"#end#if ($attribute.columnPrecision), precision = ${attribute.columnPrecision}#end#if ($attribute.columnScale), scale = ${attribute.columnScale}#end)
## Only add the fetch type property for LAZY hints - default is EAGER
#**##if ($attribute.lazy)
    @javax.persistence.Basic(fetch = javax.persistence.FetchType.LAZY)
#**##end
    public $attribute.type.fullyQualifiedName ${attribute.getterName}()
    {
        return $attribute.name;
    }

## Allow only if not a version attribute since they are set by the container - No setter method is made available
#**##if (!$attribute.version)
    /**
     * Set the $attribute.name property.
     * @param value the new value
     */
    public void ${attribute.setterName}($attribute.type.fullyQualifiedName value)
    {
        this.${attribute.name} = value;
    }
#**##end
    
#end

    // ------------- relations ------------------

#foreach ($associationEnd in $entity.allEntityRelations)
#**##set ($target = $associationEnd.otherEnd)
#**##if($target.navigable)
#*  *##if ($associationEnd.many2One)
##
## MANY TO ONE RELATIONSHIP
##
## Default fetch type: EAGER
##
    /**
     * Get the ${target.name}
     * @return $associationEnd.relationType
     */
#*    *##set ($argExists = false)
    @javax.persistence.ManyToOne(#if (!$target.optional)optional = false#set ($argExists = true)#end#if ($target.cascadeType)#if ($argExists), #end#**#cascade = {${target.cascadeType}}#set ($argExists = true)#end#if ($target.lazy)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.LAZY#end)
    @javax.persistence.JoinColumn(name = "$stringUtils.upperCase(${target.name})"#if ($associationEnd.columnDefinition), columnDefinition = "${associationEnd.columnDefinition}"#end)
#*    *##if ($associationEnd.association.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${$associationEnd.association.transactionType})
#*    *##end
    public $associationEnd.relationType ${target.getterName}()
    {
        return this.${target.name};
    }

#*    *##if(!$target.readOnly)
   /**
    * Set the ${target.name}
    * @param ${target.name}
    */
    public void ${target.setterName}($associationEnd.relationType ${target.name})
    {
        this.${target.name} = ${target.name};
    }
#*    *##end
#*  *##elseif ($associationEnd.one2Many)
##
## ONE TO MANY RELATIONSHIP
##
## Include the mappedBy element for bidirection relationships ONLY
## Default fetch type: LAZY
## If orderBy element is not specified, container assumes PK ordering
##
    /**
     * Get the ${target.name} Collection
     * @return $associationEnd.relationType
     */
#*    *##set ($argExists = false)
    @javax.persistence.OneToMany(#if ($target.cascadeType)cascade = {${target.cascadeType}}#set ($argExists = true)#end#if ($associationEnd.navigable)#if ($argExists) ,#end#**#mappedBy="${associationEnd.name}"#set ($argExists = true)#end#if ($target.eager)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.EAGER#end)
#*    *##if ($associationEnd.association.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${$associationEnd.association.transactionType})
#*    *##end
#*    *##if ($target.hasTaggedValue("@andromda.persistence.orderBy"))
#*      *##if ($stringUtils.isNotEmpty(${target.orderByClause}))
    @javax.persistence.OrderBy("${target.orderByClause}")
#*      *##else
    @javax.persistence.OrderBy
#*      *##end
#*    *##end
    public $associationEnd.relationType<${target.type.name}> ${target.getterName}()
    {
        return this.${target.name};
    }
    
    /**
     * Set the ${target.name}
     * @param ${target.name}
     */
    public void ${target.setterName} (${associationEnd.relationType}<${target.type.name}> ${target.name})
    {
        this.${target.name} = ${target.name};
    }
#*  *##elseif ($associationEnd.one2One)
##
## ONE TO ONE RELATIONSHIP
##
## Default fetch type: EAGER
##
    /**
     * Get the ${target.name}
     * @return $associationEnd.relationType
     */
#*    *##set ($argExists = false)
    @javax.persistence.OneToOne(#if (!$target.optional)optional = false#set ($argExists = true)#end#if ($target.cascadeType)#if ($argExists), #end#**#cascade = {${target.cascadeType}}#set ($argExists = true)#end#if(!$associationEnd.owning)#if ($argExists), #end#**#mappedBy="${associationEnd.name}"#set ($argExists = true)#end#if ($target.lazy)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.LAZY#end)
#*    *##if($associationEnd.owning)
    @javax.persistence.JoinColumn(name = "$stringUtils.upperCase(${target.name})"#if ($associationEnd.columnDefinition), columnDefinition = "${associationEnd.columnDefinition}"#end)
#*    *##end
#*    *##if ($associationEnd.association.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${$associationEnd.association.transactionType})
#*    *##end
    public $associationEnd.relationType ${target.getterName}()
    {
        return this.${target.name};
    }

#*    *##if(!$target.readOnly)
   /**
    * Set the ${target.name}
    * @param ${target.name}
    */
    public void ${target.setterName}($associationEnd.relationType ${target.name})
    {
        this.${target.name} = ${target.name};
    }
#*    *##end
#*  *##elseif ($associationEnd.many2Many)
##
## MANY TO MANY RELATIONSHIP
##
## Default fetch type: LAZY
##
    /**
     * Get the ${target.name} Collection
     * @return $associationEnd.relationType
     */
#*    *##set ($argExists = false)
    @javax.persistence.ManyToMany(#if ($target.cascadeType)cascade = {${target.cascadeType}}#set ($argExists = true)#end#if ($target.eager)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.EAGER#end)
## Use Aggregation and Composition to determine owning side
#*    *##if(($associationEnd.owning) && ${associationEnd.association.tableName})
    @javax.persistence.JoinTable(table = @javax.persistence.Table(name = "${associationEnd.association.tableName}"))
#*    *##end
#*    *##if ($associationEnd.association.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${$associationEnd.association.transactionType})
#*    *##end
#*    *##if ($target.hasTaggedValue("@andromda.persistence.orderBy"))
#*      *##if ($stringUtils.isNotEmpty(${target.orderByClause}))
    @javax.persistence.OrderBy("${target.orderByClause}")
#*      *##else
    @javax.persistence.OrderBy
#*      *##end
#*    *##end
    public $associationEnd.relationType<${target.type.name}> ${target.getterName}()
    {
        return this.${target.name};
    }
    
    /**
     * Set the ${target.name}
     * @param ${target.name}
     */
    public void ${target.setterName} (${associationEnd.relationType}<${target.type.name}> ${target.name})
    {
        this.${target.name} = ${target.name};
    }
#*  *##end
#**##end
#end

    // ----------------- finder method ------------------
    
#foreach ($finder in $entity.getQueryOperations(true))
#**##set ($returnType = $finder.returnType.fullyQualifiedName)
#**##set ($parameterList = $finder.typedArgumentList)
#**##if ($finder.arguments.empty)
#*  *##set ($parameters = "javax.persistence.EntityManager em")
#**##else
#*  *##set ($parameters = "javax.persistence.EntityManager em, ${parameterList}")
#**##end
    /**
$finder.getDocumentation("     * ")
     *
     * Finder method for ${entity.name} entity using a query.
     * @param em javax.persistence.EntityManager
#**##foreach ($parameter in $finder.arguments)
     * @param $parameter.type.fullyQualifiedName ${parameter.name}
#**##end
     * @return $returnType
     */
    $finder.visibility static $returnType#if ($returnType == "java.util.Collection" || $returnType == "java.util.List")<${entity.name}>#end ${finder.name}($parameters)
    {
        javax.persistence.Query query = em.createQuery("$finder.query");
#**##foreach ($parameter in $finder.arguments)
#*  *##set ($index = $velocityCount - 1)
#*  *##if ($parameter.firstResult)
        query.setFirstResult(${parameter.name});
#*  *##elseif ($parameter.maxResults)
        query.setMaxResults(${parameter.name});
#*  *##else
#*    *##if ($finder.useNamedParameters)
        query.setParameter("${parameter.name}",#if ($parameter.type.primitive) new ${parameter.type.wrapperName}(${parameter.name})#else ${parameter.name}#end#if ($parameter.temporalType), javax.persistence.TemporalType.${parameter.temporalType}#end);
#*    *##else
        query.setParameter(${index},#if ($parameter.type.primitive) new ${parameter.type.wrapperName}(${parameter.name})#else ${parameter.name}#end#if ($parameter.temporalType), javax.persistence.TemporalType.${parameter.temporalType}#end);
#*    *##end
#*  *##end
#**##end
#**##if ($finder.returnType.primitive)
        return (($finder.returnType.wrapperName)query.getSingleResult()).${returnType}Value();
#**##elseif (!$finder.returnType.collectionType)
        return ($returnType)query.getSingleResult();
#**##else
        return query.getResultList();
#**##end
    }
    
#end## finder operations
    // --------------- business methods -----------------
    
#foreach ($operation in $entity.businessOperations)
#**##set ($signature = $operation.signature)
#**##set ($visibility = $operation.visibility.toString())
    /**
$operation.getDocumentation("     * ")
     */
#**##if ($operation.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${operation.transactionType})
#**##end
#**##set ($returnType = $operation.returnType.fullyQualifiedName)
#**##if ($operation.exceptionsPresent)
    $visibility abstract $returnType $signature
        throws $operation.exceptionList;
#**##else
    $visibility abstract $returnType $signature;
#**##end
#end
}