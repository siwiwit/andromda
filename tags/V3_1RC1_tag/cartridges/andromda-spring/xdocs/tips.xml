<?xml version="1.0" encoding="iso-8859-1"?>

<document>

    <properties>
        <author email="wouter@andromda.org">Wouter Zoons</author>
        <title>AndroMDA - Spring - Tips</title>
    </properties>

    <body>

        <section name="Tips for using the AndroMDA Spring cartridge">
            <p>
                This section provides you with some pointers that might prove helpful when using AndroMDA with
                the Spring cartridge.
            </p>
        </section>

        <section name="Exceptions">
            <p>
                It's not needed to model exceptions for all the services you model, the Spring cartridge will
                generate them automatically for you. That way you don't need to keep writing
                <code>try/catch</code> blocks in the <code>handleXXX</code> methods in the service implementation
                classes, just throw any error, it will be handled for you.
            </p>
            <p>
                So basically this snippet is a good example of an implementation of a service operation, there is
                no need to catch any exception and rethrow it:
<source language="java"><![CDATA[
protected PersonDetails handleGet(Long id) throws Exception
{
    return (PersonDetails)getPersonDao().load(PersonDao.TRANSFORM_PERSONDETAILS, id);
}
]]></source>
            </p>
        </section>

        <section name="Running without EJBs">
            <p class="highlight">
                If you have told <code>andromdapp:generate</code> to generate a WAR-only project (i.e. for deployment
                in Tomcat) EJBs will be disabled by default and you won't need to worry about this section.
            </p>
            <p>
                With the change of a single line it is possible to enable or disable the usage of stateless session
                EJBs, simply put the <![CDATA[<session-ejbs>]]> outlet in comment, like this 
                (this is done in <code>mda/conf/andromda.xml</code>):
<source language="xml"><![CDATA[
<namespace name="spring">
    <properties>
        ...
        <!--
            <property name="session-ejbs">${maven.andromda.core.generated.dir}</property>
        -->
        ...
    </properties>
</namespace>
]]></source>
            </p>
        </section>
        <section name="Beware of lazy loading!">
            <p>
                  Unless an Association is composition-modeled, all associations
                  collections are made <a href="profile.html#@andromda_hibernate_lazy">lazy</a> by
                  default. While this is very nice to avoid retrieving the whole
                  database on each query, you should be aware that each
                  time you invoke a method on a <a href="howto3.html">Spring Service</a>, a Hibernate
                  Session is opened at the beginning and closed at the end of the call.
            </p>
            <p>
                  The consequence of this is that every persistent object that was retrieved in the body
                  of a Service method is unable to retrieve its associations lazily outside this very call.
            </p>
            <p>
                  For example: if the <code>user</code> parameter in the following code was obtained as the result
                  of calling a Spring service method, and that user has a lazy <code>group</code> association,
                  and the following is another Spring Service method,
                  it would raise a <code>net.sf.hibernate.LazyInitializationException</code>:
            </p>
<source language="java"><![CDATA[
protected boolean doSomethingWithUserGroups(User user) throws Exception
{
    ...
    java.util.Collection userGroups = user.getGroups ();
    java.util.Iterator everyUserGroup = userGroups.iterator(); // this call would generate the exception
    ...
}
]]></source>
        </section>
        <section name="Connecting to JBoss with Remote EJBs">
            <p>
                When connecting to a remote EJB wrapped Spring service deployed in JBoss, its possible you'll get 
                the following exception:
<source>
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'transactionManager' defined in c
lass path resource [applicationContext-dataSource.xml]: Initialization of bean failed; nested exception is org.springfra
mework.transaction.TransactionSystemException: JTA UserTransaction is not available at JNDI location [java:comp/UserTran
saction]; nested exception is javax.naming.NameNotFoundException: UserTransaction not bound
org.springframework.transaction.TransactionSystemException: JTA UserTransaction is not available at JNDI location [java:
comp/UserTransaction]; nested exception is javax.naming.NameNotFoundException: UserTransaction not bound
javax.naming.NameNotFoundException: UserTransaction not bound
        at org.jnp.server.NamingServer.getBinding(NamingServer.java:491)
        at org.jnp.server.NamingServer.getBinding(NamingServer.java:499)
        at org.jnp.server.NamingServer.getObject(NamingServer.java:505)
        at org.jnp.server.NamingServer.lookup(NamingServer.java:278)    
</source>
                To get around this, place the following 2 properties in your <em>spring</em> namespace:
                <source language="xml"><![CDATA[
                    
<namespace name="spring">
    ...
    <property name="userTransactionName">null</property>
    <property name="transactionManagerName">java:/TransactionManager</property>    
    ...  
</namespace>              
                ]]></source>
            </p>
        </section>
    </body>
</document>
