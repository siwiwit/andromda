<?xml version="1.0"?>

<document>

  <properties>
    <author email="mbohlen@mbohlen.de">Matthias Bohlen</author>
    <author email="chdbrandon@yahoo.com">Chad Brandon</author>
    <title>The cartridge system of AndroMDA</title>
    <gennews>no</gennews>
  </properties>

  <body>

    <section name="The cartridge system of AndroMDA">
 
      <p class="std">
			The <strong>primary plugin</strong> of the AndroMDA framework, <em>cartridges</em>
			provide the ability to process model elements that have specified <code>stereotypes</code>
			(i.e. <code><![CDATA[<<Entity>>]]></code>, <code><![CDATA[<<Enumeration>>]]></code>, etc.).  
			Cartridges process these model elements using template files defined within the cartridge
			<a href="descriptor-schema.html">descriptor</a>.
      </p>
      <p class="std">
          This page describes the internal structure of an AndroMDA cartridge.
          After reading it, you will probably find it very easy to write your
          own cartridge or customize an existing cartridge for your needs.
      </p>

      <h2>Using a cartridge</h2>
      <p class="std">
          If you want to use existing cartridge(s) for generation 
          (i.e. the <a href="../andromda-bpm4struts-cartridge/index.html">BPM4Struts Cartridge</a>, 
          etc.), simply place the cartridges on your classpath; using the 
          <a href="../maven-andromda-plugin/index.html">AndromMDA Maven Plugin</a> 
          this is VERY simple, you just add the AndroMDA maven plugin and cartridge(s)
          as dependencies to your project.xml file and then run the plugin goal 
          <em>andromda:run</em>, that's it!
          <source><![CDATA[
<dependencies>
    ...
	<dependency>
		<groupId>andromda</groupId>
		<artifactId>maven-andromda-plugin</artifactId>
		<version>3.0</version>
		<type>plugin</type>
	</dependency>
	<dependency>
		<groupId>andromda-cartridges</groupId>
		<artifactId>andromda-bpm4struts-cartridge</artifactId>
		<version>3.0</version>
	</dependency>
	<dependency>
		<groupId>andromda-hibernate</groupId>
		<artifactId>andromda-bpm4struts-cartridge</artifactId>
		<version>3.0</version>
	</dependency>
	...
</dependencies>
]]></source>
      </p>

      <h2>Inside a cartridge</h2>
      <p class="std">
          An AndroMDA cartridge is a "thing" (directory or jar file)
          on the classpath that consists of several items:
      </p>
      <table border="1" cellpadding="4" class="std">
        <tr>
          <td valign="top"><b>File</b></td>
          <td valign="top"><b>Contents</b></td>
          <td align="center" valign="top" ><b>Required</b></td>
        </tr>
		<tr>
			<td valign="top">
				<code>src/java/**/*</code>
			</td>
			<td valign="top">Source code for classes that are invoked at 
				runtime of the code generated by that cartridge.
			</td>
			<td align="center" valign="top">
				No.
			</td>			
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap">
				<code>src/META-INF/andromda-cartridge.xml</code>
			</td>
			<td valign="top"> 
				Declarative cartridge descriptor (see below). 
			</td>
			<td align="center" valign="top"> 
				Yes. 
			</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap">
				<code>src/META-INF/andromda-metafacades.xml</code>
			</td>
			<td valign="top"> 
				Metafacades descriptor. This is used to specify
				facades for the underlying metamodel (UML 1.4, etc.).
			</td>
			<td align="center" valign="top"> 
				No. 
			</td>
		</tr>
        <tr>
			<td valign="top">
				<code>src/templates/*.vsl</code>
			</td>
          <td valign="top">
			  Templates that tell the cartridge how format the generated code.
		  </td>
          <td align="center" valign="top">Yes.</td>
        </tr>
      </table>
      <p class="std">
          All items except the descriptor and the templates are optional. If
          you want to see a complete cartridge, have a look inside the 
          <em>andromda-bpm4struts-cartridge</em> cartridge.
      </p>

      <h2>The cartridge descriptor</h2>

      <p class="std">
        The descriptor allows AndroMDA to find this cartridge on the classpath automatically.
        The core also uses this descriptor to find out the capabilities of a cartridge: the
        supported stereotypes, the outlets and, templates and the variable name
        to place the model element(s) into in the template. The cartridge descriptor <b>must</b>
        reside in the <code>META-INF</code> subdirectory and <b>must</b> be named
        <code>andromda-cartridge.xml</code>.
      </p>

      <p class="std">
        Let's have a look at part of a typical cartridge descriptor:
      </p>
      <source><![CDATA[
<cartridge name="ejb">

    <templateEngine>
        <!-- library of macros used in template engine -->
       <macrolibrary name="templates/EJB.vm" />
    </templateEngine>

    <!-- define the template objects that are made availble to the template -->
    <templateObject name="str" className="org.andromda.core.common.StringUtilsHelper"/>
    <templateObject name="transform" className="org.andromda.cartridges.ejb.EJBScriptHelper"/>
    
    <!-- the official template definitions -->
    <template
        sheet="templates/EntityBean.vsl"
        outputPattern="{0}/{1}Bean.java"
        outlet="entity-beans"
        overWrite="true">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>    
        </modelElements>
    </template>

    <template
        sheet="templates/EntityLocalIntf.vsl"
        outputPattern="{0}/{1}.java"
        outlet="entity-beans"
        overWrite="true">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>    
        </modelElements>
    </template>

    <template
        sheet="templates/EntityHome.vsl"
        outputPattern="{0}/{1}LocalHome.java"
        outlet="entity-beans"
        overWrite="true">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>    
        </modelElements>
    </template>
    
    <template
        sheet="templates/EntityBeanImpl.vsl"
        outputPattern="{0}/{1}BeanImpl.java"
        outlet="entity-impls"
        overWrite="false">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>  
        </modelElements>  
    </template>

	...
    
</cartridge>
      ]]></source>
      <p class="std">
          Note the usage
          of the <code>"{0}/"</code> pattern. This will cause the target
          java file to be generated into <code>"com/mycompany/test"</code>
          if it was in the package <code>"com.mycompany.test"</code>.
      </p>

      <h3>&lt;cartridge&gt;</h3>
      <p class="std">
        The <code>&lt;cartridge&gt;</code> tag is used to delimit
        the cartridge descriptor and give a name to the cartridge.
      </p>

      <h3>&lt;property&gt;</h3>
      <p class="std">
        The <code>&lt;property&gt;</code> tag is used to define a set of
        key-value pairs for a cartridge. These properties define which
        aspects of the target application's architecture are generated
        by this cartridge. In the future, these properties will be used
        for automatic aspect-to-cartridge mappings (not yet implemented).
        Example:
      </p>
      <blockquote><pre>
&lt;property name="persistence" value="hibernate" /&gt;
      </pre></blockquote>

      <h3>&lt;stereotype&gt;</h3>
      <p class="std">
        This tag is used to declare the stereotypes that should trigger
        the core module to use this cartridge. Example: The EJB cartridge
        declares the <code>&lt;&lt;Entity&gt;&gt;</code> stereotype because entities may be represented
        by entity beans.
      </p>

      <h3>&lt;outlet&gt;</h3>
      <p class="std">
        This tag is used to declare a logical outlet name that can later
        be mapped to a physical directory (using the <code>&lt;andromda&gt;</code>
        task in your build.xml script.
      </p>
      <p class="std">
        <code>&lt;template&gt;</code> tags use outlet names to declare
        which outlet will be used for the source code output files
        caused by a particular template.
      </p>

      <h3>&lt;template&gt;</h3>
      <p class="std">
        The <code>&lt;template&gt;</code> tag is used to describe
        the set of templates that will be used to generate source code.
      </p>
      <p class="std">
        The attributes of this tag are:
      </p>
      <table border="1" cellpadding="2" cellspacing="0" class="std">
        <tr>
          <td valign="top" ><b>Attribute</b></td>
          <td valign="top" ><b>Description</b></td>
          <td align="center" valign="top" ><b>Required</b></td>
        </tr>
        <tr>
          <td valign="top" >stereotype</td>
          <td valign="top" >Specifies the name of the stereotype that should
                                       trigger the use of this template.
          </td>
          <td align="center" >Yes.</td>
        </tr>
        <tr>
          <td valign="top" >sheet</td>
          <td valign="top" >Specifies the path (relative to the cartridge root)
                                       for a template (*.vsl) file to use for code generation.
          </td>
          <td align="center" >Yes.</td>
        </tr>
        <tr>
          <td valign="top" >outputPattern</td>
          <td valign="top" >Specifies a pattern in
                                       <a href="http://java.sun.com/j2se/1.4/docs/api/java/text/MessageFormat.html">
                                         java.text.MessageFormat</a>
                                       syntax.
                                       You can use this pattern to tell AndroMDA how to construct
                                       output file names. The pattern can consist of any ordinary
                                       printable characters as well as some predefined placeholders
                                       for things that AndroMDA already knows about: <br />
                                       <code>{0}</code> stands for the package directory of the class.<br />
                                       <code>{1}</code> stands for the class name.<br />
                                       <code>{2}</code> stands for the base part of the *.vsl file name.<br />
                                       <code>{3}</code> stands for the name of the stereotype.<br />
                                       See example above.
          </td>
          <td align="center" >Yes.</td>
        </tr>
        <tr>
          <td valign="top" >outlet</td>
          <td valign="top" >Specifies the logical name of the outlet
                                       where the cartridge will write the output files
                                       caused by this template.</td>
          <td valign="top" align="center" >Yes.</td>
        </tr>
        <tr>
          <td valign="top" >overWrite</td>
          <td valign="top" >Specifies whether the files already contained in <code>&lt;outlet&gt;</code>
                                       should be overwritten when AndroMDA runs a second time.
          </td>
          <td valign="top" align="center" >Yes.</td>
        </tr>
        <tr>
          <td valign="top" >generateEmptyFiles</td>
          <td valign="top" >Specifies whether files should be generated even if the template did not produce
          any output. This can be used by the cartridge developer to decide if a certain file should be generated
          based on the information in the model. <em>Note:</em> If this property is set to "false", the
          template produces no output, <code>overWrite</code> is set to "true", and an existing file is found
          (probably generated by a previous run), then this file is removed.
          </td>
          <td valign="top" align="center" >No, default is "true"</td>
        </tr>
        <tr>
          <td valign="top" >transformClassname</td>
          <td valign="top" >Specifies a name of a java class that can be used to help the code generation templates.
                                       In some cases the velocity scripting language is not enough for what you would like
                                       to do in your code generation template.  You can solve this problem by writing a
                                       java class to extend the $transform object in the template.  One way to write your
                                       own helper is to extend the class
                                       <a href="../javadoc/org/andromda/core/simpleuml/SimpleOOHelper.html">
                                         SimpleOOHelper
                                       </a>
          </td>
          <td valign="top" align="center" >No.</td>
        </tr>
      </table>

      <h3>Example</h3>
      <blockquote><pre>
&lt;template
    stereotype="Entity"
    sheet="templates/DatabaseScript.vsl"
    outputPattern="{1}.sql"
    outlet="database-scripts"
    overWrite="true"&gt;
&lt;/template&gt;
      </pre></blockquote>
      <p class="std">
          This could(!) generate SQL scripts for the entities in the model (if you
          wrote such a template!).
      </p>

    </section>

  </body>
</document>
