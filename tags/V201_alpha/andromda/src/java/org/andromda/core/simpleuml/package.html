<html>

<body>

<p>FOR DETAILS READ THE FULL PACKAGE DESCRIPTION - this package implements an extension to the UML v1.4 API
for performing querys and that mimics the UML2EJB SimpleOO API.</p>

<h3>The History</h3>

<p> The first step to understanding this package is to know something about the history of AndroMDA.  The predeccessor of
AndroMDA was UML2EJB. UML2EJB did not use UML 1.4 as the basis for its object models.  It used a meta-model that
was called SimpleOO that was completely unique to UML2EJB. The code generation templates that were written for
UML2EJB relied upon this SimpleOO schema to work. </p>

<h4>The Problem Statement</h4>

<p> When the transition from UML2EJB to AndroMDA occurred the project also transitioned from using 
the SimpleOO meta-model to using the UML v1.4 meta-model.  The benefit of this was that AndroMDA would
be able to utilize all of the modeling features of UML.   The problem with this was that all the existing 
UML2EJB code generation templates relied upon the SimpleOO meta model.  They would all now be broken.</p>
 
<p> The problem was how to introduce AndroMDA, and the UML v1.4 meta-model, without breaking the existing 
code generation templates? </p>

<h3>The Solution</h3>

<p> The solution that was used was to identify all the operations provided by the SimpleOO, and used 
by the existing code generation templates, that did not exist in the UML v1.4 API.  We then extended 
the UML v1.4 schema objects to include these operations. The resulting merger of those two schemas is 
what this package implements. <p>

<p> The solution sounds easy: just subclass the UML schema objects, and add the missing methods. It
turns out not to be as easy as it sounds because we it is the MDR repository that actually
controls the object creations. This means we have no way to substitute in our new extended
classes.</p>

<p> We solve this problem by creating what is called in Java a 'Dynamic Proxy'.  The proxy object
handles method calls in a special way.  All method calls for which it has an implementation it handles
itself.  All other method calles it delegates to another object.  In our case the Proxy handles all the
SimpleOO method calls and delegates the other method calls to the UML v 1.4 schema objects.</p>

<h3>The Implemenation</h3>

<p>There are essentially three types of objects in this package:</p>

<ul>
<li> interfaces prefixed with UML (such as UMLModel). These interfaces define the operations
that existed on the SimpleOO classes but are missing from the UML 1.4 schema objects.
<li> classes prefixed with P (such as PModelElement). These are the proxy objects.  These
object dynamically support at least two interfaces: one of the UML 1.4 interfaces 
(such as org.omg.uml.foundation.core.ModelElement) , and one 
of this packages UML intefaces (such as UMLModelElement).
<li> classes like the SimpleOOHelper which act as a facade over the rest of the UML v1.4
model. If one wants new funcationality the operations should be added to the SimpleOOHelper
and not to the proxies. The proxies might at some point be depreccated.
</ul>

<p>Take a look at the SimpleOOHelper implementation for examples of how to use
the proxy objects.</p>


</body>



</html>