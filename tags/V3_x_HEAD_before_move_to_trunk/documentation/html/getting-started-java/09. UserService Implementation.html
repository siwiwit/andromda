<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>UserService Implementation</title>
</head>
<body>
    <h2>UserService Implementation</h2>
    <!------------------------- Intro Text ------------------------->
    <p>
        In this section we will implement the <code>UserService</code> and make sure it
        passes the tests.
    </p>
    <!------------------------- Main Text ------------------------->
    <p>
        {mosimage}
        <!-- img src="Images/User.jpg" alt="User" / -->
    </p>
    <p>
        As discussed under <a href="/index.php?option=com_content&task=view&id=108&Itemid=89">
            Application Architecture</a>, the value object is a special packaging of attributes
        from one more more entities, with the purpose of shielding the entities from other
        tiers of the application and/or external applications. To implement the <code>getAllUsers()</code>
        method in <code>UserService</code>, we will now define a <code>User</code> entity.
        To keep things simple, we will do a straight one-to-one mapping of attributes in
        <code>UserVO</code> to the attributes in the <code>User</code> entity. The model
        of the <code>User</code> entity is shown on the right. Note that we have not explicitly
        modeled the <code>id</code> attribute -- all entities are assumed to have an <code>id</code>
        attribute of type <code>Long</code>. You need to model an <code>id</code> only if
        this default assumption is not true, i.e. your <code>id</code> attribute has a different
        name or type.
    </p>
    <p>
        Note that AndroMDA will map the <code>User</code> entity to a database table called
        <code>USER</code>. However <code>USER</code> happens to be a reserved word in several
        databases. So we will force AndroMDA to map this entity to a table called <code>USERS</code>.
        This exercise will also show you how to override AndroMDA's default code generation
        behavior.
    </p>
    <p>
        Now let us enter the <code>User</code> entity in the TimeTracker model. Please follow
        one of the links below to edit the model with the UML tool of your choice.
    </p>
    <ul>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=189&amp;Itemid=42"
            target="_blank">ArgoUML</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=136&amp;Itemid=42"
            target="_blank">MagicDraw 9.x</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=153&amp;Itemid=42"
            target="_blank">MagicDraw 15.5</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=161&amp;Itemid=42"
            target="_blank">RSM 6</a></li>
    </ul>
    <p>
        {mosimage}
        <!-- img src="Images/UserToUserVODependency.jpg" alt="User To UserVO Dependency" / -->
    </p>
    <p>
        Next we will add couple of dependency relationships to our model to tell AndroMDA
        about dependencies between some of the elements we have modeled. The first is the
        dependency from the <code>User</code> entity to the <code>UserVO</code>. This dependency
        is shown on the right and tells AndroMDA to generate conversion methods between
        <code>User</code> and <code>UserVO</code> objects. The conversion methods are generated
        in <code>UserDaoBase</code>, the data access object for the <code>User</code> entity.
        They take care of simple conversions, however if your value objects are complicated
        (for example, if they have attributes fetched from related entities), then you will
        have to override the default conversion methods to fill in the additional attributes.
        Anyway, our <code>UserVO</code> is simple enough that the default conversion methods
        work perfectly!
    </p>
    <p>
        Please follow one of the links below to enter this new dependency in the model.
    </p>
    <ul>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=190&amp;Itemid=42"
            target="_blank">ArgoUML</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=139&amp;Itemid=42"
            target="_blank">MagicDraw 9.x</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=154&amp;Itemid=42"
            target="_blank">MagicDraw 15.5</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=162&amp;Itemid=42"
            target="_blank">RSM 6</a></li>
    </ul>
    <p>
        Next add a dependency from <code>UserService</code> to the <code>User</code> entity.
        This dependency is shown below and tells AndroMDA to give <code>UserService</code>
        access to the <code>User</code> entity. From an implementation perspective, this
        injects a <code>UserDao</code> instance into <code>UserService</code>. As you may
        have guessed, <code>UserDao</code> is the data access object that allows its clients
        to read and write <code>User</code> entities from the database.
    </p>
    <table width="100%" border="0">
        <tbody>
            <tr>
                <!-- img src="Images/UserServiceToUserDependency.jpg" alt="UserService To User Dependency" / -->
                <td align="center" style="width: 100%">
                    {mosimage}</td>
            </tr>
        </tbody>
    </table>
    <p>
        Please follow one of the links below to enter this new dependency in the model.
    </p>
    <ul>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=191&amp;Itemid=42"
            target="_blank">ArgoUML</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=138&amp;Itemid=42"
            target="_blank">MagicDraw 9.x</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=155&amp;Itemid=42"
            target="_blank">MagicDraw 15.5</a></li>
        <li><a href="/index.php?option=com_content&amp;task=view&amp;id=163&amp;Itemid=42"
            target="_blank">RSM 6</a></li>
    </ul>
    <p>
        Now let's ask AndroMDA to generate code for the <code>User</code> entity:
    </p>
    <ol>
        <li>Execute the command <code>mvn install</code> in the Command Prompt. Note that the
            build will not succeed because the test will still fail, however the code generation
            part should succeed.</li>
    </ol>
    <p>
        Open the folder C:/timetracker/core/target/src/org/andromda/timetracker/domain in
        Windows Explorer. Note that there are 5 files generated in this folder as a result
        of creating the single <code>User</code> entity in the application model.
    </p>
    <ol>
        <li><strong>User.java:</strong> This is the primary class that implements the <code>
            User</code> entity. It contains the 3 attributes from the model along with their
            getters and setters. AndroMDA automatically adds an <code>id</code> attribute that
            represents the unique identifier for <code>User</code> instances in the database.
            In addition, AndroMDA generates <code>equals()</code> and <code>hashCode()</code>
            methods for the entity. Note that <code>User</code> is an abstract class - it cannot
            be instantiated. The <code>UserImpl</code> class described below, is a concrete
            class that extends <code>User</code>. It can be instantiated using the factory methods
            embedded in the <code>User</code> class.</li>
        <li><strong>UserImpl.java:</strong> As mentioned above <code>UserImpl</code> is a concrete
            extension of the <code>User</code> class. It is meant to be a container for any
            custom code that developers would like to add to the <code>User</code> entity.</li>
        <li><strong>UserDao.java:</strong> Data access objects for any entity are created as
            a trio of classes: an interface, an abstract base class and a concrete implementation.
            <code>UserDao</code> is the interface for the <code>User</code> data access object.
            It specifies CRUD methods for the DAO.</li>
        <li><strong>UserDaoBase.java:</strong> <code>UserDaoBase</code> implements all of the
            CRUD methods specified in the <code>UserDao</code> interface class.</li>
        <li><strong>User.hbm.xml:</strong> This is the Hibernate mapping file that maps the
            <code>User</code> entity to its relational representation in the database.</li>
    </ol>
    <p>
        Now open the folder C:/timetracker/core/src/main/java/org/andromda/timetracker/domain
        in Windows Explorer. Note that there is 1 additional file generated in this folder:
    </p>
    <ol>
        <li><strong>UserDaoImpl.java:</strong> <code>UserDaoImpl</code> is a concrete extension
            of the <code>UserDaoBase</code> class created in the target folder above. It is
            meant to be a container for any custom code that developers would like to add to
            the <code>User</code> data access object.</li>
    </ol>
    <p>
        Note that the <code>target</code> folder is intended for auto generated files only.
        None of the files in this folder should be modified by hand because code regeneration
        will wipe them out completely, thus deleting all your changes. It is also a best
        practice not to check this code into your source repository. Instead let your build
        script generate it on the fly.
    </p>
    <p>
        By now you must be wondering where to add your custom code. We already said above
        that developers can add custom code into <code>UserImpl.java</code> and <code>UserDaoImpl.java</code>.
        But why is <code>UserImpl.java</code> generated in the <code>target</code> folder
        then? Well, AndroMDA is pretty smart. You have given it no indication that you want
        to write custom code in <code>UserImpl.java</code>. As long as that is the case
        it will keep generating the <code>UserImpl.java</code> class in the target folder.
        However, as soon as you tell AndroMDA that you want to write some custom code in
        this class, it will generate the class in the <code>src</code> folder under the
        core project. Now you are free to modify the <code>UserImpl.java</code> class and
        add any code to it. AndroMDA will never overwrite files in the project <code>src</code>
        folder. They are auto-generated only once for your convenience.
    </p>
    <p>
        Talking about custom code, note that so far we have not written even a single line
        of custom code to implement the <code>UserService</code>! AndroMDA has done most
        of the work for us, e.g. creation of the <code>UserService</code>, <code>UserVO</code>,
        <code>UserDao</code>, Hibernate mapping file and so on. All that is really left
        is to fill in the "handle" method in <code>UserServiceImpl</code>. To do this, add
        the bold lines shown in the listing below to your <code>UserServiceImpl</code> class.
    </p>
    <pre>
// license-header java merge-point
/**
 * This is only generated once! It will never be overwritten.
 * You can (and have to!) safely modify it by hand.
 */
package org.andromda.timetracker.service;

<b>import java.util.Collection;</b>

<b>import org.andromda.timetracker.domain.UserDao;</b>
<b>import org.andromda.timetracker.vo.UserVO;</b>

/**
 * @see org.andromda.timetracker.service.UserService
 */
public class UserServiceImpl
    extends org.andromda.timetracker.service.UserServiceBase
{

    /**
     * @see org.andromda.timetracker.service.UserService#getAllUsers()
     */
    protected org.andromda.timetracker.vo.UserVO[] handleGetAllUsers()
        throws java.lang.Exception
    {
        <b>Collection userVOs = getUserDao().loadAll(UserDao.TRANSFORM_USERVO);</b>
        <b>return (UserVO[])userVOs.toArray(new UserVO[0]);</b>
    }
}
</pre>
    <p>
        Here we make a direct call to the <code>loadAll()</code> method in <code>UserDao</code>
        which is completely implemented in <code>UserDaoBase</code>. We supply the <code>UserDao.TRANSFORM_USERVO</code>
        parameter to the <code>loadAll()</code> method which asks the method to convert
        the <code>User</code> entities to <code>UserVO</code> objects before returning.
        We then convert the returned collection to an array as required by the method signature
        and return this array. That's it! You see how simple it was to implement this method,
        no need to write DAOs or convert database records to objects, AndroMDA takes care
        of all this for you.
    </p>
    <p>
        Well, we think that <code>UserService</code> is now completely implemented. Let's
        test it. Execute the command below to run <code>UserServiceTest</code>. Note that
        this time we do not execute <code>mvn install</code> because this command regenerates
        code and rebuilds the entire application. Since we have not made any model changes
        after the last build, it makes sense to just run the <code>test</code> target in
        the <code>core</code> project.
    </p>
    <pre>
C:\timetracker>mvn -f core/pom.xml test
...
...
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running Services Test
SQL Error: 1146, SQLState: 42S02
<b>Table 'timetracker.user' doesn't exist</b>
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 3.996 sec <<< FAILURE!

Results :
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 2 seconds
[INFO] Finished at: Wed Jun 28 16:32:02 EDT 2006
[INFO] Final Memory: 26M/53M
[INFO] ------------------------------------------------------------------------
    </pre>
    <p>
        Aha, we forgot to create our <code>user</code> table in the database. Follow the
        steps below to create this table, populate it with test data and then run the test
        again.</p>
    <ol>
        <li>Run the following command in the Command Prompt, asking AndroMDA to create our database
            schema:<br />
            <code>mvn -f core/pom.xml andromdapp:schema -Dtasks=create</code><br />
            Make sure you get a <code>BUILD SUCCESSFUL</code> message</li>
        <li>Open MySQL Query Browser. Login as timetracker. You should see the <code>user</code>
            table in the <code>timetracker</code> schema.</li>
        <li>Select File > New Script Tab and paste the following SQL script in the new tab.
            <pre>
insert into USERS (ID, USERNAME, FIRST_NAME, LAST_NAME)
    values (1, 'nbhatia',      'Naresh', 'Bhatia');
insert into USERS (ID, USERNAME, FIRST_NAME, LAST_NAME)
    values (2, 'lcoude',       'Louis',  'Coude');
insert into USERS (ID, USERNAME, FIRST_NAME, LAST_NAME)
    values (3, 'ecrutchfield', 'Eric',   'Crutchfield');
insert into USERS (ID, USERNAME, FIRST_NAME, LAST_NAME)
    values (4, 'cmicali',      'Chris',  'Micali');
            </pre>
        </li>
        <li>Click the Execute button on the top right.</li>
        <li>Now rerun the test:<br />
            <code>mvn -f core/pom.xml test</code><br />
            You will see that the test runs successfully - yeah! </li>
        <li>Open <code>C:\timetracker\core\timetracker-test.log</code> to see results logged
            by the test. You should see the usernames printed out at the end of this file:
            <pre>
16:59:28.362 INFO  - nbhatia
16:59:28.362 INFO  - lcoude
16:59:28.362 INFO  - ecrutchfield
16:59:28.362 INFO  - cmicali
            </pre>
        </li>
    </ol>
    <h3>What's Next?</h3>
    <p>
        Now that <code>UserService.getAllUsers()</code> method is working, let's try to
        use it from the front-end. Click the <em>Next</em> link below to implement the search
        criteria panel of the search screen, which needs to call this method.
    </p>
</body>
</html>
