#if ($umlUtils.shouldOutput($class))
// license-header java merge-point
//
/**
 * @author GENERATED CODE! Do not modify by hand!
 * 
 * TEMPLATE:     ValueObject.vsl in andromda-java-cartridge.
 * MODEL CLASS:  $class.validationName
 * METAFACADE:   org.andromda.metafacades.uml.ValueObject
#foreach ($stereotype in $class.stereotypes)
 * STEREOTYPE:   $stereotype.name
#end
 */
#if ($stringUtils.isNotBlank($class.packageName))
package $class.packageName;
#end

#if ($serializable)
import java.io.Serializable;
#end
#set ($XMLOutput=$XMLBindingAnnotations&&!$class.hasStereotype("NoXml"))
#if ($XMLOutput)
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
#if ($xmlAttributes)
import javax.xml.bind.annotation.XmlAttribute;
#end
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
#end
import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;

/**
$class.getDocumentation(" * ")
 */
#if ($XMLOutput)
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "$class.name", namespace="http://$javaUtils.reversePackage($class.packageName)/", 
#set ($size = $class.attributes.size() + $class.navigableConnectingEnds.size())
#set ($count = 1)
  propOrder = {
#foreach ($attribute in $class.attributes)
    "$attribute.name"#if ($count<$size),#end

#set ($count = $count+1)
#end
#foreach ($connectingEnd in $class.navigableConnectingEnds)
#set ($namespaceName="$javaUtils.reversePackage($connectingEnd.packageName)/")
    "$connectingEnd.name"#if ($count<$size),#end

#set ($count = $count+1)
#end
})
#if (!$cxfVersion.startsWith("2.0"))
#set ($specializations = $class.typeSpecializations)
#if (!$specializations.empty)
#set ($count=1)
// Referenced subclasses of $class.name
@javax.xml.bind.annotation.XmlSeeAlso({
#foreach ($specialization in $specializations)
    ${specialization.fullyQualifiedName}.class#if ($count<$specializations.size()), #end

#set ($count=$count+1)
#end
})
#end
#end
#end
public#if($class.abstract) abstract#end class $class.name
#if($class.generalization)
## Class should only extend another ValueObject, which already declares Serializable and Comparable
    extends $class.generalization.fullyQualifiedName
#elseif ($serializable)
    implements Serializable, Comparable#if($enableTemplating)<Object>#end
#else
    implements Comparable#if($enableTemplating)<Object>#end
#end

    {
#if ($serializable)
    /** The serial version UID of this class. Needed for serialization. */
    private static final long serialVersionUID = ${class.serialVersionUID}L;

#end
#if (!$class.attributes.empty)
    // Class attributes
#end
#foreach ($attribute in $class.attributes)
#if ($XMLOutput)
#set ($type=$stringUtils.substring($attribute.type.fullyQualifiedName, 0, 9))
## Primitive types and type wrappers will have empty package name
#set ($useAttributes = $xmlAttributes && !$attribute.many && $attribute.type.name!='Object' && ($stringUtils.isBlank($attribute.type.packageName) || $attribute.type.packageName.equals("java.lang") || $type.equals("java.util") || $type.equals("java.math") || $attribute.type.packageName.equals("PrimitiveTypes")))
#set ($namespaceName="$javaUtils.reversePackage($attribute.packageName)/")
#set ($type=$attribute.type.name)
#if ($useAttributes)
## defaultValue not supported in @XmlAttribute annotation - annoying
    @XmlAttribute(name = "$attribute.name"#if ($attribute.required), required=true#end)
#else
## Custom JAXB binding to use Date instead of XMLGregorianCalendar. Custom DateParser/printer class wraps CXF bindings
#if (($type.equals("DateTime") && $stringUtils.isNotBlank($XMLDateTimeAdapter)) || ($type.equals("Time") && $stringUtils.isNotBlank($XMLTimeAdapter))|| ($type.equals("Date") && $stringUtils.isNotBlank($XMLDateAdapter))|| ($type.equals("Integer") && $stringUtils.isNotBlank($XMLIntegerAdapter))|| ($type.equals("Decimal") && $stringUtils.isNotBlank($XMLDecimalAdapter)))
#set ($elementType=", type=${attribute.type.fullyQualifiedName}.class")
#else
#set ($elementType="")
#end
    @XmlElement(name = "$attribute.name"##No newline
#if ($type.equals("String"))
#if ($stringUtils.isNotBlank($attribute.defaultValue)), defaultValue=$attribute.defaultValue#end$elementType)
#elseif ($type.equals("Character") || $type.equals("char"))
#set ($default=$stringUtils.replace($attribute.defaultValue, "'", "\""))
#if ($stringUtils.isNotBlank($attribute.defaultValue)), defaultValue=$attribute.defaultValue#end$elementType)
#else
#if ($stringUtils.isNotBlank($attribute.defaultValue)), defaultValue="$attribute.defaultValue"#end$elementType)
#end
#end
## The default class generated by CXF wsdl2java
#if ($type.equals("DateTime") && $stringUtils.isNotBlank($XMLDateTimeAdapter))
    @javax.xml.bind.annotation.XmlSchemaType(name = "dateTime")
    @javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter(${XMLDateTimeAdapter}.class)
#elseif ($type.equals("Time") && $stringUtils.isNotBlank($XMLTimeAdapter))
    @javax.xml.bind.annotation.XmlSchemaType(name = "time")
    @javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter(${XMLTimeAdapter}.class)
#elseif ($type.equals("Date") && $stringUtils.isNotBlank($XMLDateAdapter))
    @javax.xml.bind.annotation.XmlSchemaType(name = "date")
    @javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter(${XMLDateAdapter}.class)
#elseif ($type.equals("Integer") && $stringUtils.isNotBlank($XMLIntegerAdapter))
    @javax.xml.bind.annotation.XmlSchemaType(name = "integer")
    @javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter(${XMLIntegerAdapter}.class)
#elseif ($type.equals("Decimal") && $stringUtils.isNotBlank($XMLDecimalAdapter))
    @javax.xml.bind.annotation.XmlSchemaType(name = "decimal")
    @javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter(${XMLDecimalAdapter}.class)
#end
#end
#set ($returnType = $attribute.getterSetterTypeName)
    protected $returnType $attribute.name#if ($attribute.defaultValuePresent) = ${attribute.defaultValue}#end;
#end
#if (!$class.navigableConnectingEnds.empty)
    // Class associationEnds
#end
#foreach ($connectingEnd in $class.navigableConnectingEnds)
#if ($XMLOutput)
    @XmlElement(name="$connectingEnd.name"#if(!$connectingEnd.packageName.equals($class.packageName)), namespace="http://$javaUtils.reversePackage($connectingEnd.packageName)/"#end##No newline
#if ($connectingEnd.required), required=true#end)
#end
    protected $connectingEnd.getterSetterTypeName $connectingEnd.name;
#end

##
##  default constructor
##
#if (!$class.requiredConstructorParameters.empty || $class.allRequiredConstructorParameters.size() > $class.requiredConstructorParameters.size())
    /** Default Constructor with no properties */
    public ${class.name}()
    {
#if($class.generalization)
        super();
#else
        // Documented empty block - avoid compiler warning - no super constructor
#end
    }

#end
##
##  constructor taking only required properties
##
#if ($class.allProperties.size() > $class.allRequiredConstructorParameters.size() && ($class.allRequiredConstructorParameters.size() != 1 || !$class.allRequiredConstructorParameters.get(0).getterSetterTypeName.equals($class.fullyQualifiedName)))
    /** 
     * Constructor taking only required properties 
#foreach ($property in $class.allRequiredConstructorParameters)
     * @param ${property.name}In $property.getterSetterTypeName#if ($stringUtils.isNotBlank(${property.documentation})) ${property.documentation}#end

#end
     */
    public ${class.name}(## no newline
#set ($comma = "")
#foreach ($property in $class.allRequiredConstructorParameters)
##set ($propertyType = ${conversionUtils.getFullName(${property.getterSetterTypeName})})
${comma}${property.getterSetterTypeName} ${property.name}In## no newline
#set ($comma = ", ")
#end
)
    {
#if($class.generalization)
        super(## no newline
#set ($comma = "")
#foreach ($property in $class.generalization.allRequiredConstructorParameters)
${comma}${property.name}In## no newline
#set ($comma = ", ")
#end
);
#elseif($class.allRequiredConstructorParameters.empty)
        // Documented empty block - avoid compiler warning - no super constructor
#end
#foreach ($property in $class.requiredConstructorParameters)
        this.${property.name} = ${property.name}In;
#end
    }

#end
##
##  constructor taking all properties
##
#if ($class.allProperties.size() != 1 || !$class.allProperties.get(0).getterSetterTypeName.equals($class.fullyQualifiedName))
    /** 
     * Constructor with all properties 
#foreach ($property in $class.allProperties)
     * @param ${property.name}In $property.getterSetterTypeName
#end
     */
    public ${class.name}(## no newline
#set ($comma = "")
#foreach ($property in $class.allProperties)
#set ($propertyType = $property.getterSetterTypeName)
${comma}$propertyType ${property.name}In## no newline
#set ($comma = ", ")
#end
)
    {
#if($class.generalization)
        super(## no newline
#set ($comma = "")
#foreach ($property in $class.generalization.allProperties)
${comma}${property.name}In## no newline
#set ($comma = ", ")
#end
);
#end
#foreach ($property in $class.properties)
        this.${property.name} = ${property.name}In;
#end
#if ($class.allProperties.empty)
        // documented empty block - avoid compiler warning
#end
    }

#end
    /**
     * Copies constructor from other $class.name
     *
     * @param otherBean Cannot be <code>null</code>
     * @throws NullPointerException if the argument is <code>null</code>
     */
    public ${class.name}($class.name otherBean)
    {
        super();
#foreach ($property in $class.allProperties)
        this.${property.name} = otherBean.${property.getterName}();
#end
    }

    /**
     * Copies all properties from the argument value object into this value object.
     * @param otherBean Cannot be <code>null</code>
     * @return this
     */
    public#if($generateChainedSetters) $class.name#else void#end copy($class.name otherBean)
    {
        if (otherBean != null)
        {
#foreach ($property in $class.allProperties)
            this.${property.setterName}(otherBean.${property.getterName}());
#end
#if ($class.allProperties.empty)
            // No attributes to copy...
#end
        }
#if($generateChainedSetters)
        return otherBean;
#end
    }

#foreach ($attribute in $class.attributes)
#set ($returnType = $attribute.getterSetterTypeName)

    /**
$attribute.getDocumentation("     * ")
     * Get the $attribute.name Attribute
     * @return $attribute.name $returnType
     */
    public $returnType ${attribute.getterName}()
    {
#if ($attribute.many && !$attribute.type.name.endsWith("[]"))
        if (this.${attribute.name} == null) 
        {
            this.${attribute.name} = new java.util.ArrayList#if($enableTemplating)<${attribute.type.fullyQualifiedName}>#end();
        }
#end
        return this.$attribute.name;
    }

#if ($attribute.booleanType && $generateIsBooleanGetters)
    /**
$attribute.getDocumentation("     * ")
     * Duplicates getBoolean method, for use as Jaxb2 compatible object
     * Get the $attribute.name Attribute
     * @return $attribute.name $returnType
     */
    public $returnType get$stringUtils.capitalize(${attribute.name})()
    {
        return this.$attribute.name;
    }

#end
#if (!$attribute.readOnly)
## - always have as public, having read-only causes too many issues when attempting to 
##   use in other cartridges
    /**
$attribute.getDocumentation("     * ")
     * @param ${attribute.name}In $returnType
#if($generateChainedSetters&&!$XMLOutput)
     * @return this ${class.name}
#end
     */
## XMLOutput does not allow return values from the setter method
    public#if($generateChainedSetters&&!$XMLOutput) ${class.name}#else void#end ${attribute.setterName}($returnType ${attribute.name}In)
    {
        this.${attribute.name} = ${attribute.name}In;
#if($generateChainedSetters&&!$XMLOutput)
        return this;
#end
    }

#end
#end
## Generate the relation methods.
#foreach ($connectingEnd in $class.navigableConnectingEnds)

    /**
     * Get the $connectingEnd.name Association
#if ($connectingEnd.many)
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the object.
#end
     * @return this.${connectingEnd.name} $connectingEnd.getterSetterTypeName
$connectingEnd.getDocumentation("     * ")
     */
    public $connectingEnd.getterSetterTypeName ${connectingEnd.getterName}()
    {
## XMLBindings assume nillable is never declared, List must be empty instead of null
#if ($connectingEnd.many && !$connectingEnd.getterSetterTypeName.endsWith("[]"))
        if (this.${connectingEnd.name} == null) 
        {
            this.${connectingEnd.name} = new java.util.ArrayList#if($enableTemplating)<${connectingEnd.type.fullyQualifiedName}>#end();
        }
#end
        return this.${connectingEnd.name};
    }

## - always have as public, having read-only causes too many issues when attempting to 
##   use in other cartridges
    /**
     * Sets the $connectingEnd.name
     * @param ${connectingEnd.name}In $connectingEnd.getterSetterTypeName
#if($generateChainedSetters)
     * @return this ${class.name}
#end
     */
    public#if($generateChainedSetters) ${class.name}#else void#end ${connectingEnd.setterName}($connectingEnd.getterSetterTypeName ${connectingEnd.name}In)
    {
        this.${connectingEnd.name} = ${connectingEnd.name}In;
#if($generateChainedSetters)
        return this;
#end
    }

#end
    /**
     * @param object to compare this object against
     * @return boolean if equal
     * @see Object#equals(Object)
     */
#if ($enableAnnotations)
    @Override
#end
    public boolean equals(Object object) 
    {
        if (object==null || !(object instanceof ${class.fullyQualifiedName}))
        {
             return false;
        }
#if (!$class.allProperties.empty)
        ${class.fullyQualifiedName} rhs = (${class.fullyQualifiedName}) object;
#end
        return new EqualsBuilder().appendSuper(super.equals(object))
#foreach($attr in $class.allProperties)
            .append(this.${attr.getterName}(), rhs.${attr.getterName}())
#end
            .isEquals();
    }

    /**
     * @param object to compare this object against
     * @return int if equal
     * @see Comparable#compareTo(Object)
     */
#if ($enableAnnotations && $class.generalization)
    @Override
#end
    public int compareTo(Object object)
    {
        if (object==null || !(object instanceof ${class.fullyQualifiedName}))
        {
            return -1;
        }
#if (!$class.allProperties.empty)
        ${class.fullyQualifiedName} myClass = (${class.fullyQualifiedName}) object;
#end
        return new CompareToBuilder()
#foreach($attr in $class.allProperties)
            .append(this.${attr.getterName}(), myClass.${attr.getterName}())
#end
            .toComparison();
    }

    /**
     * @return int hashCode value
     * @see Object#hashCode()
     */
#if ($enableAnnotations)
    @Override
#end
    public int hashCode()
    {
        return new HashCodeBuilder(1249046965, -82296885).appendSuper(super.hashCode())
#foreach($attr in $class.getAttributes(true))
            .append(this.${attr.getterName}())
#end
#foreach($associationEnd in $class.associationEnds)
#set ($target = $associationEnd.otherEnd)
#if ($target.navigable)
## Do not append one of the two ends if bidirectional navigation. Comment out 1 end of 1:*, or end with lower alphabetical name. 
#if (($associationEnd.many.compareTo($target.many)<0) || ($associationEnd.many.equals($target.many)) && $associationEnd.type.fullyQualifiedName.compareTo($target.type.fullyQualifiedName)<1)
            //Commented out to avoid commons-lang-2.4 recursion StackOverflowError: https://issues.apache.org/jira/browse/LANG-456
            //.append(this.${target.getterName}())
#else
            .append(this.${target.getterName}())
#end
#end
#end
            .toHashCode();
    }

    /**
     * @return String representation of object
     * @see Object#toString()
     */
#if ($enableAnnotations)
    @Override
#end
    public String toString()
    {
        return new ToStringBuilder(this)
##foreach($attr in $class.getAttributes(true))
#foreach($attr in $class.allProperties)
            .append("${attr.name}", this.${attr.getterName}())
#end
            .toString();
    }

##
##      equality methods
##
## only render the macro in case there are properties to include
#if (!$class.properties.empty && $generateEqualPropertiesMethod)
    /**
     * Compares the properties of this instance to the properties of the argument. This method will return
     * {@code false} as soon as it detects that the argument is {@code null} or not of the same type as
     * (or a sub-type of) this instance's type.
     *
     * <p/>For array, collection or map properties the comparison will be done one level deep, in other words:
     * the elements will be compared using the {@code equals()} operation.
     *
     * <p/>Note that two properties will be considered equal when both values are {@code null}.
     *
     * @param thatObject the object containing the properties to compare against this instance
     * @return this method will return {@code true} in case the argument has the same type as this class, or is a
     *      sub-type of this class and all properties as found on this class have equal values when queried on that
     *      argument instance; in all other cases this method will return {@code false}
     */
#if ($enableAnnotations && $class.generalization)
    @Override
#end
    public boolean equalProperties(Object thatObject)
    {
        if (thatObject == null || !this.getClass().isAssignableFrom(thatObject.getClass()))
        {
            return false;
        }

        final ${class.fullyQualifiedName} that = (${class.fullyQualifiedName})thatObject;

#if ($class.generalization)
        return super.equalProperties(that)
#set ($operator = "&& ")
#else
        return
#set ($operator = "")
#end
#foreach ($property in $class.properties)
## no identifiers and constants, the 'constant' feature is defined in NmsEntity (= read-only and static)
#if (!$property.constant && !$property.identifier)
            ${operator}equal(this.${property.getterName}(), that.${property.getterName}())
#set ($operator = "&& ")
#end
#end
        ;
    }

#if (!$class.generalization)
    /**
     * This is a convenient helper method which is able to detect whether or not two values are equal. Two values
     * are equal when they are both {@code null}, are arrays of the same length with equal elements or are
     * equal objects (this includes {@link java.util.Collection} and {@link java.util.Map} instances).
     *
     * <p/>Note that for array, collection or map instances the comparison runs one level deep.
     *
     * @param first the first object to compare, may be {@code null}
     * @param second the second object to compare, may be {@code null}
     * @return this method will return {@code true} in case both objects are equal as explained above;
     *      in all other cases this method will return {@code false}
     */
    protected static boolean equal(Object first, Object second)
    {
        final boolean equal;

        if (first == null)
        {
            equal = second == null;
        }
        else if (first.getClass().isArray() && (second != null) && second.getClass().isArray())
        {
            equal = java.util.Arrays.equals((Object[])first, (Object[])second);
        }
        else // note that the following also covers java.util.Collection and java.util.Map
        {
            equal = first.equals(second);
        }

        return equal;
    }

#end
#end
    // ${class.fullyQualifiedName} value-object java merge-point
}
#end