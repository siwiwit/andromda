##
## Set global invariants
##
#set ($stateMachine = $transform.getStateMachine($class))
#set ($initialState = $transform.getInitialState($stateMachine))
#set ($controllerClass = $transform.getControllerClass($class))
#set ($controllerClassName = $transform.toJavaClassName($controllerClass))
#set ($controllerFormName = $transform.toJavaClassName($transform.getControllerForm($class)))
#if (!$controllerFormName)## If there is no form, use the default one
#set ($controllerFormName = "ActionForm")
#end
#set ($className = "${controllerClassName}Abstract")
#set ($packageName = $transform.getPackageName($controllerClass))
##
## This small macro will handle the processing of the argument transition.
## Depending on this transition's target it will rendered different code:
##
## A guarded decision point
##   there is a method for each of these nodes, it will be called here
##
## ActionState & FinalState
##    it will render the action forward from the mapping for this target
##
## ObjectFlowState
##    there is a method for each object flow state, it will be called here
##
## Please note that any merge points are simply skipped, they do not add
## any specific logic.
##
#macro ( processTransition $transition $indent )
#set ($target = $transform.dynamicHelper.skipMergePoints($transition).target)
#if ($transform.dynamicHelper.isGuardedDecisionPoint($target))
${indent}return $transform.toJavaMethodName($target)(mapping, form, request, response);
#elseif ($transform.dynamicHelper.isActionState($target) || $transform.dynamicHelper.isFinalState($target))
${indent}return mapping.findForward("$transform.toForwardName($target)");
#elseif ($transform.dynamicHelper.isObjectFlowState($target))
#set ($objectFlowStateName = $transform.toJavaClassName($target))
#set ($objectFlowStateState = $transform.getObjectFlowStateState($target))
${indent}return set$objectFlowStateName$transform.toJavaClassName($objectFlowStateState)(mapping, form, request, response);
#else
// illegal modelelement : $target.name ($target)
#end
#end
##
## Package declaration and imports
##
package $packageName;

import org.apache.struts.actions.DispatchAction;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

##
## Set collections from which methods will be rendered, we convert them to sets
## because we don't want to render doubles (just to make sure)
##
#set ($actionStates = $transform.toSet($transform.dynamicHelper.getActionStates($stateMachine)))
#set ($decisionPoints = $transform.toSet($transform.dynamicHelper.getDecisionPoints($stateMachine)))
#set ($objectFlowStates = $transform.toSet($transform.dynamicHelper.getObjectFlowStates($stateMachine)))
#set ($guardNames = $transform.toSet($transform.getGuardNames($stateMachine)))
#set ($guardedTransitions = $transform.toSet($transform.dynamicHelper.getGuardedTransitions($stateMachine)))
##
## Start of the class declaration, notice how it extends DispatchAction, not Action
##
public abstract class ${className} extends DispatchAction
{
##
## Global constants used by the decision making processes, please note how their values
## are hashcodes, while they do not need to be unique for each object of the same type we know they
## are unique for String instances that represent the same text.
##
#foreach ($guardName in $guardNames)
#set ($fieldName = $transform.toFinalMemberName($guardName))
#set ($fieldValue = $fieldName.hashCode())
    protected final int $fieldName = $fieldValue;
#end

##
## Since there is only one initial state (with only one outgoing transition we will make the unspecified method
## call the first state vertex.
##
    public final ActionForward unspecified(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
#processTransition ( $initialState.outgoing.iterator().next() "        " )
    }

##
## Each action state will have a corresponding dispatch method, depending on the outgoing
## transitions the macro is called.
##
## If there is only one transition this method is fairly simply, for more transitions
## there needs to be some logic to determine which one has been called. This is done by
## means of a request parameter (notice what happens if there is no custom form class,
## the transition value will be retrieved from the request context in that case).
##
## Each transition needs to have a trigger or this script will not work (hard requirement).
##
#foreach ($actionState in $actionStates)
#set ($methodName = $transform.toJavaMethodName($actionState))
#set ($methodNameImpl = "${methodName}Impl")
    public final ActionForward ${methodName}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
#set ($transition = $actionState.outgoing.iterator().next())## there MUST be only one outgoing transition
#set ($target = $transition.target)
#if ($transform.dynamicHelper.isTriggeredDecisionPoint($target))
#if ($controllerFormName.equals("ActionForm"))
        final String trigger = request.getParameter("trigger").toUpperCase();
#else
        final String trigger = (($controllerFormName)form).getTrigger().toUpperCase();
#end

#foreach ($transition in $target.outgoing)
        if ("$transform.toFinalMemberName($transition.trigger)".equals(trigger))
#processTransition( $transition "            " )

#end
        // if this happens the page specified an illegal trigger: application bug!
        return null;
#else
#processTransition( $transition "        " )
#end
    }

#end
##
## Each decision point in the use-case represents a node where the application flow can take a different
## road depending on a certain decision process that is part of the business.
##
#foreach ($decisionPoint in $decisionPoints)
#if ($transform.dynamicHelper.isGuardedDecisionPoint($decisionPoint))
#set ($methodName = $transform.toJavaMethodName($decisionPoint))
    private ActionForward $methodName(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
        final int ${methodName}Value = ${methodName}Impl(mapping, ($controllerFormName)form, request, response);

        switch(${methodName}Value)
        {
#foreach ($transition in $decisionPoint.outgoing)
            case $transform.toFinalMemberName($transition.guard) :
#processTransition ( $transition "                " )
#end
            default :
                return null;
        }
    }

    protected abstract int ${methodName}Impl(ActionMapping mapping, $controllerFormName form, HttpServletRequest request, HttpServletResponse response);

#end
#end
##
## For each object flow state we will have a method that implements the logic to actually
## set the specified object in the desired state, this is done in the implementation class.
##
#foreach ($objectFlowState in $objectFlowStates)
#set ($objectFlowStateName = $transform.toJavaClassName($objectFlowState))
#set ($objectFlowTypeName = $transform.toJavaClassName($objectFlowState.type))
#set ($objectFlowStateState = $transform.getObjectFlowStateState($objectFlowState))
#set ($methodName = "set$objectFlowStateName$transform.toJavaClassName($objectFlowStateState)")
    private final ActionForward ${methodName}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
        ${methodName}Impl(mapping, ($controllerFormName)form, request, response);
#processTransition( $objectFlowState.outgoing.iterator().next() "        " )
    }

    protected abstract void ${methodName}Impl(ActionMapping mapping, $controllerFormName form, HttpServletRequest request, HttpServletResponse response) throws Exception;

#end
}
