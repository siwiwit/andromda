<?xml version="1.0" encoding="ISO-8859-1" ?>

<!DOCTYPE struts-config PUBLIC
   "-//Apache Software Foundation//DTD Struts Configuration 1.1//EN"
   "http://jakarta.apache.org/struts/dtds/struts-config_1_1.dtd">

##
## Set global variables.
##
#set ($allUseCases = $transform.filterWithStereotypeName($transform.dynamicHelper.allUseCases, "FrontEndUseCase"))
#set ($allWorkflows = $transform.filterWithStereotypeName($transform.dynamicHelper.allUseCases, "FrontEndWorkflow"))
#set ($allControllerForms = $transform.filterWithStereotypeName($transform.staticHelper.allClasses, "FrontEndModel"))
#set ($allInitialStates = $transform.getAllInitialStates($allUseCases))
<struts-config>

##
## For each controller form we will declare a form bean.
##
   <form-beans>
#foreach ($formBeanControllerForm in $allControllerForms)
#set ($formBeanName = "$transform.toJavaMethodName($formBeanControllerForm)")
#set ($formBeanType = "$transform.toFullyQualifiedJavaClassName($formBeanControllerForm)")
      <form-bean name="$formBeanName" type="$formBeanType" />
#end
   </form-beans>

##
## Define the global exceptions here, they will be handled by the exception handlers
## that are configured here (if any)
##
   <global-exceptions>
#foreach ($exceptionHandler in $transform.getExceptionHandlers($class))
#set ($ehKey = $transform.staticHelper.findTagValue($exceptionHandler, "key"))
#set ($ehType = $transform.staticHelper.findTagValue($exceptionHandler, "type"))
      <exception
#if (!$ehKey)
         key="error.key"
#else
         key="$ehKey"
#end
#if (!$ehType)
         type="java.lang.Exception"
#else
         type="$ehType"
#end
         handler="$transform.toFullyQualifiedJavaClassName($exceptionHandler)"/>
#set ($ehKey = false)## reset these values for the next iteration
#set ($ehType = false)
#end
   </global-exceptions>

##
## We will take all workflow use-cases and their initial states will determine the global
## entry points of the application. For each workflow as well as for each individual use-case
## there will be exactly one global-forward declaration here.
##
## Notice how we redirect instead of forward to the use case, we explicitly want a new request
## object to be sent to the provided path
##
   <global-forwards>
      <!-- WORKFLOWS: these are the macro-level entry points of the application -->
#foreach ($workflow in $allWorkflows)
#set ($forwardName = $transform.toForwardName($workflow))
#set ($firstUseCase = $transform.getFirstFrontEndUseCase($workflow))
#set ($forwardPath = $transform.toJavaClassName($transform.getControllerClass($firstUseCase)))
      <forward name="$forwardName" path="/${forwardPath}.do" redirect="true"/>
#end
      <!-- USE-CASES: these are the micro-level entry points of the application -->
#foreach ($useCase in $allUseCases)
#set ($forwardName = $transform.toForwardName($useCase))
#set ($forwardPath = $transform.toJavaClassName($transform.getControllerClass($useCase)))
      <forward name="$forwardName" path="/${forwardPath}.do" redirect="true"/>
#end
      <!-- EXCEPTIONS: each exception handler forwards to an exception page -->
#foreach ($exceptionHandler in $transform.getExceptionHandlers($class))
      <forward name="$transform.toForwardName($exceptionHandler)" path="/$transform.getPackagePath($exceptionHandler)/${transform.toJavaClassName($exceptionHandler)}.jsp" redirect="false"/>
#end
   </global-forwards>

##
## Each use-case will be mapping onto an action controller, optionally associated to an action form.
## Final states of a use-cases will be connected to the next use-case as determined by the global workflows
## that contain these use-cases.
## Each state in the use-case's state machine will render a forward.
##
   <action-mappings>
#foreach ($useCase in $allUseCases)
#set ($stateMachine = $transform.getStateMachine($useCase))
#set ($actionMappingControllerClass = $transform.getControllerClass($useCase))
#set ($actionMappingPath = $transform.toJavaClassName($actionMappingControllerClass))
#set ($actionMappingType = $transform.toFullyQualifiedJavaClassName($actionMappingControllerClass))
#set ($actionMappingForm = $transform.getControllerForm($useCase))
#set ($actionMappingFormName = $transform.toJavaMethodName($actionMappingForm))
      <action
         path="/$actionMappingPath" type="$actionMappingType"
#if ($transform.getControllerForm($useCase))
         name="$actionMappingFormName"
#end
         scope="request" unknown="false" validate="true" parameter="target" >
#set ($actionStates = $transform.dynamicHelper.getActionStates($stateMachine))
#foreach ($actionState in $actionStates)
#set ($actionForwardName = $transform.toForwardName($actionState))
#set ($actionForwardPath = $transform.toFullyQualifiedWebFileName($actionState))
##
## Notice how we forward instead of redirect to the next action, this allows us to reuse the form that
## is in the request scope. This is interesting when an object flow state sets up some form properties
## that we want to use in the next page.
##
         <forward name="$actionForwardName" path="/${actionForwardPath}.jsp" redirect="false" />
#end
#set ($finalStates = $transform.dynamicHelper.getFinalStates($stateMachine))
#foreach ($finalState in $finalStates)
#set ($nextUseCase = $transform.findNextUseCaseInWorkflow($useCase, $finalState.name))
#if ($nextUseCase == false)## nothing happens here
#else
#set ($actionForwardName = $transform.toForwardName($finalState))
#set ($actionForwardPath = $transform.toJavaClassName($transform.getControllerClass($nextUseCase)))
##
## Notice how we redirect instead of forward to the next use case, we explicitly want a new request
## object to be sent to the provided path
##
         <forward name="$actionForwardName" path="/${actionForwardPath}.do" redirect="false"/>
#set ($nextUseCase = false)
#end
#end
      </action>
#end
   </action-mappings>

   <!-- i18n messages go in 'application.properties' -->
   <message-resources parameter="application" null="false" />

   <plug-in className="org.apache.struts.tiles.TilesPlugin" >
      <set-property property="definitions-config" value="/WEB-INF/tiles-defs.xml" />
      <set-property property="moduleAware" value="true" />
   </plug-in>

</struts-config>


