#set ($generatedFile = "${class.fullFormBeanPath}.java")
##
##  CONSTANTS
##
#set ($formBeanClassName = $class.formBeanClassName)
#set ($fields = $class.formFields)
##
##  START TEMPLATE
##
package $class.packageName;

import java.io.Serializable;

import org.apache.struts.action.ActionMapping;
import org.apache.struts.validator.ValidatorForm;

import javax.servlet.http.HttpServletRequest;

/**
 * @struts.form
 *      name="$class.formBeanName"
 */
public class $formBeanClassName extends ValidatorForm implements Serializable
{
#set ($collectionPresent = false)
#set ($arrayPresent = false)
#foreach ($field in $fields)
#if ($field.type.collectionType)
#set ($collectionPresent = true)
#end
#if ($field.type.arrayType)
#set ($arrayPresent = true)
#end
    private $field.type.fullyQualifiedName $field.name;
#if ($field.date)
    private final java.text.DateFormat ${field.name}DateFormatter = new java.text.SimpleDateFormat("${field.dateFormat}");
#end
#if ($field.hasBackingList())
    private $field.backingListType $field.backingListName;
#end
#end

    public $formBeanClassName()
    {
#foreach ($field in $fields)
#if ($field.date)
#set ($lenient = !$field.strictDateFormat)
        ${field.name}DateFormatter.setLenient($lenient);
#end
#end
    }

#foreach ($field in $fields)
#set ($fieldType = $field.type.fullyQualifiedName)
#set ($fieldName = $field.name)
#if ($field.type.collectionType)
    public void ${field.setterName}($fieldType $fieldName)
    {
        this.$fieldName = $fieldName;
    }

    public $fieldType ${field.getterName}()
    {
        return this.${fieldName};
    }

    public void ${field.setterName}AsArray(Object[] $fieldName)
    {
        this.$fieldName = ($fieldName == null) ? null : java.util.Arrays.asList($fieldName);
    }

    public Object[] ${field.getterName}AsArray()
    {
        return ($fieldName == null) ? null : ${fieldName}.toArray();
    }
#elseif ($field.date)
    public void ${field.setterName}($fieldType $fieldName)
    {
        this.$fieldName = $fieldName;
    }

    public $fieldType ${field.getterName}()
    {
        return this.$fieldName;
    }

    public void ${field.setterName}AsString(String ${fieldName}AsString)
    {
        if (${fieldName}AsString == null || ${fieldName}AsString.trim().length()==0)
        {
            this.$fieldName = null;
        }
        else
        {
            try
            {
#if ($fieldType == "java.util.Date")
                this.$fieldName = ${fieldName}DateFormatter.parse(${fieldName}AsString);
#else
## this is an attempt to support descendants of java.util.Date, the class needs <init>(long)
                this.$fieldName = new ${fieldType}(${fieldName}DateFormatter.parse(${fieldName}AsString).getTime());
#end
            }
            catch(java.text.ParseException e)
            {
                throw new RuntimeException(e);
            }
        }
    }

    public String ${field.getterName}AsString()
    {
        return (${fieldName} == null) ? null : ${fieldName}DateFormatter.format($fieldName);
    }

    public java.text.DateFormat ${field.getterName}DateFormatter()
    {
        return this.${fieldName}DateFormatter;
    }
#else
    public void ${field.setterName}($fieldType $fieldName)
    {
        this.$fieldName = $fieldName;
    }

    public $fieldType ${field.getterName}()
    {
        return this.$fieldName;
    }
#end

#if ($field.hasBackingList())
#set ($backingListName = $field.backingListName)
#set ($backingListMethod = $str.upperCaseFirstLetter($backingListName))
    public void set${backingListMethod}($field.backingListType $backingListName)
    {
        this.$backingListName = $backingListName;
    }

    public $field.backingListType get${backingListMethod}()
    {
        return this.$backingListName;
    }

#end
#end
    public void reset(ActionMapping mapping, HttpServletRequest request)
    {
#foreach ($field in $fields)
#if ($field.mustReset())
        this.$field.name = $field.nullValue;
#end
#end
    }

#if ($fields.empty == false)
#set ($separator = '')
    public String toString()
    {
        final StringBuffer buffer = new StringBuffer().append('[');

#foreach ($field in $fields)
#if ($field.type.arrayType || $field.type.collectionType)
        buffer.append("${separator}${field.name}=");
        buffer.append(toString(this.${field.getterName}()));
#elseif ($field.date)
        buffer.append("${separator}${field.name}=");
        buffer.append(${field.getterName}AsString());
#else
        buffer.append("${separator}${field.name}=");
        buffer.append(String.valueOf(this.${field.getterName}()));
#end
#set ($separator = ',')
#if ($field.hasBackingList())
        buffer.append("${separator}${field.backingListName}=");
        buffer.append(toString(this.get${backingListMethod}()));
#end
#end

        return buffer.append(']').toString();
    }
#end

#if ($collectionPresent)
    private final static String toString(java.util.Collection objects)
    {
        return (objects==null) ? null : toString(objects.toArray());
    }

#end
#if ($arrayPresent || $collectionPresent)
    private final static String toString(Object[] objects)
    {
        if (objects == null)
        {
            return null;
        }
        else
        {
            final StringBuffer buffer = new StringBuffer('[');
            String prefix = "";
            for (int i=0; i<objects.length; i++)
            {
                buffer.append(prefix);
                buffer.append(objects[i]);
                prefix = ",";
            }
            return buffer.append(']').toString();
        }
    }
#end

    public void clean()
    {
#foreach ($field in $fields)
#if ($field.type.primitiveType)
#if ($field.type.fullyQualifiedName == "boolean")
        this.$field.name = false;
#else
        this.$field.name = 0;
#end
#else
        this.$field.name = null;
#end
#if ($field.hasBackingList())
        this.$field.backingListName = null;
#end
#end
    }

}
