#if ($umlUtils.shouldOutput($service))
<?xml version="1.0" encoding="UTF-8"?>
##<bindings jxb:version=#if ($cxfVersion.startsWith("2.0"))"2.0"#else"2.1"#end
<bindings jxb:extensionBindingPrefixes="xjc"
    wsdlLocation="../${service.name}.wsdl"
    xmlns="http://java.sun.com/xml/ns/jaxws"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
    xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
    xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
    xmlns:jaxws="http://java.sun.com/xml/ns/jaxws"
    targetNamespace="http://java.sun.com/xml/ns/jaxws"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/jaxws/wsdl_customizationschema_2_0.xsd">
    <!-- Generated by andromda-webservice cartridge (cxf/jaxb_bindings.xml.vsl) on $webServiceUtils.date DO NOT EDIT! -->
    <!-- Disable wrapped operation inputs/outputs: Allows unwrapped methods in service implementation -->
    <!-- WSDL operations are still wrapped in request/response -->
    <!-- Change the Endpoint Interface class name from the default <Service>.java to <Service>SEI.java -->
## Using a variable for single quote is ugly, but it's the easiest way to provide those literals inside quoted strings
#set ($q="'")
#set ($namespace="http://$webServiceUtils.reversePackage($service.packageName)#if($addNamespaceBackslash)/#end")
    <bindings node="wsdl:definitions/wsdl:portType">
        <class name="${service.name}SEI"/>
    </bindings>
    <!-- Change the Endpoint Impl class name from the default <Service>PortTypeImpl.java to <Service>SEIClient -->
    <bindings node="wsdl:definitions/wsdl:service[@name = $q${service.name}$q]">
       <class name="${service.name}SEIClient"/>
    </bindings>
#foreach ($operation in $service.allowedOperations)
#foreach($exception in $operation.exceptions)
#if ($exception.associationEnds.empty)
##    <!-- $exception $exception.associationEnds $exception.associationEnds.size() -->
#set ($faultName=$exception.name.replace("Exception", "Fault"))
#else
#set ($faultName=$exception.associationEnds.get(0).otherEnd.type.name)
#end
    <!-- change the generated exception class package from default service package $service.packageName-->
    <bindings node="wsdl:definitions/wsdl:portType[@name=$q${service.name}$q]/wsdl:operation[@name=$q$operation.operationName$q]/wsdl:fault[@name=$q$faultName$q]">
#if (!$exception.packageName.equals($service.packageName))
        <package name="$exception.packageName"/>
#end
        <!-- Avoid Exception_Exception class in code created from wsdl Exception -->
        <class name="$exception.name"/>
    </bindings>
#end
#if (!$operation.operationName.equals($operation.name))
    <!-- change the generated exception class package from default service package $service.packageName-->
    <bindings node="wsdl:definitions/wsdl:portType[@name=$q${service.name}$q]/wsdl:operation[@name=$q$operation.operationName$q]">
        <!-- Implmented service operation name is different from exposed operation name -->
        <method name="$operation.name"/>
    </bindings>
#end
#end
    <!-- Change the xs:date databinding from the default XMLGregorianCalendar. Creates org.w3._2001.xmlschema.Adapter1 class -->
    <bindings node="wsdl:definitions/wsdl:types/xs:schema">
      <!-- Preserve underscore instead of using it as a word break in class/attribute/literal names -->
      <!-- Generate IsSet methods for optional elements -->
#if (!$cxfVersion.startsWith("2.0"))
      <!-- CXF 2.1 will not work unless jxb:extensionBindingPrefixes declared here. Causes an error with RAD 7.5. -->
#end
      <jxb:globalBindings#if (!$cxfVersion.startsWith("2.0")) jxb:extensionBindingPrefixes="xjc" xmlns:jxb="http://java.sun.com/xml/ns/jaxb" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"#end

      choiceContentProperty="false" collectionType="java.util.ArrayList" underscoreBinding="asWordSeparator"
        enableJavaNamingConventions="true" generateIsSetMethod="false"#if (!$cxfVersion.startsWith("2.0")) generateElementProperty="false"#end>
        <!-- Add implements Serializable with SerialVersionUID=1L-->
        <jxb:serializable uid="1"/>
#if ($cxfVersion.startsWith("2.0"))
        <!-- Bug in CXF 2.0.x: bindings are not allowing any xjc: elements. -->
#elseif ($simpleBindingMode && ($pluralizeAssociationEndNames || $pluralizeAttributeNames || $pluralizeParameterNames))
        <!-- XJC binding extension with simple binding, which prevents most object name collisions by assuming type is uniquely used -->
        <xjc:simple/>
#end
        <!-- CXF overridden XML Binding customizations. -->
        <!-- Customized bindings, in SharedJaxb2.jar. Allows null values, does not generate new Adapter classes -->
        <!-- Date=$webServiceUtils.getTypeMapping($service.languageMappings, "Date") Time=$webServiceUtils.getTypeMapping($service.languageMappings, "Time") DateTime=$webServiceUtils.getTypeMapping($service.languageMappings, "DateTime") Integer=$webServiceUtils.getTypeMapping($service.languageMappings, "Integer") Decimal=$webServiceUtils.getTypeMapping($service.languageMappings, "Decimal") -->
#if ($stringUtils.isNotBlank($XMLDateAdapter))
        <!-- Default XJC binding is XMLGregorianCalendar, must match java cartridge mapping -->
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Date").equals("java.util.Date"))
#if ($cxfVersion.startsWith("2.0"))
##        <!-- Requires custom developed datatype bindings -->
##        <jxb:javaType xmlType="xs:date" name="java.util.Date"
##                      parseMethod="com.xxx.DatatypeConverter.parseXsDate"
##                      printMethod="com.xxx.DatatypeConverter.printXsDate"/>
#else
        <xjc:javaType xmlType="xs:date" name="java.util.Date" adapter="$XMLDateAdapter"/>
#end
#elseif ($webServiceUtils.getTypeMapping($service.languageMappings, "Date").equals("java.util.Calendar"))
#if ($cxfVersion.startsWith("2.0"))
        <jxb:javaType xmlType="xs:date" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseDate"
                      printMethod="javax.xml.bind.DatatypeConverter.printDate"/>
#else
        <xjc:javaType xmlType="xs:date" name="java.util.Calendar" adapter="$XMLDateAdapter"/>
#end
#end
#end
#if ($stringUtils.isNotBlank($XMLTimeAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Time").equals("java.util.Date"))
#if ($cxfVersion.startsWith("2.0"))
##        <jxb:javaType xmlType="xs:time" name="java.util.Date"
##                      parseMethod="com.xxx.DatatypeConverter.parseXsTime"
##                      printMethod="com.xxx.DatatypeConverter.printXsTime"/>
#else
        <xjc:javaType xmlType="xs:time" name="java.util.Date" adapter="$XMLTimeAdapter"/>
#end
#elseif ($webServiceUtils.getTypeMapping($service.languageMappings, "Time").equals("java.util.Calendar"))
#if ($cxfVersion.startsWith("2.0"))
        <xjc:javaType xmlType="xs:time" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printTime"/>
#else
        <xjc:javaType xmlType="xs:time" name="java.util.Calendar" adapter="$XMLTimeAdapter"/>
#end
#end
#end
#if ($stringUtils.isNotBlank($XMLDateTimeAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "DateTime").equals("java.util.Date") || $webServiceUtils.getTypeMapping($service.languageMappings, "DateTime").equals("java.sql.Timestamp"))
#if ($cxfVersion.startsWith("2.0"))
##        <jxb:javaType xmlType="xs:dateTime" name="java.util.Date"
##                      parseMethod="com.xxx.DatatypeConverter.parseXsDateTime"
##                      printMethod="com.xxx.DatatypeConverter.printXsDateTime"/>
#else
        <xjc:javaType xmlType="xs:dateTime" name="java.util.Date" adapter="$XMLDateTimeAdapter"/>
#end
#elseif ($webServiceUtils.getTypeMapping($service.languageMappings, "DateTime").equals("java.util.Calendar"))
#if ($cxfVersion.startsWith("2.0"))
        <jxb:javaType xmlType="xs:dateTime" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseDateTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printDateTime"/>
#else
        <xjc:javaType xmlType="xs:dateTime" name="java.util.Calendar" adapter="$XMLDateTimeAdapter"/>
#end
##elseif ($webServiceUtils.getTypeMapping($service.languageMappings, "DateTime").equals("java.sql.Timestamp"))
##if ($cxfVersion.startsWith("2.0"))
##        <jxb:javaType xmlType="xs:dateTime" name="java.sql.Timestamp" adapter="$XMLTimestampAdapter"/-->
##                      parseMethod="com.xxx.DatatypeConverter.parseTimestamp"
##                      printMethod="com.xxx.DatatypeConverter.printTimestamp"/>
##else
##        <xjc:javaType xmlType="xs:dateTime" name="java.sql.Timestamp" adapter="$XMLTimestampAdapter"/>
##end
#end
#end
#if ($stringUtils.isNotBlank($XMLBooleanAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Boolean").equals("Boolean") || $webServiceUtils.getTypeMapping($service.languageMappings, "Boolean").equals("java.lang.Boolean"))
        <!-- Each boolean attribute with required=false must be bound to Boolean, instead of globally -->
#if ($cxfVersion.startsWith("2.0"))
        <!--xjc:javaType xmlType="xs:boolean" name="boolean"
                      parseMethod="com.xxx.DatatypeConverter.parseBoolean"
                      printMethod="com.xxx.DatatypeConverter.printBoolean"/-->
#else
        <!--xjc:javaType xmlType="xs:boolean" name="Boolean" adapter="$XMLBooleanAdapter"/-->
#end
#end
#else
        <!-- Bug in CXF 2.1.x: bindings are wrapped Boolean even if attribute is not optional. Use this to make everything wrapped Boolean.
        <xjc:javaType xmlType="xs:boolean" name="boolean" adapter="com.xxx.adapter.BooleanAdapter"/ -->
#end
#if ($stringUtils.isNotBlank($XMLIntegerAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Integer").equals("Integer") || $webServiceUtils.getTypeMapping($service.languageMappings, "Integer").equals("java.lang.Integer"))
        <!-- Default XJC binding is BigInteger, must match java cartridge mapping -->
#if ($cxfVersion.startsWith("2.0"))
##        <xjc:javaType xmlType="xs:integer" name="Integer"
##                      parseMethod="com.xxx.DatatypeConverter.parseInteger"
##                      printMethod="com.xxx.DatatypeConverter.printInteger"/>
#else
        <xjc:javaType xmlType="xs:integer" name="Integer" adapter="$XMLIntegerAdapter"/>
#end
#end
#end
#if ($stringUtils.isNotBlank($XMLDecimalAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Decimal").equals("Decimal") || $webServiceUtils.getTypeMapping($service.languageMappings, "Decimal").equals("java.lang.Decimal"))
        <!-- Default XJC binding is BigInteger, must match java cartridge mapping -->
#if ($cxfVersion.startsWith("2.0"))
##        <xjc:javaType xmlType="xs:decimal" name="Decimal"
##                      parseMethod="com.xxx.DatatypeConverter.parseDecimal"
##                      printMethod="com.xxx.DatatypeConverter.printDecimal"/>
#else
        <xjc:javaType xmlType="xs:decimal" name="Decimal" adapter="$XMLDecimalAdapter"/>
#end
#end
#end
      </jxb:globalBindings>
    </bindings>
</bindings>
#end