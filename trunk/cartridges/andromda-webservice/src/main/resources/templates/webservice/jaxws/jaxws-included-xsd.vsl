#if ($umlUtils.shouldOutput($service))
<!-- Generated by andromda-webservice cartridge (jaxws/jaxws-included-xsd.vsl) on $webServiceUtils.date DO NOT EDIT! -->
##<!-- useAttributes=$useAttributes makeNillable=$makeNillable useArrayWrapper=$useArrayWrapper useEventLogger=$useEventLogger -->
#set ($schemaTypes = $service.typeMappingElements)
#set ($quote='"')
##foreach ($typeMapping in $schemaTypes)
##set ($type = $typeMapping)
##if ($typeMapping.type)
##set ($type = $typeMapping.type)
##end
##end
#set ($pkgs = $webServiceUtils.getPackages($service, $schemaTypes, $extensionInheritanceDisabled))
#foreach ($pkg in $pkgs)
#if ($pkg.fullyQualifiedName.equals($service.packageName) || !$importedXSD)
    <xs:schema attributeFormDefault="$pkg.attributeFormDefault.toLowerCase()" elementFormDefault="$pkg.elementFormDefault.toLowerCase()" version="1.0"
        targetNamespace="http://$webServiceUtils.reversePackage($pkg.fullyQualifiedName)/"
        jxb:version="2.1" jxb:extensionBindingPrefixes="xjc"
        xmlns:${service.namespacePrefix}="http://$webServiceUtils.reversePackage($pkg.fullyQualifiedName)/"
#set ($pkgRefs = $webServiceUtils.getPackageReferences($service, $schemaTypes, $pkg.fullyQualifiedName, $extensionInheritanceDisabled))
##<!-- $pkg $pkg.fullyQualifiedName $pkgRefs $pkgRefs.size() -->
#foreach ($pkgRef in $pkgRefs)
        xmlns:$webServiceUtils.getPkgAbbr($pkgRef)="http://$webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)/"
#end
        xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
        xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
        xmlns:xs="$xmlSchemaNamespace">
#foreach ($pkgRef in $pkgRefs)
        <xs:import namespace="http://$webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)/" xmlns="http://www.w3.org/2001/XMLSchema"#if($importedXSD)  schemaLocation="xsd/${webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)}.xsd"#end/>
#end
#if ($pkg.fullyQualifiedName.equals($service.packageName))
        <!-- Schema Types from service.allowedOperations -->
#foreach ($operation in $service.allowedOperations)
## Bare not possible if any parameters have minOccurs > 1 or default values
#set ($isMany=false)
#foreach ($parameter in $operation.arguments)
#if (!$useArrayWrapper && $parameter.many)
#set ($isMany=true)
#end
#end
#if ($defaultParameterStyle.equalsIgnoreCase("WRAPPED") || $isMany)
## RequestWrapper must be the same as the operation name, or else the java is Bare instead of wrapped
        <xs:element name="${operation.operationName}">
#if ($stringUtils.isNotBlank($operation.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
##    <!-- $operation.getDocumentation("", 64, false) $stringUtils.containsNone("<", '<') $stringUtils.containsNone($operation.getDocumentation("", 64, false), '<') !$stringUtils.containsNone($operation.getDocumentation("", 64, false), '<') $stringUtils.containsNone($operation.getDocumentation("", 64, false), "<") -->
#if (!$stringUtils.containsNone($operation.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$operation.getDocumentation("                ", 100, false)
#if (!$stringUtils.containsNone($operation.getDocumentation("", 64, false), "\"'&<>"))]]>#end
            </xs:documentation></xs:annotation>
#end
#if (!$operation.arguments.empty)
            <xs:complexType>
                <xs:sequence>
#foreach ($parameter in $operation.arguments)
##Check first if we have something like Enumeration, Classifier, not a WSDLType
#if (!$parameter.type.wSDLTypeMetaType)
#if ($parameter.type.packageName.equals($pkg.fullyQualifiedName))
#set ($pkgAbbr='impl')
#else
#set ($pkgAbbr=${webServiceUtils.getPkgAbbr($parameter.type.package)})
#end
#set ($type="$pkgAbbr:${parameter.type.name}")
#elseif ($parameter.type.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($parameter.type.packageName) || $parameter.type.schemaType.startsWith("xs:"))
#set ($type=$parameter.type.schemaType)
#else
#set ($type="${webServiceUtils.getPkgAbbr($parameter.type.package)}:$parameter.type.name")
#end
## Metafacade: Parameter.getUpper returns -1 for multiplicity *
#if (!$useArrayWrapper && ($parameter.upper>1 || $parameter.upper==-1))
#set ($isMany=true)
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($isMany=false)
#set ($maxOccurs='')
#end
##                    <!-- $parameter.name type=$parameter.type.fullyQualifiedName schemaType=$parameter.type.schemaType isMany=$isMany-->
## Determine if attribute/element is a simple schema type when it starts with xs:
##if (!$useAttributes || !$parameter.type.schemaType.startsWith("xs:") || $isMany)
#if ($parameter.defaultValuePresent)
#set ($default=$parameter.defaultValue.replaceAll('"', ''))
##set ($default='"$default"')
#set ($use = " minOccurs=${quote}0$quote default=$quote$default$quote")
#elseif (!$parameter.nillable)
#set ($use = ' minOccurs="1"')
#else
#set ($use = ' minOccurs="0"')
#end
## Parameter of type List should never be nillable, can still be empty size=0. Could cause interoperability problems.
#if ($parameter.many)
#set ($nillable = ' nillable="false"')
#else
#set ($nillable = "")
#end
## Use minOccurs instead of nillable
                    <xs:element name="$parameter.name" type="$type"${use}${maxOccurs}${nillable}>
#if ($stringUtils.isNotBlank($parameter.getDocumentation("", 9999, false)))
                        <xs:annotation>
                          <xs:documentation>
##    <!-- $stringUtils.containsNone($parameter.getDocumentation("", 64, false), '<') !$stringUtils.containsNone($parameter.getDocumentation("", 64, false), '<') $stringUtils.containsNone($parameter.getDocumentation("", 64, false), "<") -->
#if (!$stringUtils.containsNone($parameter.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$parameter.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($parameter.getDocumentation("", 64, false), "\"'&<>"))]]>#end
                          </xs:documentation>
## JAXB does not bind wrapped types properly - always primitive if no customization, always wrapped if customization
#if ($parameter.type.booleanType && $parameter.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                          <xs:appinfo><jxb:property><jxb:baseType>
                            <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                          </jxb:baseType></jxb:property></xs:appinfo>
#end
                        </xs:annotation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#elseif ($parameter.type.booleanType && $parameter.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                        <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                          <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                        </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
##elseif ($parameter.many && $parameter.unique)
##                        <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
##                          <xjc:javaType name="$parameter.getterSetterTypeName" adapter="$XMLBooleanAdapter"/>
##                        </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                    </xs:element>
##end
#end
                </xs:sequence>
## No attributes for operation parameters - allow bare methods
##if ($useAttributes)
##foreach ($parameter in $operation.parameters)
##set ($type=$parameter.type.schemaType)
##if (!$useArrayWrapper && ($parameter.upper>1 || $parameter.upper==-1))
##set ($isMany=true)
##else
##set ($isMany=false)
##end
###              <!-- $parameter.name type.packageName=$type.packageName schemaType=$type isMany=$isMany-->
##if (!$parameter.return && $type.startsWith("xs:") && !$isMany)
### Metafacade: Paramerter.getUpper returns -1 for multiplicity *
##if ($parameter.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($parameter.packageName))
##if ($parameter.defaultValuePresent)
##set ($default = ' use="required" default="' + $parameter.defaultValue + '"')
##elseif (!$parameter.nillable)
##set ($default = ' use="required"')
##else
##set ($default = "")
##end
##if ($stringUtils.isNotBlank($parameter.getDocumentation("", 9999, false)))
##                <xs:attribute name="$parameter.name" type="$type"$default>
##                    <xs:annotation><xs:documentation>
##if (!$stringUtils.containsNone($parameter.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
##$parameter.getDocumentation("                        ", 100, false)
##if (!$stringUtils.containsNone($parameter.getDocumentation("", 64, false), "\"'&<>"))]]>#end
##                    </xs:documentation></xs:annotation>
##                </xs:attribute>
##else
##                <xs:attribute name="$parameter.name" type="$type"$default/>
##end
##end
##end
##end
##end
            </xs:complexType>
#else
            <xs:complexType/>
#end
        </xs:element>
#if ($operation.returnTypePresent || $operation.exceptionsPresent)
        <xs:element name="${operation.operationName}ResponseWrapper">
#if ($operation.returnTypePresent)
#if ($operation.returnType.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($operation.returnType.packageName) || $operation.returnType.schemaType.startsWith("xs:"))
#set ($type=$operation.returnType.schemaType)
#else
#set ($type="${webServiceUtils.getPkgAbbr($operation.returnType.package)}:${operation.returnType.name}")
#end
#if ($operation.returnParameter.lower<1 || $operation.lower<1)
#set ($minOccurs=' minOccurs="0"')
#else
#set ($minOccurs='')
#end
#if (!$useArrayWrapper && ($operation.returnParameter.many || $operation.upper>1 || $operation.upper==-1 || $type.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($maxOccurs='')
#end
#if ($operation.returnTypePresent)
## Avoid primitive types for wrapper attribute names, reserved keywords
#if ($stringUtils.isNotEmpty($operation.returnParameter.name))
#set ($returnName=$stringUtils.uncapitalize($operation.returnParameter.name))
#else
#set ($returnName="#if ($stringUtils.isBlank($operation.returnType.packageName) || $operation.returnType.schemaType.startsWith('xs:'))_#end${operation.returnType.name}")
#end
#else
#set ($returnName=$stringUtils.uncapitalize($operation.operationName))
#end
            <xs:complexType>
                <xs:sequence>
##                    <!-- $type $operation.returnType.name $operation.returnType $operation.returnType.schemaType -->
                    <xs:element name="$returnName" type="$type"${maxOccurs}>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($operation.returnType.booleanType && $operation.returnType.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                      <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                        <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                      </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                    </xs:element>
                </xs:sequence>
            </xs:complexType>
#else
            <xs:complexType/>
#end
        </xs:element>
#end
#end
#end
## Service exceptions are already included in referenced $types
##        <!-- $service.allowedOperationExceptions.size() $service.allowedOperationExceptions $service -->
#foreach($exception in $service.allowedOperationExceptions)
#if ($exception.associationEnds.empty)
#set ($faultName=$exception.name.replace("Exception", "Fault"))
#set ($faultPkg=$webServiceUtils.getPkgAbbr($exception.package))
#else
#set ($faultName=$exception.associationEnds.get(0).otherEnd.type.name)
#set ($faultPkg=$webServiceUtils.getPkgAbbr($exception.associationEnds.get(0).otherEnd.type.package))
#end
##        <!-- $exception.packageName $service.package.fullyQualifiedName $pkg $schemaTypes.contains($exception) $exception -->
##if ($exception.packageName.equals($service.package.fullyQualifiedName) || $stringUtils.isBlank($exception.packageName))
##set ($type=$exception.qName)
#set ($type="$webServiceUtils.getPkgAbbr(${exception.package}):$faultName")
        <xs:element name="$faultName" type="$type"/>
#if ($exception.packageName.equals($service.packageName))
        <xs:complexType name="${exception.name}">
            <xs:sequence>
#foreach($property in $exception.allProperties)
#if($property.lower==0)
#set ($multiplicity="0")
#elseif($property.lower==1)
#set ($multiplicity="1")
#else
#set ($multiplicity="unlimited")
#end
#if ($property.type.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($property.type.packageName) || $property.type.schemaType.startsWith("xs:"))
                <xs:element name="${property.name}" type="${property.type.schemaType}" minOccurs="$multiplicity"/>
#else
                <xs:element name="${property.name}" type="$webServiceUtils.getPkgAbbr(${property.type.package}):${property.type.name}" minOccurs="$multiplicity"/>
#end
#end
            </xs:sequence>
        </xs:complexType>
#end
##end
#end
#if ($defaultParameterStyle.equalsIgnoreCase("BARE"))
        <!-- TypeMapping for bare parameters in foreign namespaces -->
#foreach ($typeMapping in $webServiceUtils.getServiceReferences($service, $extensionInheritanceDisabled))
##if ($typeMapping.type)#set($typeMapping=$typeMapping.type)#end
#set ($type="${webServiceUtils.getPkgAbbr($typeMapping.package)}:${typeMapping.name}")
##        <!-- $typeMapping.name $typeMapping.packageName $typeMapping.type.schemaType -->
## TODO: default value for parameter added to type
        <xs:element name="$typeMapping.name" type="$type"/>
#end
#end
#end
        <!-- Service TypeMapping elements -->
##        <!-- $service $schemaTypes.size() $pkg.fullyQualifiedName -->
#foreach ($typeMapping in $webServiceUtils.getPackageTypes($service, $schemaTypes, $pkg.fullyQualifiedName, $extensionInheritanceDisabled))
#if ($umlUtils.shouldOutput($typeMapping))
#set ($type = $typeMapping)
##        <!-- Type mapping for $type.getSchemaType(false, true): qName=${type.qName} typeName=$typeMapping.name type=$typeMapping.type.name -->
#if ($typeMapping.type)
#set ($type = $typeMapping.type)
#end
#set ($arrayItemName = ${stringUtils.uncapitalize($type.getSchemaType(false, false))})
## TODO: Add nillable option for all minOccurs=0 elements/attributes
#if ($typeMapping.many && $useArrayWrapper)
        <xs:complexType name="$type.wsdlArrayName">
            <xs:sequence>
                <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="${type.namespacePrefix}:${type.qName}" />
            </xs:sequence>
        </xs:complexType>
#end
## If the declared type ends in [] (configurable metafacade property)
#if ($type.arrayType && $useArrayWrapper)
        <xs:complexType name="$type.getSchemaType(false, true)">
            <xs:sequence>
                <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="$type.getSchemaType(true, false)" />
            </xs:sequence>
        </xs:complexType>
#else
#* *##if ($type.enumeration)
##       <!-- Enumeration $type.name $type.getSchemaType(false, true): qName=${type.qName} -->
#*     *##foreach ($literal in ${type.literals})
##       <!-- $type.name literal: $literal -->
#*         *##set ($enumType = ${literal.type.schemaType})
#*     *##end
#if ($stringUtils.isBlank($type.qName))#set ($typeName = ${type.name})#else#set ($typeName = $type.qName)#end
        <xs:simpleType name="${typeName}">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$type.getDocumentation("                ", 100, false)
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))]]>#end
            </xs:documentation></xs:annotation>
#end
#if ($stringUtils.isBlank($enumType))#set ($enumType = "xs:string")#end
            <xs:restriction base="$enumType">
#*     *##foreach ($literal in $type.literals)
##            <!-- $type.name literal: $literal -->
#if ($stringUtils.isNotBlank($literal.getDocumentation("", 9999, false)))
                <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}">
                    <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($literal.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$literal.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($literal.getDocumentation("", 64, false), "\"'&<>"))]]>#end
                    </xs:documentation></xs:annotation>
                </xs:enumeration>
#else
                <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}"/>
#end
#*     *##end
            </xs:restriction>
        </xs:simpleType>
#* *##else
##if (!$service.allowedOperationExceptions.contains($type))
#if (!$type.hasStereotype("Exception") && !$type.hasStereotype("ApplicationException") && !$type.hasStereotype("UnexpectedException"))
#if ($type.hasStereotype("WebFault") && $type.hasStereotype("ValueObject"))
##set ($faultName=$type.qName.replace("Exception", "Fault"))
        <xs:element name="$type.qName" type="impl:$type.qName" />
#end
        <xs:complexType name="$type.qName">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$type.getDocumentation("                ", 100, false)
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))]]>#end
            </xs:documentation></xs:annotation>
#end
#set ($extensionRequired = $type.generalization && !$extensionInheritanceDisabled)
#if ($extensionRequired)
                <xs:complexContent>
                <xs:extension base="${type.generalization.namespacePrefix}:$type.generalization.qName">
#end
#set ($attributes = $type.getAttributes($extensionInheritanceDisabled))
#set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
##set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
## Output sequence if there are attributes/associations, and there are complex types or if everything is an element
##            <!-- Model: qName=${type.qName} hasComplexTypes=$webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled) package=${type.packageName} attributes=$attributes.size() otherEnds=$otherEnds.size() schemaType=${type.getSchemaType(false, true)} otherEnds.empty=$otherEnds.empty attributes.empty=$attributes.empty !($useAttributes && $attributes.empty) -->
##            <!-- Model: qName=${type.qName} package=${type.packageName} schemaType=${type.getSchemaType(false, true)} -->
#if (!$otherEnds.empty||!($useAttributes && $attributes.empty) || $webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled))
## xs:all indicates elements can exist in any order but can only appear once or not at all - can't use for arrays
## What we really need here is to see if any of the included elements are array elements maxOccurs > 1
#if ($useArrayWrapper)
            <xs:all>
#else
            <xs:sequence>
#end
#foreach ($attribute in $attributes)
#set ($attributeType = $attribute.type)
## Attribute type may be something other than WSDLType, i.e. Enumeration
#if (!$attributeType.wSDLTypeMetaType)
#set ($schemaType = "${webServiceUtils.getPkgAbbr($attributeType.package)}:${attributeType.qName}")
#elseif ($attribute.many && $useArrayWrapper)
#set ($schemaType = "${attributeType.namespacePrefix}:${attributeType.wsdlArrayName}")
#elseif (!$attributeType.packageName.equals($pkg.fullyQualifiedName) && $stringUtils.isNotBlank($attributeType.packageName) && $attributeType.packageName.indexOf('.')>0 && !$attributeType.schemaType.startsWith("xs:"))
#set ($schemaType = "${webServiceUtils.getPkgAbbr($attributeType.package)}:${attributeType.qName}")
#else
#set ($schemaType = "$attribute.type.schemaType")
#end
#if (!$useArrayWrapper && ($attribute.many || $attributeType.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#set ($isMany=true)
#else
#set ($maxOccurs='')
#set ($isMany=false)
#end
#if ($attribute.defaultValuePresent)
##if ($attribute.type.name.equals("String") || $attribute.type.name.equals("Character") || $attribute.type.name.equals("char"))
##set ($default=${attribute.defaultValue})
##else
#set ($default=${attribute.defaultValue.replaceAll('"', '')})
##end
#set ($use = ' minOccurs="0" default="$default"')
#elseif (!$attribute.nillable)
#set ($use = ' minOccurs="1"')
#else
#set ($use = ' minOccurs="0"')
#end
##                <!-- $attribute.name many=$attribute.many namespacePrefix=$type.namespacePrefix packageName=$type.packageName AschemaType=$attribute.type.schemaType qName=$type.qName isMany=$isMany schemaType=$schemaType -->
#if ((!$useAttributes) || ($isMany) || (!$attribute.type.schemaType.startsWith("xs:")))
                <xs:element name="$attribute.name" type="$schemaType"${use}${maxOccurs}>
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
                  <xs:annotation>
                    <xs:documentation>
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$attribute.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))]]>#end
                    </xs:documentation>
                  </xs:annotation>
#end
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#elseif ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                    <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                      <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                    </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                </xs:element>
#*     *##end
##if (!$otherEnds.empty)
##                <!-- Model associationEnds -->
##end
#foreach ($otherEnd in $otherEnds)
#set ($otherEndType = $otherEnd.type)
#if ($otherEnd.many && $useArrayWrapper)
#set ($schemaType = "${otherEndType.namespacePrefix}:${otherEndType.wsdlArrayName}")
#elseif ($otherEndType.packageName.equals($pkg.fullyQualifiedName) && $stringUtils.isNotBlank($otherEndType.packageName) && $otherEndType.packageName.indexOf('.')>0)
#if ($stringUtils.isBlank(${otherEndType.namespacePrefix}) || $stringUtils.isBlank(${otherEndType.qName}))
#set ($schemaType = "${service.namespacePrefix}:${otherEndType.name}")
#else
#set ($schemaType = "${otherEndType.namespacePrefix}:${otherEndType.qName}")
#end
#else
#if ($otherEndType.packageName.equals($pkg.fullyQualifiedName)))
#set ($schemaType = "${service.namespacePrefix}:${otherEndType.name}")
#elseif ($stringUtils.isBlank(${otherEndType.qName}))
#set ($schemaType = "${webServiceUtils.getPkgAbbr($otherEndType.package)}:${otherEndType.name}")
#else
#set ($schemaType = "${webServiceUtils.getPkgAbbr($otherEndType.package)}:${otherEndType.qName}")
#end
#end
#if (!$useArrayWrapper && ($otherEnd.many || $otherEndType.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($maxOccurs='')
#end
##                <!-- $otherEnd.name type.packageName=$type.packageName schemaType=$schemaType type.qName=$type.qName type.arrayType=$type.arrayType -->
#if ($stringUtils.isNotBlank($otherEnd.getDocumentation("", 9999, false)))
                <xs:element name="$otherEnd.name" type="${schemaType}"#if ($otherEnd.nillable) minOccurs="0"#else minOccurs="1"#end${maxOccurs}>
                    <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($otherEnd.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$otherEnd.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($otherEnd.getDocumentation("", 64, false), "\"'&<>"))]]>#end
                    </xs:documentation></xs:annotation>
                </xs:element>
#else
                <xs:element name="$otherEnd.name" type="${schemaType}"#if ($otherEnd.nillable) minOccurs="0"#else minOccurs="1"#end${maxOccurs}/>
#end
#end
#if ($useArrayWrapper)
            </xs:all>
#else
            </xs:sequence>
#end
#end
#if ($useAttributes)
#foreach ($attribute in $attributes)
#set ($attributeType = $attribute.type)
#if ($attribute.many || $attributeType.arrayType)
#set ($isMany=true)
#else
#set ($isMany=false)
#end
#if ($attributeType.schemaType.startsWith("xs:") && !$isMany)
## Metafacade: Paramerter.getUpper returns -1 for multiplicity *
## Use optional/required instead of nillable. If default, parameter is always optional
#if ($attribute.defaultValuePresent)
##if ($attribute.type.name.equals("String") || $attribute.type.name.equals("Character") || $attribute.type.name.equals("char"))
##set ($default=${attribute.defaultValue})
##else
#set ($default=${attribute.defaultValue.replaceAll('"', '')})
##end
#set ($use = ' use="optional" default="$default"')
#elseif (!$attribute.nillable)
#set ($use = ' use="required"')
#else
#set ($use = "")
#end
##            <!-- $attribute.name type=$attribute.getterSetterTypeName packageName=$type.packageName typeName=$type.fullyQualifiedName typeNameMdl=$type.getFullyQualifiedName(false) schemaType=$type.schemaType isMany=$isMany -->
            <xs:attribute name="$attribute.name" type="$attributeType.schemaType"${use}>
                <xs:annotation>
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
                  <xs:documentation>
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[#end
$attribute.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))]]>#end
                  </xs:documentation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                  <xs:appinfo><jxb:property><jxb:baseType>
                    <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                  </jxb:baseType></jxb:property></xs:appinfo>
#end
                </xs:annotation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#elseif ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                  <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
            </xs:attribute>
#end
#end
#end
#*     *##if ($extensionRequired)
            </xs:extension>
            </xs:complexContent>
#*     *##end
        </xs:complexType>
##if ($type.hasStereotype("WebFault") && $type.hasStereotype("ValueObject"))
##        </xs:element>
##end
##end
#end
#end
#end
#end
#end
    </xs:schema>
#end
#end
#end