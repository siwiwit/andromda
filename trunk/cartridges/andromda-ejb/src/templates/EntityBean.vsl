/* Autogenerated by AndroMDA (EntityBean.vsl) - do not edit */
package $entity.packageName;

#set ($identifier = $entity.identifiers.iterator().next())
/**
 * Autogenerated EJB implementation class for ${entity.name}
 *
$entity.getDocumentation(" * ")
 *
#if ($entity.abstract)
 * @ejb.bean generate="false"
#else
 * @ejb.bean generate="true"
#end
 *     name="$entity.name"
 *     type="CMP"
 *     cmp-version="2.x"
 *     view-type="local"
 *     local-jndi-name = "${entity.jndiName}/Local"
###end
#if (!$identifier.complex)
 *     primkey-field = "${identifier.name}"
#end
 *
 * @ejb.interface generate="false" local-class="${entity.fullyQualifiedName}"
 * @ejb.home generate="false" local-class="${entity.fullyQualifiedName}LocalHome"
 * @ejb.pk generate = "false" class = "$identifier.type.fullyQualifiedName"
 *
## Only generate persistence tags for concrete EJBs.
#if(!$entity.abstract)
 * @ejb.persistence table-name="$entity.tableName"
 *
#end
#foreach($envEntry in $entity.getEnvironmentEntries(true))
#set ($value = $envEntry.defaultValue)
## Add string delimiters if they are not already present
#if (!$value.startsWith('"') || !$value.endsWith('"'))
#set ($value = "$value")
#end
 * @ejb.env-entry
 *     name="$envEntry.name"
 *     type="$envEntry.type.fullyQualifiedName"
 *     value=$value
 *
#end
#foreach ( $dependency in $entity.dependencies )
#if ($dependency.hasStereotype("EntityRef") || $dependency.hasStereotype("ServiceRef"))
#set ($reference = $dependency.targetElement)
 *
 * @ejb.ejb-ref
 *     ejb-name="$reference.name"
 *     view-type="$reference.viewType"
 *     ref-name="ejb/${reference.name}BeanRef"
#end
#if ($dependency.hasStereotype("ResourceRef"))
#set ($superclass = $dependency.targetElement)
#set ($jndiRef = $dependency.findTaggedValue("@andromda.ejb.resource-ref.jndi-name"))
#set ($resAuth = $dependency.findTaggedValue("@andromda.ejb.resource-ref.res-auth"))
#if (!$resAuth)
#set ($resAuth = "Container")
#end
#set ($resName = $dependency.name)
#if (!$resName || $resName == "")
#set ($resName = $reference.name)
#end
 *
 * @ejb.resource-ref
 *     res-ref-name="resource/$resName"
 *     res-type="$reference.type.fullyQualifiedName"
 *     res-auth="$resAuth"
#if ($jndiRef)
 *
 * @jboss.resource-ref
 *     res-ref-name="resource/$resName"
 *     jndi-name="$jndiRef"
#end
#end
#end
#foreach ( $finder in $entity.getFinders(true))
#if($finder.findTaggedValue("@andromda.ejb.query.dialect") == "JBossQL")
 *
 * @ejb.finder signature="$finder.returnType.fullyQualifiedName $finder.signature"
 *             query="This finder method is only supported on the JBoss application server"
 * @jboss.query signature="$finder.returnType.fullyQualifiedName $finder.signature"
 *             query="$finder.query"
#else
 *
 * @ejb.finder signature="$finder.returnType.fullyQualifiedName $finder.signature"
 *             query="$finder.query"
#end
#end## finder operations
 */
public abstract class ${entity.name}Bean
#if($entity.generalization)  
	extends ${entity.generalization.fullyQualifiedName}BeanImpl
#end
    implements javax.ejb.EntityBean
{
    // ----------- constant definitions -----------
#foreach($constant in $entity.getConstants(true))
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#end

    // -- accessors for environment entries --
#foreach($envEntry in $entity.getEnvironmentEntries(true))
    /**
     * Get <em>${envEntry.name}</em> environment entry.
$envEntry.getDocumentation("     * ")
     *
## Only expose the method to the component interface if it is public.
#if($envEntry.visibility == "public")
     * @ejb.interface-method
#end
     */
    $envEntry.visibility $envEntry.type.fullyQualifiedName ${constant.getterName}(){
        javax.naming.InitialContext initialContext = null;
        try {
            initialContext = new javax.naming.InitialContext();
            return (${attType}) initialContext.lookup("java:comp/env/$envEntry.name");
        } catch (javax.naming.NamingException cause) {
            RuntimeException ex = new IllegalStateException(
                "Cannot access environment entry \"$envEntry.name\".");
            // In order to set the exception cause on JDK 1.4
            // and stay JDK 1.3 compatible nonetheless, we need
            // a bit of reflection magic here...
            try {
                java.lang.reflect.Method initCause =
                  ex.getClass().getMethod("initCause",
                                        new Class[] {Throwable.class});
                initCause.invoke(ex, new Object[] { cause });
            } catch (Throwable t) {
               // Ignore any errors here - we simply make do without the cause
            }
            throw ex;
        } finally {
            try {
                if (initialContext != null) { initialContext.close(); }
            } catch (javax.naming.NamingException ignore) {
                // Silently ignore naming exceptions at cleanup time
            }
        }

## If the env-entry is public, expose it to the home interface as well
#if($envEntry.visibility == "public")

    /**
     * Home interface method for accessing {@link #${att.getterName}}.
     * @ejb.home-method
     * @see #${envEntry.getterName}
     */
     public $envEntry.type.fullyQualifiedName ejbHomeGet${envEntry.name}() {
         return ${envEntry.getterName};
     }
#end
#end

    // -- accessors for constants --
#foreach($constant in $entity.getConstants(true))
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
#if ($constant.visibility == "public")
     *
     * @ejb.interface-method
#end
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}(){
        return $constant.name;
    }

## If the constant is public, expose it to the home interface as well
#if($constant.visibility == "public")

    /**
     * Home interface method for accessing {@link #${att.getterName}}.
     * @ejb.home-method
     * @see #${constant.getterName}
     */
     public $constant.type.fullyQualifiedName ejbHomeGet${constant.name}() {
         return ${constant.getterName};
     }
#end
#end

    // --------------- attributes ---------------------
#foreach ( $att in $entity.attributes)
#set($attType = $att.type.fullyQualifiedName)
#set ($transactionType = $att.findTaggedValue("@ejb.transactionType", true))
#set ($visibility = $att.visibility.toString())
    /**
     * Get the ${att.name} property
$att.getDocumentation("     * ")
     *
#if ($att.identifier)
     * @ejb.pk-field
#end
     * @ejb.persistence
     *     column-name="${att.columnName}"
     *       jdbc-type="${att.jdbcType}"
     *        sql-type="${att.sqlType}"
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     *
## Only expose the method to the interfaces if it is public. The method
## visibility must be public because of CMP semantics
#if($visibility == "public")
     * @ejb.interface-method
#end
     */
    public abstract $attType ${att.getterName}();

    /**
     * Set the ${att.name} property
     * @param value the new value
## We need to generate a public set method even for readonly or proteced
## attributes because of CMP semantics.
## But we don't need to expose it on the interface
#if($visibility == "public" && !$att.readOnly)
     * @ejb.interface-method
#end
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     */
    public abstract void ${att.setterName}($attType value);

#end

    // ------------- CMR relations ------------------
## If the class is abstract, generate abstract methods for all CMR relations so that they
## are accessible in the *BeanImpl class
#if ($entity.abstract)
#foreach ( $assoc in $entity.entityRelations) )
#set ($target = $assoc.otherEnd)
#if(!($assoc.association.findTaggedValue("@andromda.ejb.generateCMR") == "false"))
#set ($assocname = $assoc.association.name)
#set ($targetRoleName = $assoc.otherEnd.name)
#set ($targetTypeName = $assoc.relationType)

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("    * ")
    * @ejb.interface-method
    */
    public abstract $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
#if(!$assoc.otherEnd.readOnly)
    * @ejb.interface-method
#end
    */
    public abstract void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end
#end ## foreach

#end
## Generate the real CMR methods.
#foreach ( $assoc in $entity.allEntityRelations )
#set ($target = $assoc.otherEnd)
## relations not flagged as CMR are generated below under business methods
#if(!($assoc.association.findTaggedValue("@andromda.ejb.generateCMR") == "false"))
#set ($assocname = $assoc.association.name)
#set ($transactionType = $assoc.association.findTaggedValue("@andromda.ejb.transactionType"))
#set ($targetTypeName = $assoc.relationType)

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("    * ")
    *
    * @ejb.interface-method
    * @ejb.relation
    *    name="$assocname"
    *    role-name="$assocname:$assoc.name"
    *    target-ejb="$assoc.otherEnd.type.name"
#if (!$assoc.navigable)
    *    target-role-name="$assocname:$assoc.otherEnd.name"
#if ($assoc.many2One || $assoc.many2Many)
    *    target-multiple="true"
#end
#end
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    *
#if ($assoc.one2Many || $assoc.many2Many || $assoc.otherEnd.findTaggedValue("@jboss.autoKeyFields") == "true")
    * @jboss.auto-key-fields
#else
#set ($identifiers = $assoc.otherEnd.type.identifiers)
#if (!$identifiers.empty)
#foreach ($identifier in $identifiers)
#if ($identifiers.size() == 1)
#set ($identifierName = $identifier.name)
#else
#set ($identifierName = "$assoc.otherEnd.type.name")
#end
    * @jboss.relation
    *     fk-column="${assoc.otherEnd.columnName}"
    *     related-pk-field="${identifierName}"
#end
#end
#end
    */
    public abstract $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
#if(!$assoc.otherEnd.readOnly)
    * @ejb.interface-method
#end
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end
#end ## foreach

    // ---------------- business and select methods  ----------------------
## Generate business methods for relations flagged as non-CMR even when the class
## is abstract. That way, we can implement them in the base class
#foreach ( $assoc in $entity.entityRelations)
#set ($target = $assoc.otherEnd)
#if($assoc.association.findTaggedValue("@andromda.ejb.generateCMR") == "false")
#set ($transactionType = $assoc.association.findTaggedValue("@andromda.ejb.transactionType"))
#set ($targetTypeName = $assoc.relationType))

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("     * ")
    *
    * @ejb.interface-method
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
    * @ejb.interface-method
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end
#end ## foreach

#foreach ( $op in $entity.operations)
#if (!$op.hasStereotype("FinderMethod") && !$op.hasStereotype("CreateMethod") && !$op.hasStereotype("SelectMethod"))
#set ($transactionType = $op.findTaggedValue("@andromda.ejb.transactionType", true))
#set ($signature = $op.signature)
#set ($interfaceType = "interface")
#set ($visibility = $op.visibility.toString())
## Public static methods are exposed on the home
## interface instead of the component interface
#if ($visibility == "public" && $op.static)
#set ($interfaceType = "home")
#set ($signature = "ejbHome${str.capitalize($signature)}")
#end
   /**
$op.getDocumentation("    * ")
    *
## Only public methods have transactions and are exported to the interfaces
#if ($visibility == "public")
    * @ejb.${interfaceType}-method
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
#end
    */
#set ($returnType = $op.returnType.fullyQualifiedName)
#if ($op.hasExceptions())
    $visibility abstract $returnType $signature
        throws $op.exceptionList;
#else
    $visibility abstract $returnType $signature;
#end
#end
#if ($op.hasStereotype("SelectMethod"))
#set($queryString = "")
#set($queryString = $op.findTaggedValue("@andromda.ejb.query"))
#if($queryString == "")
#set($queryString = "SELECT DISTINCT OBJECT(c) FROM $entity.name AS c")
#if($op.arguments.size() >0 )
#set($queryString = "${queryString} WHERE")
#foreach($prm in $op.arguments)
#set($queryString="${queryString} c.$prm.name = ?$velocityCount")
#if($velocityCount != $op.arguments.size())
#set($queryString = "${queryString} AND")
#end
#end
#end
#end
#set ($returnType = $op.returnType.fullyQualifiedName)
   /**
$op.getDocumentation("    * ")
    *
    * @ejb.select query="$queryString"
    */
    public abstract $returnType $op.signature
    throws javax.ejb.FinderException;
#end##if op.stereotype = "SelectMethod"

#end

    // ---------------- create methods --------------------
## Handle explicitly defined create methods. Since we can't know
## what the user intended to do with the arbitrary parameters to these methods,
## we generate an abstract ejbCreateImpl() and delegate the implementation to
## the user.
#foreach ( $op in $entity.createMethods(false))
#set ($transactionType = $op.findTaggedValue("@andromda.ejb.transactionType", true))

    /**
#if (!$entity.abstract)
     * Implementation for the
     * {@link #ejbCreate($op.argumentTypeNames)}
     * create method.
#else
     * Implementation for create methods in derived classes. This method will be called from
     * the autogenerated  <code>ejbCreate($op.argumentTypeNames)</code>
     * methods in concrete subclasses of this abstract EJB.
#end
     *
     * This extra implementation method is necessary to avoid
     * problems with different primary key classes.
	 *
     */
    protected abstract void ejbCreateImpl${op.typedArgumentList}
           throws javax.ejb.CreateException;

    public void ejbPostCreate${op.typedArgumentList} {
    }
#end
#if (!$entity.abstract)
#foreach ( $op in $entity.createMethods(true))

    /**
$op.getDocumentation("    * ")
     *
     */
    public $identifier.type.fullyQualifiedName ejbCreate${op.typedArgumentList}
           throws javax.ejb.CreateException {
       ejbCreateImpl($op.argumentNames);
       return null;
    }
#end
#end

## Autogenerate a create method implementation with all attributes.
#set ($allAttributes = $transform.filterByVisibility($entity.allInstanceAttributes, "public"))
#set ($inheritedAttributes = $transform.filterByVisibility($entity.inheritedInstanceAttributes, "public"))
#set ($instanceAttributes = $transform.filterByVisibility($entity.instanceAttributes, "public"))

    /**
     * Implementation for the create method with all CMP attributes.
     * This method calls the super class implementation for inherited
     * CMP fields and sets all CMP fields defined in this class to the
     * values provided by the parameters. Override this method in the
     * implementation class if you need different behaviour.
     *
     * This extra implementation method is necessary to avoid
     * problems with different primary key classes.
	 *
#foreach($att in $allAttributes)
     * @param $att.name Value for the ${att.name} property
#end
     */
    protected void ejbCreateImpl($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!$inheritedAttributes.empty)
        super.ejbCreateImpl($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
##
## Implement artificial key generation as a quick hack until
## Richard returns and tells us how to do it properly without
## breaking usability of the PIM with the Hibernate cartridge.
## (Matthias Bohlen)
##
#if (!$identifier.complex)
#if ($identifier.type.fullyQualifiedName == "java.lang.String")
        if ($identifier.name == null) {
            $identifier.name = new java.rmi.server.UID().toString();
        }

#end
#end
#foreach ( $attribute in $instanceAttributes)
        ${attribute.setterName}(${attribute.name});
#end
    }

## Only generate create methods with all CMP and CMR fields for concrete EJBs,
## and only if it is not explicitly switched off
#if (!$entity.abstract && !$entity.findTaggedValue("@andromda.ejb.noSyntheticCreateMethod"))
    /**
     * Create method with all CMP attribute values.
#foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the $attribute.name property
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $identifier.type.fullyQualifiedName ejbCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
        ejbCreateImpl($transform.getAttributesAsList($allAttributes, false, true));
        return null;
    }
#end

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!$inheritedAttributes.empty)
        // Call postCreate method for the super type
        super.ejbPostCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
    }
#set ($relations = $entity.allEntityRelations)
#if (!$relations.empty)
#if (!$entity.abstract && !$entity.findTaggedValue("@andromda.ejb.noSyntheticCreateMethod"))
    /**
     * Create method with all CMP attribute values and CMR relations.
#foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the $attribute.name property
#end
#foreach ($relation in $relations)
     * @param $relation.otherEnd.name Value for the ${relation.otherEnd.name} relation role
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $identifier.type.fullyQualifiedName ejbCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.empty), #end#foreach ($relation in $relations)${relation.relationType} $relation.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
           throws javax.ejb.CreateException
    {
        // Call ejbCreate method for the CMP attributes
        ejbCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Relations cannot be set in ejbCreate() - this is done in ejbPostCreate()
        return null;
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.empty), #end#foreach ($relation in $relations)${relation.relationType} $relation.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
           throws javax.ejb.CreateException
    {
        // Call postCreate method for the CMP attributes
        ejbPostCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Set the CMR relations
#foreach ($relation in $relations)
        ${relation.otherEnd.setterName}($relation.otherEnd.name);
#end
    }
#end
#end
    // ---------------- accessor methods for bean references ---------------

#foreach ( $dependency in $entity.dependencies )
#if ($dependency.hasStereotype("EntityRef") || $dependency.hasStereotype("ServiceRef"))
#set ($reference = $dependency.targetElement)
#if ($reference.viewType == "local")
#set ($homeInterfaceName = "${reference.name}LocalHome")
#set ($fqHomeInterfaceName = "${reference.fullyQualifiedName}LocalHome")
    /**
     * Get the local home interface of the ${reference.name} bean.
     * The home interface is obtained from the initial context
     * by looking up the bean reference name.
     * @return local home interface for ${reference.name}.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try {
            // Local homes shouldn't be narrowed, as there is no RMI involved.
            ${fqHomeInterfaceName} home =
                (${fqHomeInterfaceName}) initialContext.lookup("java:/comp/env/ejb/${reference.name}BeanRef");
            return home;
        } finally {
            initialContext.close();
        }
    }
#end
#if ($reference.viewType == "remote")
#set ($homeInterfaceName = "${reference.name}Home")
#set ($fqHomeInterfaceName = "${reference.fullyQualifiedName}Home")
    /**
     * Get the remote home interface of the ${reference.name} bean.
     * The home interface is obtained from the initial context
     * by looking up the bean reference name.
     * @return remote home interface for ${reference.name}. Lookup using bean ref name.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try {
            Object home =
                 initialContext.lookup("java:/comp/env/ejb/${reference.name}BeanRef");
            return ($fqHomeInterfaceName)
                   javax.rmi.PortableRemoteObject.narrow(home,
                   ${fqHomeInterfaceName}.class);
        } finally {
            initialContext.close();
        }
    }
#end
#end
#if ($dependency.hasStereotype("ResourceRef"))
#set ($reference = $dependency.targetElement)
#set ($resClassName = "$reference.fullyQualifiedName")
#set ($resName = $dependency.name)
#if (!$resName || $resName == "")
#set ($resName = $reference.name)
#end
    /**
     * Get the ${resName} resource.
     * The resource is obtained by looking up
     * <code>java:/comp/env/resource/$resName</code> in JNDI
     * @return the ${resName} resource
     */
    protected static ${resClassName} get${str.capitalize($resName)}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try {
            Object resource =
                 initialContext.lookup("java:/comp/env/resource/$resName");
            return ($resClassName) resource;
        } finally {
            initialContext.close();
        }
    }
#end
#end

}
