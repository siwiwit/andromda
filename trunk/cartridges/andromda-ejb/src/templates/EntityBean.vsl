/* Autogenerated by AndroMDA (EntityBean.vsl) - do not edit */
## Include global definitions. ##
#parse("templates/EJBglobals.vm")

##################################################################################
##                         The actual template starts here                      ##
##################################################################################
package $packagename;

/**
 * Autogenerated EJB implementation class for ${class.name}
 *
$class.getDocumentation(" * ")
 *
#if ($class.abstract)
 * @ejb.bean generate="false"
#else
 * @ejb.bean generate="true"
#end
 *     name="$entityname"
 *     type="CMP" 
 *     cmp-version="2.x"
 *     view-type="local"
 *     local-jndi-name = "${ejbRefName}/Local"
###end
#if (!$primaryKeyAttribute.complex)
 *     primkey-field = "${primaryKeyAttribute.name}"
#end
 *
 * @ejb.interface generate="false" local-class="${packagename}.${entityname}"
 * @ejb.home generate="false" local-class="${packagename}.${entityname}LocalHome"
 * @ejb.pk generate = "false" class = "$pkclassname"
 *
## Only generate persistence tags for concrete EJBs.
#if(!$class.abstract)
 * @ejb.persistence table-name="$class.tableName"
 *
## Project specific stuff: Generate an environment entry for the 
## primary key sequence if this entity is a concrete EJB and has an IntegerIdPk
#if ($pkclassname == "de.tivano.labdb.datalayer.IntegerIdPK")
 * @ejb.env-entry 
 *     name = "PrimaryKeySequence"
 *     type = "java.lang.String"
 *     value = "${class.tableName}_SEQ"
 *
#end
#end
## Generate environment entries for all static, readonly attributes stereotyped
## as <<EnvEntry>>
#foreach($att in $class.staticAttributes)
#if ($att.hasStereotype("EnvEntry"))
#set ($value = $att.defaultValue.body)
## Add string delimiters if they are not already present
#if (!$value.startsWith('"') || !$value.endsWith('"'))
#set ($value = "$value")
#end
 * @ejb.env-entry 
 *     name = "$att.name"
 *     type = "$att.type.fullyQualifiedName"
 *     value = $value
 *
#end
#end
#foreach ( $dep in $class.dependencies )
#if ($dep.hasStereotype("EntityRef") || $dep.hasStereotype("ServiceRef"))
#set ($superclass = $dep.targetElement)
#set ($viewtype = $class.findTaggedValue("@andromda.ejb.viewType"))
#if (!$viewtype || $viewtype == "")
#set ($viewtype = $superclass.viewType)
#end
 *
 * @ejb.ejb-ref 
 *     ejb-name="${superclass.name}" 
 *     view-type="$viewtype" 
 *     ref-name="ejb/${superclass.name}BeanRef"
#end
#if ($dep.hasStereotype("ResourceRef"))
#set ($superclass = $dep.targetElement)
#set ($jndiRef = $dep.findTaggedValue("@andromda.ejb.resource-ref.jndi-name"))
#set ($resAuth = $dep.findTaggedValue("@andromda.ejb.resource-ref.res-auth"))
#if (!$resAuth)
#set ($resAuth = "Container")
#end
#set ($resName = $dep.name)
#if (!$resName || $resName == "")
#set ($resName = $superclass.name)
#end
 *
 * @ejb.resource-ref 
 *     res-ref-name="resource/$resName" 
 *     res-type="$superclass.type.fullyQualifiedName" 
 *     res-auth="$resAuth"
#if ($jndiRef)
 *
 * @jboss.resource-ref 
 *     res-ref-name = "resource/$resName" 
 *     jndi-name = "$jndiRef" 
#end
#end
#end
#foreach ( $finder in $class.getFinders(true))
#if($finder.findTaggedValue("@andromda.ejb.query.dialect") == "JBossQL")
 *
 * @ejb.finder signature="$finder.type.fullyQualifiedName $finder.signature"
 *             query="This finder method is only supported on the JBoss application server"
 * @jboss.query signature="$finder.type.fullyQualifiedName $finder.signature"
 *             query="$finder.query"
#else
 *
 * @ejb.finder signature="$finder.type.fullyQualifiedName $finder.signature"
 *             query="$finder.query"
#end
#end##operation.finders
#copyTaggedValues($class " " [ "@andromda.ejb.viewType", "@andromda.ejb.transactionType",  "@andromda.ejb.noSyntheticCreateMethod" ])
 *
 */
public abstract class ${entityname}Bean 
       extends $beanparentclass
       implements javax.ejb.EntityBean
{
    // ----------- constant definitions --------------------
#foreach($att in $class.staticAttributes)
#if (!$att.hasStereotype("EnvEntry"))
#set ($attType = $att.type.fullyQualifiedName)
#set ($ATT_NAME = $att.columnName)
    private static final $attType $ATT_NAME = $att.initialValue.body;
#end
#end
    
    // -- accessors for environment entries and constants --
#foreach($att in $class.staticAttributes)
#set($attType = $att.type.fullyQualifiedName)
#set ($visibility = $att.visibility.toString() )

    /**
#if($att.hasStereotype("EnvEntry"))
     * Get <em>${att.name}</em> environment entry
#else
#set ($ATT_NAME = $att.columnName)
     * Get ${att} the <code>$ATT_NAME</code> constant
#end
$att.getDocumentation("     * ")
     *
## Only expose the method to the component interface if it is public.
#if($visibility == "public")
     * @ejb.interface-method
#end
     */
    $visibility $attType ${att.getterName}(){
#if($att.hasStereotype("EnvEntry"))
        javax.naming.InitialContext initialContext = null;
        try {
            initialContext = new javax.naming.InitialContext();
            return (${attType}) initialContext.lookup("java:comp/env/$att.name");
        } catch (javax.naming.NamingException cause) {
            RuntimeException ex = new IllegalStateException(
                "Cannot access environment entry \"$att.name\".");
            // In order to set the exception cause on JDK 1.4
            // and stay JDK 1.3 compatible nonetheless, we need
            // a bit of reflection magic here...
            try {
                java.lang.reflect.Method initCause =
                  ex.getClass().getMethod("initCause", 
                                        new Class[] {Throwable.class});
                initCause.invoke(ex, new Object[] { cause });
            } catch (Throwable t) {
               // Ignore any errors here - we simply make do without the cause
            }
            throw ex;
        } finally {
            try {
                if (initialContext != null) { initialContext.close(); }
            } catch (javax.naming.NamingException ignore) {
                // Silently ignore naming exceptions at cleanup time
            }
        }
#else
        return $ATT_NAME;
#end
    }
## If the attribute is public, expose it to the home interface as well
#if($visibility == "public")

    /**
     * Home interface method for accessing {@link #${att.getterName}}.
     * @ejb.home-method
     * @see #${att.getterName}
     */
     public $attType ejbHomeGet${att.name}() {
         return ${att.getterName};
     }
#end
#end

    // --------------- attributes ---------------------
#foreach ( $att in $class.attributes)
#set($attType = $att.type.fullyQualifiedName)    
#set ($transactionType = $att.findTaggedValue("@andromda.ejb.transactionType", true))
#set ($visibility = $att.visibility.toString())
    /**
     * Get the ${att.name} property
$att.getDocumentation("     * ")
     *
#if ($att.identifier)
     * @ejb.pk-field
#end
     * @ejb.persistence
     *     column-name="${att.columnName}"
     *       jdbc-type="${att.jdbcType}"
     *        sql-type="${att.sqlType}"
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     *
## Only expose the method to the interfaces if it is public. The method
## visibility must be public because of CMP semantics
#if($visibility == "public")
     * @ejb.interface-method 
#end
     */
    public abstract $attType ${att.getterName}();

    /**
     * Set the ${att.name} property
     * @param value the new value
## We need to generate a public set method even for readonly or proteced
## attributes because of CMP semantics. 
## But we don't need to expose it on the interface
#if($visibility == "public" && !$att.readOnly)
     * @ejb.interface-method 
#end     
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     */
    public abstract void ${att.setterName}($attType value);
    
#end

    // ------------- CMR relations ------------------
## If the class is abstract, generate abstract methods for all CMR relations so that they
## are accessible in the *BeanImpl class
#if ($class.abstract)
#foreach ( $assoc in $class.entityRelations) )
#set ($target = $assoc.otherEnd)
#if(!($assoc.association.findTaggedValue("@andromda.ejb.generateCMR") == "false"))
#set ($assocname = $assoc.association.relationName)
#set ($targetRoleName = $assoc.otherEnd.name)
#set ($targetTypeName = $assoc.relationType)

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("    * ")
    * @ejb.interface-method 
    */
    public abstract $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
#if(!$assoc.otherEnd.readOnly)
    * @ejb.interface-method 
#end
    */
    public abstract void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end
#end ## foreach

#end
## Generate the real CMR methods.
#foreach ( $assoc in $class.allEntityRelations )
#set ($target = $assoc.otherEnd)
## relations not flagged as CMR are generated below under business methods
#if(!($assoc.association.findTaggedValue("@andromda.ejb.generateCMR") == "false"))
#set ($assocname = $assoc.association.relationName)
#set ($transactionType = $assoc.association.findTaggedValue("@andromda.ejb.transactionType"))
#set ($targetTypeName = $assoc.relationType)

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("    * ")
    *
    * @ejb.interface-method 
    * @ejb.relation
    *    name="$assocname"
    *    role-name="$assocname:$assoc.name"
    *    target-ejb="$assoc.otherEnd.type.name"
#if (!$assoc.navigable)
    *    target-role-name="$assocname:$assoc.otherEnd.name"
#if ($assoc.many2One || $assoc.many2Many)
    *    target-multiple="true"
#end
#end
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    *
#if ($assoc.isOne2Many() || $assoc.isMany2Many() || $assoc.otherEnd.findTaggedValue("@andromda.jboss.autoKeyFields") == "true")
    * @jboss.auto-key-fields
#else
#set ($identifiers = $assoc.otherEnd.type.identifiers)
#if (!$identifiers.empty)
#foreach ($identifier in $identifiers)
#if ($identifiers.size() == 1)
#set ($identifierName = $identifier.name)
#else
#set ($identifierName = "$assoc.otherEnd.type.name")
#end
    * @jboss.relation 
    *     fk-column = "${assoc.otherEnd.columnName}"
    *     related-pk-field = "${identifierName}"
#end
#end
#end
    */
    public abstract $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
#if(!$assoc.otherEnd.readOnly)
    * @ejb.interface-method 
#end
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end
#end ## foreach 

    // ---------------- business and select methods  ----------------------
## Generate business methods for relations flagged as non-CMR even when the class
## is abstract. That way, we can implement them in the base class
#foreach ( $assoc in $class.entityRelations)
#set ($target = $assoc.otherEnd)
#if($assoc.association.findTaggedValue("@andromda.ejb.generateCMR") == "false")
#set ($transactionType = $assoc.association.findTaggedValue("@andromda.ejb.transactionType"))
#set ($targetTypeName = $assoc.relationType))

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("     * ")
    *
    * @ejb.interface-method 
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
    * @ejb.interface-method 
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
    */
    public abstract void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end
#end ## foreach 

#foreach ( $op in $class.operations)
#if (!$op.hasStereotype("FinderMethod") && !$op.hasStereotype("CreateMethod") && !$op.hasStereotype("SelectMethod"))
#set ($transactionType = $op.findTaggedValue("@andromda.ejb.transactionType", true))
#set ($msig = $op.signature)
#set ($interfaceType = "interface")
#set ($visibility = $op.visibility.toString())
#set ($exceptions = "")
#set ($exceptions = $op.findTaggedValue("@andromda.java.throws"))
#if ($exceptions == "")
#set ($exceptions = $defaultException.fullyQualifiedName)
#end
## Public static methods are exposed on the home 
## interface instead of the component interface
#if ($visibility == "public" && $op.static) 
#set ($interfaceType = "home")
#set ($msig = "ejbHome${str.upperCaseFirstLetter($msig)}")
#end
   /**
$op.getDocumentation("    * ")
    *
## Only public methods have transactions and are exported to the interfaces
#if ($visibility == "public")
    * @ejb.${interfaceType}-method 
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
#end
    */
#set ($returntype = $op.type.fullyQualifiedName)
#if ($exceptions == "")
    $visibility abstract $returntype ${msig};    
#else
    $visibility abstract $returntype ${msig}
        throws $exceptions;
#end
#end
#if ($op.hasStereotype("SelectMethod"))
#set($querystring = "")
#set($querystring = $op.findTaggedValue("@andromda.ejb.query"))
#if($querystring == "")
#set($querystring = "SELECT DISTINCT OBJECT(c) FROM $class.name AS c")
#if($op.parameters.size() >0 )
#set($querystring = "${querystring} WHERE")
#foreach($prm in $op.parameters)
#set($querystring="${querystring} c.$prm.name = ?$velocityCount")
#if($velocityCount != $op.parameters.size())
#set($querystring = "${querystring} AND")
#end
#end
#end
#end
#set ($returntype = $op.type.fullyQualifiedName)
   /**
$op.getDocumentation("    * ")
    *
    * @ejb.select query="$querystring"
    */
    public abstract $returntype $op.signature 
    throws javax.ejb.FinderException;
#end##if op.stereotype = "SelectMethod"

#end

    // ---------------- create methods --------------------
## Handle explicitly defined create methods. Since we can't know 
## what the user intended to do with the arbitrary parameters to these methods,
## we generate an abstract ejbCreateImpl() and delegate the implementation to 
## the user.
#foreach ( $op in $class.createMethods(false))
#set ($transactionType = $op.findTaggedValue("@andromda.ejb.transactionType", true))

    /**
#if (!$class.abstract)
     * Implementation for the 
     * {@link #ejbCreate($op.parameterTypeNames)} 
     * create method.
#else
     * Implementation for create methods in derived classes. This method will be called from
     * the autogenerated  <code>ejbCreate($op.parameterTypeNames)</code> 
     * methods in concrete subclasses of this abstract EJB.
#end
     *
     * This extra implementation method is necessary to avoid 
     * problems with different primary key classes.
	 *     
     */
    protected abstract void ejbCreateImpl${op.typedParameterList}
           throws javax.ejb.CreateException;

    public void ejbPostCreate${op.typedParameterList} {
    }
#end    
#if (!$class.abstract)
#foreach ( $op in $class.createMethods(true))

    /**
$op.getDocumentation("    * ")
     *
     */
    public $pkclassname ejbCreate${op.typedParameterList}
           throws javax.ejb.CreateException {
       ejbCreateImpl($op.parameterNames);
       return null;
    }
#end
#end

## Autogenerate a create method implementation with all attributes.
#set ($allAttributes = $transform.filterByVisibility($class.allInstanceAttributes, "public"))
#set ($inheritedAttributes = $transform.filterByVisibility($class.inheritedInstanceAttributes, "public"))
#set ($instanceAttributes = $transform.filterByVisibility($class.instanceAttributes, "public"))

    /**
     * Implementation for the create method with all CMP attributes.
     * This method calls the super class implementation for inherited
     * CMP fields and sets all CMP fields defined in this class to the
     * values provided by the parameters. Override this method in the
     * implementation class if you need different behaviour.
     *
     * This extra implementation method is necessary to avoid 
     * problems with different primary key classes.
	 *     
#foreach($att in $allAttributes)
     * @param $att.name Value for the ${att.name} property
#end
     */
    protected void ejbCreateImpl($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!$inheritedAttributes.isEmpty())
        super.ejbCreateImpl($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
##
## Implement artificial key generation as a quick hack until
## Richard returns and tells us how to do it properly without
## breaking usability of the PIM with the Hibernate cartridge.
## (Matthias Bohlen)
##
##if (!$transform.hasComplexPrimaryKey($class))
#if (!$primaryKeyAttribute.complex)
#set ($primKey = $primaryKeyAttribute)
#if ($primKey.type == "java.lang.String")
        if ($primKey.name == null) {
            $primKey.name = new java.rmi.server.UID().toString();
        }

#end
#end
#foreach ( $att in $instanceAttributes)
        set${str.upperCaseFirstLetter(${att.name})}(${att.name});
#end
    }

## Only generate create methods with all CMP and CMR fields for concrete EJBs, 
## and only if it is not explicitly switched off
#if (!$class.abstract && !$class.findTaggedValue("@andromda.ejb.noSyntheticCreateMethod"))
    /**
     * Create method with all CMP attribute values.
#foreach($att in $allAttributes)
     * @param $att.name Value for the ${att.name} property
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP 
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $pkclassname ejbCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
        ejbCreateImpl($transform.getAttributesAsList($allAttributes, false, true));
        return null;
    }
#end

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!$inheritedAttributes.empty)
        // Call postCreate method for the super type
        super.ejbPostCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
    }
#set ($relations = $class.allEntityRelations)
#if (!$relations.isEmpty())
#if (!$class.abstract && !$class.findTaggedValue("@andromda.ejb.noSyntheticCreateMethod"))
    /**
     * Create method with all CMP attribute values and CMR relations.
#foreach($att in $allAttributes)
     * @param $att.name Value for the ${att.name} property
#end
#foreach ($rel in $relations)
     * @param $rel.otherEnd.name Value for the ${rel.otherEnd.name} relation role
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     * @return <code>null</code> as required by the EJB specification for CMP 
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $pkclassname ejbCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.isEmpty()), #end#foreach ($rel in $relations)${rel.relationType} $rel.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
           throws javax.ejb.CreateException
    {
        // Call ejbCreate method for the CMP attributes
        ejbCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Relations cannot be set in ejbCreate() - this is done in ejbPostCreate()
        return null;
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.isEmpty()), #end#foreach ($rel in $relations)${rel.relationType} $rel.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
           throws javax.ejb.CreateException
    {
        // Call postCreate method for the CMP attributes
        ejbPostCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Set the CMR relations
#foreach ($rel in $relations)
        set${str.upperCaseFirstLetter($rel.otherEnd.name)}($rel.otherEnd.name);
#end
    }
#end
#end
    // ---------------- accessor methods for bean references ---------------

#foreach ( $dep in $class.dependencies )
#set ($viewtype = "")
#if ($dep.hasStereotype("EntityRef") || $dep.hasStereotype("ServiceRef"))
#set ($referencedClass = $dep.targetElement)
#set ($viewtype = $referencedClass.findTaggedValue("@andromda.ejb.viewType"))
#if ($viewtype == "")
#set ($viewtype = $referencedClass.viewType)
#end
#if ($viewtype == "local")
#set ($homeInterfaceName = "${referencedClass.name}LocalHome")
#set ($fqHomeInterfaceName = "${referencedClass.fullyQualifiedName}LocalHome")
    /**
     * Get the local home interface of the ${referencedClass.name} bean.
     * The home interface is obtained from the initial context 
     * by looking up the bean reference name.
     * @return local home interface for ${referencedClass.name}. 
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            // Local homes shouldn't be narrowed, as there is no RMI involved.
            ${fqHomeInterfaceName} home = 
                (${fqHomeInterfaceName}) initialContext.lookup("java:/comp/env/ejb/${referencedClass.name}BeanRef");
            return home;
        } finally {
            initialContext.close();
        }
    }
#end
#if ($viewtype == "remote")
#set ($homeInterfaceName = "${referencedClass.name}Home")
#set ($fqHomeInterfaceName = "${referencedClass.fullyQualifiedName}Home")
    /**
     * Get the remote home interface of the ${referencedClass.name} bean.
     * The home interface is obtained from the initial context 
     * by looking up the bean reference name.
     * @return remote home interface for ${referencedClass.name}. Lookup using bean ref name.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            Object home = 
                 initialContext.lookup("java:/comp/env/ejb/${referencedClass.name}BeanRef");
            return ($fqHomeInterfaceName) 
                   javax.rmi.PortableRemoteObject.narrow(home, 
                   ${fqHomeInterfaceName}.class);
        } finally {
            initialContext.close();
        }
    }
#end
#end
#if ($dep.hasStereotype("ResourceRef"))
#set ($referencedClass = $dep.targetElement)
#set ($resClassName = "$referencedClass.fullyQualifiedName")
#set ($resName = $dep.name)
#if (!$resName || $resName == "")
#set ($resName = $referencedClass.name)
#end
    /**
     * Get the ${resName} resource. 
     * The resource is obtained by looking up
     * <code>java:/comp/env/resource/$resName</code> in JNDI
     * @return the ${resName} resource
     */
    protected static ${resClassName} get${str.upperCaseFirstLetter($resName)}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            Object resource = 
                 initialContext.lookup("java:/comp/env/resource/$resName");
            return ($resClassName) resource;
        } finally {
            initialContext.close();
        }
    }
#end
#end

}
