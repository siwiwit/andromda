/* Autogenerated by AndroMDA (EntityLocalIntf.vsl) - do not edit */
## Include global definitions. ##
#parse("templates/EJBglobals.vm")
##
#if ($superclass)
#if ($superclass.hasStereotype("Entity"))
## Extend the component interface of the super type if the super type
## is an <<Entity>>
#set ($parentInterface = "${superclass.fullyQualifiedName}")
#end
#end
#if (!$parentInterface)
#set ($parentInterface = "javax.ejb.EJBLocalObject")
#end

##################################################################################
##                         The actual template starts here                      ##
##################################################################################
package $packagename;

/**
 * Local component interface for the $entityname entity bean.
$class.getDocumentation(" * ")
 *
#copyTaggedValues($class " " [ "@andromda.ejb.viewType", "@andromda.ejb.transactionType", "@andromda.ejb.noSyntheticCreateMethod" ])
 *
 */
public interface ${entityname}
extends $parentInterface
        #foreach($intf in $class.abstractions),
        $intf.fullyQualifiedName#end

{

    // -- accessors for environment entries --
#foreach($envEntry in $class.getEnvironmentEntries(true))
#if($envEntry.visibility == "public")
    /**
     * Get the ${envEntry.name} environment entry
$envEntry.getDocumentation("     * ")
     */
    public $envEntry.type.fullyQualifiedName ${envEntry.type.getterName}();

#end
#end
// -- accessors for constants --
#foreach($constant in $class.constants)
## Only expose the method to the home interface if it is public.
#if($constant.visibility == "public")
    /**
     * Get the $att.name constant
$constant.getDocumentation("     * ")
     */
    public $constant.type.fullyQualifiedName ${constant.getterName}();

#end
#end

    // ------------- attributes ----------------

#foreach ( $att in $class.instanceAttributes)
#set ($visibility = $att.visibility.toString())
## Only expose the method to the component interface if it is public.
#if($visibility == "public")
#set($attType = $att.type.fullyQualifiedName)
    /**
     * Get the ${att.name} property
$att.getDocumentation("     * ")
     */
    public $attType ${att.getterName}();

#if(!$att.readOnly)
    /**
     * Set the ${att.name} property
     * @param value the new value
     */
    public void ${att.setterName}($attType value);

#end
#end
#end

    // ------------- relations ------------------

#foreach ( $assoc in $class.entityRelations)
#set ($target = $assoc.otherEnd)
#set ($assocname = $assoc.association.name)
#set ($targetTypeName = $assoc.relationType)

   /**
    * Get the ${assoc.otherEnd.name}
$assoc.otherEnd.getDocumentation("    * ")
    */
    public $targetTypeName ${target.getterName}();

   /**
    * Set the ${assoc.otherEnd.name}
    */
    public void ${target.setterName}($targetTypeName ${assoc.otherEnd.name});
#end ## foreach

    // ---------------- business methods  ----------------------

#foreach ( $op in $class.operations)
#if (!$op.hasStereotype("FinderMethod") && !$op.hasStereotype("CreateMethod") && !$op.hasStereotype("SelectMethod"))
#set ($visibility = $op.visibility.toString())
## Only expose public, nonstatic methods (public static methods go on the home
## interface)
#if ($visibility == "public" && !$op.static)
#set ($msig = $op.signature)
   /**
$op.getDocumentation("    * ")
    */
#set ($returntype = $op.returnType.fullyQualifiedName)
#if ($op.hasExceptions())
    public $returntype ${msig} throws $op.exceptionList;
#else
    $visibility $returntype ${msig};
#end
#end
#end
#end

}
