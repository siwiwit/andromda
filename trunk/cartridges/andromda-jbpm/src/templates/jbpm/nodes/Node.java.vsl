#set ($generatedFile = "${node.nodeClassName}.java")
#if ($stringUtils.isNotBlank($node.nodePackageName))
#set ($generatedFile = "$stringUtils.replace($node.nodePackageName,'.','/')/$generatedFile")
package $node.nodePackageName;

#end
public final class $node.nodeClassName implements $node.processDefinition.nodeInterfaceName
{
    private final org.jbpm.graph.exe.Token token = null;

#if (!$node.initialState)
    ${node.nodeClassName}(final org.jbpm.graph.exe.Token token)
    {
        this.token = token;
    }

#end
#if ($node.initialState)
    /**
     * Creates a new process instance for the corresponding process definition.
     *
     * @return java.lang.Long the id of the newly created process
     */
    public java.lang.Long startProcess()
    {
        // open up the JBpm session
        final JbpmSession session = JbpmSessionFactory.getInstance().openJbpmSession();

        // the graph session allows us to work with the process definition
        final GraphSession graphSession = session.getGraphSession();

        // find the latest process definition we can use
        final ProcessDefinition processDefinition =
                graphSession.findLatestProcessDefinition("$node.processDefinition.descriptorFullPath");

        // create a new process
        final ProcessInstance processInstance = processDefinition.createProcessInstance();

        // we signal the token (which is in the start state to go to the next node)
        this.token = processInstance.getRootToken();

        // return the process id
        return new java.lang.Long(processInstance.getId());
    }

    public $node.processDefinition.nodeInterfaceName signal()
    {
        this.token.signal();
        return new ${node.outgoing.iterator().next().target.nodeClassName}(this.token);
    }

#elseif ($node.finalState)
    public void endProcess()
    {
        this.token.end();
        this.token.getProcessInstance().end();
    }

#elseif ($node.taskNode)
#foreach ($task in $node.tasks)
#set ($taskName = $stringUtils.upperCamelCaseName($task.name))
    public void start${taskName}Task()
    {
        final org.jbpm.taskmgmt.exe.TaskInstance task = this.get${taskName}Task();
        if (task != null)
        {
            task.start();
        }
    }

    public void finish${taskName}Task()
    {
        final org.jbpm.taskmgmt.exe.TaskInstance task = this.get${taskName}Task();
        if (task != null)
        {
            task.end();
        }
    }

    public boolean is${taskName}TaskFinished()
    {
        final org.jbpm.taskmgmt.exe.TaskInstance task = this.get${taskName}Task();
        return task == null ? true : task.hasEnded();
    }

#set ($taskField = "task${taskName}")
    private org.jbpm.taskmgmt.exe.TaskInstance $taskField = null;

    org.jbpm.taskmgmt.exe.TaskInstance get${taskName}Task()
    {
        if (this.$taskField == null)
        {
            final java.util.Collection tasks = this.token.getProcessInstance().getTaskMgmtInstance().getTaskInstances(token);
            for (final java.util.Iterator taskIterator = tasks.iterator(); taskIterator.hasNext() && this.$taskField == null;)
            {
                final org.jbpm.taskmgmt.exe.TaskInstance taskInstance = (org.jbpm.taskmgmt.exe.TaskInstance)taskIterator.next();
                if ("$task.name".equals(taskInstance.getName())
                {
                    this.$taskField = taskInstance;
                }
            }
        }
        return this.$taskField;
    }

#end
#if ($node.outgoing.size() == 1)
    public $node.processDefinition.nodeInterfaceName signal()
    {
        this.token.signal();
        return new ${node.outgoing.iterator().next().target.nodeClassName}(this.token);
    }

#else
#foreach ($transition in $node.outgoing)
    public $node.processDefinition.nodeInterfaceName signal(java.lang.String transitionName)
    {
        this.token.signal(transitionName);
        return new ${transition.target.nodeClassName}(this.token);
    }

#end
#end
#end
}