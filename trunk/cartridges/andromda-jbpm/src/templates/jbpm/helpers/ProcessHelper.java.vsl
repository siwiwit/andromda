#set ($className = "$stringUtils.upperCamelCaseName($processDefinition.name)")
#set ($className = "${className}Helper")
#set ($generatedFile = "${className}.java")
#set ($packageName = $processDefinition.packageName)
#if ($stringUtils.isNotBlank($packageName))
#set ($generatedFile = "${processDefinition.packagePath}/${generatedFile}")
##
##
##
#macro (renderLocator $state)
#if ($state.name)
#set ($methodName = "is$stringUtils.upperCamelCaseName($state.nodeClassName)")
    public static boolean ${methodName}(final $processDefinition.nodeInterfaceName node)
    {
        return node instanceof ${state.nodeClassName};
    }

#end
#end
##
##
##
#macro (renderNodeTest $state)
#if ($state.name)
        if ("$state.name".equals(nodeName)) currentNode = new ${state.nodeClassName}(token); else
#end
#end
##
##
##
package $packageName;

#end
/**
 * This helper class provides static utility methods to more easily handle
 * the jBPM process API for the '$processDefinition.name' process.
 */
public class $className
{
    public static final java.lang.String PROCESS_NAME = "$processDefinition.name";

#if ($processDefinition.startState)
    public static $processDefinition.startState.nodeClassName startProcess()
    {
        // open up the JBpm session
        final org.jbpm.db.JbpmSession session = org.jbpm.db.JbpmSessionFactory.getInstance().openJbpmSession();

        // the graph session allows us to work with the process definition
        final org.jbpm.db.GraphSession graphSession = session.getGraphSession();

        // find the latest process definition we can use
        final org.jbpm.graph.def.ProcessDefinition processDefinition =
                graphSession.findLatestProcessDefinition("$processDefinition.descriptorFullPath");

        // create a new process
        final org.jbpm.graph.exe.ProcessInstance processInstance = processDefinition.createProcessInstance();

        // return the first node in the process
        return new ${processDefinition.startState.nodeClassName}(processInstance.getRootToken());
    }

#end
    public static $processDefinition.nodeInterfaceName getProcess(final java.lang.Long processInstanceId)
    {
        // open up the JBpm session
        final org.jbpm.db.JbpmSession session = org.jbpm.db.JbpmSessionFactory.getInstance().openJbpmSession();

        // the graph session allows us to work with the process definition
        final org.jbpm.db.GraphSession graphSession = session.getGraphSession();

        // load the process using the unique identifier argument
        final org.jbpm.graph.exe.ProcessInstance processInstance = graphSession.loadProcessInstance(processInstanceId.longValue());

        // the token for this process instance
        final org.jbpm.graph.exe.Token token = processInstance.getRootToken();

        // find the node we're in
        $processDefinition.nodeInterfaceName currentNode = null;
        final String nodeName = token.getNode().getName();
#if ($processDefinition.startState)
#renderNodeTest($processDefinition.startState)
#end
#foreach ($state in $processDefinition.states)
#renderNodeTest($state)
#end
#foreach ($state in $processDefinition.taskNodes)
#renderNodeTest($state)
#end
#foreach ($state in $processDefinition.nodes)
#renderNodeTest($state)
#end
#foreach ($state in $processDefinition.decisions)
#renderNodeTest($state)
#end
#foreach ($state in $processDefinition.joins)
#renderNodeTest($state)
#end
#foreach ($state in $processDefinition.forks)
#renderNodeTest($state)
#end
#foreach ($state in $processDefinition.endStates)
#renderNodeTest($state)
#end
        throw new IllegalArgumentException("No matching node could be found for the process instance");

        return currentNode;
    }

#if ($processDefinition.taskNodes)
#foreach ($task in $processDefinition.tasks)
#if ($task.name)
    public static final String TASK_$stringUtils.separate($task.name,"_").toUpperCase()_NAME = "$task.name";
#end
#end

#end
#if ($processDefinition.startState)
#renderLocator($processDefinition.startState)
#end
#foreach ($state in $processDefinition.states)
#renderLocator($state)
#end
#foreach ($state in $processDefinition.taskNodes)
#renderLocator($state)
#end
#foreach ($state in $processDefinition.nodes)
#renderLocator($state)
#end
#foreach ($state in $processDefinition.decisions)
#renderLocator($state)
#end
#foreach ($state in $processDefinition.joins)
#renderLocator($state)
#end
#foreach ($state in $processDefinition.forks)
#renderLocator($state)
#end
#foreach ($state in $processDefinition.endStates)
#renderLocator($state)
#end
}

