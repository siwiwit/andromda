// license-header java merge-point
/* Autogenerated by AndroMDA (SessionBean.vsl) - do not edit */
#if ($stringUtils.isNotBlank($service.packageName))
package $service.packageName;
#end

/**
 * Autogenerated EJB entity POJO class for the ${service.serviceName} session bean.
 *
$service.getDocumentation(" * ")
 *
 *
 */
@javax.ejb.${service.type}
#if ($service.transactionType)
@javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${service.transactionType})
#end
@javax.ejb.CallbackListener(${service.fullyQualifiedServiceListenerName}.class)
#if ($service.securityDomain)
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.security.SecurityDomain("${service.securityDomain}")
#**##end
#end
#if ($service.permitAll)
@javax.annotation.security.PermitAll
#elseif ($service.rolesAllowed)
@javax.annotation.security.RolesAllowed({${service.rolesAllowed}})
#end
public abstract class ${service.serviceName}
#if($service.generalization)
    extends ${service.generalization.fullyQualifiedName}BeanImpl
#end
    implements ${service.fullyQualifiedServiceLocalInterfaceName},  ${service.fullyQualifiedServiceRemoteInterfaceName}
{
    // ------ Session Context Injection ------
    
    @javax.annotation.Resource
    javax.ejb.SessionContext context;

    // ------ Persistence Context Definitions --------
    
#set ($argExists = false)
    /**
     * Inject persistence context #if ($service.persistenceContextUnitName)${service.persistenceContextUnitName}#end
     
     */
    @javax.persistence.PersistenceContext#if ($service.persistenceContextUnitName || $service.persistenceContextType)(#end#if ($service.persistenceContextUnitName)unitName = "${service.persistenceContextUnitName}"#set ($argExists = true)#end#if ($service.persistenceContextType)#if ($argExists),#end type = javax.persistence.PersistenceContextType.${service.persistenceContextType}#end#if ($service.persistenceContextUnitName || $service.persistenceContextType))#end
    
    protected javax.persistence.EntityManager emanager;
#foreach ($reference in $service.persistenceContextReferences)
#**##set ($persistenceContext = $reference.targetElement)
#**##set ($argExists = false)

    /**
     * Inject persistence context #if ($persistenceContext.persistenceContextUnitName)${persistenceContext.persistenceContextUnitName}#end
     
     */
    @javax.persistence.PersistenceContext#if ($persistenceContext.persistenceContextUnitName || $persistenceContext.persistenceContextType)(#end#if ($persistenceContext.persistenceContextUnitName)unitName = "${persistenceContext.persistenceContextUnitName}"#set ($argExists = true)#end#if ($persistenceContext.persistenceContextType)#if ($argExists),#end type = javax.persistence.PersistenceContextType.${persistenceContext.persistenceContextType}#end#if ($persistenceContext.persistenceContextUnitName || $persistenceContext.persistenceContextType))#end 
    protected javax.persistence.EntityManager ${persistenceContext.name};
#end
#set ($references = $service.serviceReferences)
#if (!$references.empty)
#**##foreach ($dependency in $references)
#*  *##set ($reference = $dependency.targetElement)

    // ------ EJB Injection Definitions --------

    /**
     * Inject session EJB ${reference.name};
     */
    @javax.annotation.EJB
    protected ${reference.fullyQualifiedServiceName} $stringUtils.uncapitalize(${reference.name});
#**##end
#end
#set ($constants = $service.getConstants(true))
#if (!$constants.empty)

    // ----------- Constant Definitions -----------
    
#**##foreach($constant in $constants)
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#**##end
#end
#set ($instanceAttributes = $service.instanceAttributes)
#if(!$instanceAttributes.empty)

    // ------------ Attributes ------------------
    
#**##foreach ($attribute in $instanceAttributes)
    /** The $attribute.name property */
    private $attribute.type.fullyQualifiedName $attribute.name;
#**##end
#end
    
    // --------------- Constructors ---------------
    
## Default create method with no arguments.
    public ${service.serviceName}()
    {
        super();
    }
## Autogenerated create method with all attributes. Only present for stateful beans.
#set ($allAttributes = $service.allInstanceAttributes)
#if (!$allAttributes.empty)

    /**
     * Constructor with all attribute values.
#**##set ($inheritedAttributes = $service.inheritedInstanceAttributes)
#**##foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#**##end
     */
    public ${service.serviceName}($service.getAttributesAsList($allAttributes, true, true))
    {
#**##if(!$inheritedAttributes.empty)
        super($service.getAttributesAsList($inheritedAttributes, false, true));
#**##end
#**##foreach ($attribute in $service.instanceAttributes)
## Don't use a setter here - we may have none if the attribute is marked readonly
        this.$attribute.name = $attribute.name;
#**##end
    }
#end
#if (!$constants.empty)

    // --------- Accessors for Constants ----------
    
#**##foreach($constant in $constants)
#*  *##if ($constant.visibility == "public")
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
     */
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }
    
#*  *##end
#**##end
#end
#if(!$instanceAttributes.empty)

    // ------- Accessors for Attributes ----------
    
#**##foreach ($attribute in $instanceAttributes)
#*  *##set ($visibility = $attribute.visibility)
#*  *##if ($visibility == "public")
    /**
     * Get the ${attribute.name} property
$attribute.getDocumentation("     * ")
     */
#*    *##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#*    *##end
    $visibility $attribute.type.fullyQualifiedName ${attribute.getterName}() 
    {
       return $attribute.name;
    }
## Only generate a setter if the attribute is not read-only
#*    *##if (!$attribute.readOnly)

    /**
     * Set the $attribute.name property
     * @param value the new value
     */
#*      *##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#*      *##end
    $visibility void ${attribute.setterName}($attribute.type.fullyQualifiedName value) 
    {
       this.$attribute.name = value;
    }

#*    *##end
#*  *##end
#**##end
#end
#set ($operations = $service.businessOperations)
#if (!$operations.empty)

    // -------- Business Methods  --------------
    
#**##foreach ($operation in $operations)
#*  *##set ($visibility = $operation.visibility)
#*  *##if ($visibility == "public")
    /**
$operation.getDocumentation("     * ")
## Only public methods have transactions and are exported to the interfaces
     */
#*    *##if ($operation.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${operation.transactionType})
#*    *##end
#*    *##if ($operation.permitAll)
    @javax.annotation.security.PermitAll
#*    *##elseif ($operation.rolesAllowed)
    @javax.annotation.security.RolesAllowed({${operation.rolesAllowed}})
#*    *##end
#*    *##set ($returnType = $operation.returnType.fullyQualifiedName)
#*    *##if ($operation.exceptionsPresent)
    $visibility abstract $returnType $operation.signature throws $operation.exceptionList;
#*    *##else
    $visibility abstract $returnType $operation.signature;
#*    *##end

#*  *##end
#**##end
#end
}