// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\FormImpl.java.vsl) on 07/30/2011 09:32:37-0300
package org.andromda.cartridges.jsf.tests.tables.tablelink;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.faces.application.FacesMessage;
import javax.faces.event.ActionEvent;
import javax.faces.event.FacesEvent;
import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import org.apache.commons.beanutils.PropertyUtils;

/**
 * 
 */
public class ShowTableDataDuplicateGlobalTableActionFormImpl
    implements Serializable
{
    /**
     * Default constructor
     */
    public ShowTableDataDuplicateGlobalTableActionFormImpl()
    {
        // - setup the default java.util.Date.toString() formatter
        final DateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);
    }

    private transient FacesEvent event;

    /**
     * @param eventIn
     */
    public void setEvent(FacesEvent eventIn)
    {
        this.event = eventIn;
    }

    /**
     * @return ValueChangeEvent
     */
    public ValueChangeEvent getValueChangeEvent()
    {
        return this.event instanceof ValueChangeEvent
            ? (ValueChangeEvent)this.event : null;
    }

    /**
     * @return ActionEvent
     */
    public ActionEvent getActionEvent()
    {
        return this.event instanceof ActionEvent
            ? (ActionEvent)this.event : null;
    }

    // Action table-link-activity-duplicate-global-table-action formFields

    private Collection tableDatas;

    /**
     * 
     * @return tableDatas 
     */
    public Collection getTableDatas()
    {
        return this.tableDatas;
    }

    /**
     * Keeps track of whether or not the value of tableDatas has
     * be populated at least once.
     */
    private boolean tableDatasSet = false;

    /**
     * Resets the value of the tableDatasSet to false
     */
    public void resetTableDatasSet()
    {
        this.tableDatasSet = false;
    }

    /**
     * Indicates whether or not the value for tableDatas has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTableDatasSet()
    {
        return this.tableDatasSet;
    }

    /**
     * 
     * @param tableDatasIn 
     */
    public void setTableDatas(Collection tableDatasIn)
    {
        this.tableDatas = tableDatasIn;
        this.tableDatasSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] tableDatasValueList;

    /**
     * Stores the labels
     */
    private Object[] tableDatasLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTableDatasBackingList()
    {
        Object[] values = this.tableDatasValueList;
        Object[] labels = this.tableDatasLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return tableDatasValueList
     */
    public Object[] getTableDatasValueList()
    {
        return this.tableDatasValueList;
    }

    /**
     * @param tableDatasValueListIn
     */
    public void setTableDatasValueList(Object[] tableDatasValueListIn)
    {
        this.tableDatasValueList = tableDatasValueListIn;
    }

    /**
     * @return tableDatasLabelList Object[]
     */
    public Object[] getTableDatasLabelList()
    {
        return this.tableDatasLabelList;
    }

    /**
     * @param tableDatasLabelListIn
     */
    public void setTableDatasLabelList(Object[] tableDatasLabelListIn)
    {
        this.tableDatasLabelList = tableDatasLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTableDatasBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.tableDatasValueList = null;
        this.tableDatasLabelList = null;
        if (items != null)
        {
            this.tableDatasValueList = new Object[items.size()];
            this.tableDatasLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.tableDatasValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.tableDatasLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.tableDatasLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection tableDatasBackingValue;

    /**
     * @param tableDatasBackingValueIn
     */
    public void setTableDatasBackingValue(Collection tableDatasBackingValueIn)
    {
        this.tableDatasBackingValue = tableDatasBackingValueIn;
    }

    /**
     * @return tableDatasBackingValue
     */
    public Collection getTableDatasBackingValue()
    {
        return this.tableDatasBackingValue;
    }


    private String[] multiboxThings;

    /**
     * 
     * @return multiboxThings 
     */
    public String[] getMultiboxThings()
    {
        return this.multiboxThings;
    }

    /**
     * Keeps track of whether or not the value of multiboxThings has
     * be populated at least once.
     */
    private boolean multiboxThingsSet = false;

    /**
     * Resets the value of the multiboxThingsSet to false
     */
    public void resetMultiboxThingsSet()
    {
        this.multiboxThingsSet = false;
    }

    /**
     * Indicates whether or not the value for multiboxThings has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMultiboxThingsSet()
    {
        return this.multiboxThingsSet;
    }

    /**
     * 
     * @param multiboxThingsIn 
     */
    public void setMultiboxThings(String[] multiboxThingsIn)
    {
        this.multiboxThings = multiboxThingsIn;
        this.multiboxThingsSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] multiboxThingsValueList;

    /**
     * Stores the labels
     */
    private Object[] multiboxThingsLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMultiboxThingsBackingList()
    {
        Object[] values = this.multiboxThingsValueList;
        Object[] labels = this.multiboxThingsLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return multiboxThingsValueList
     */
    public Object[] getMultiboxThingsValueList()
    {
        return this.multiboxThingsValueList;
    }

    /**
     * @param multiboxThingsValueListIn
     */
    public void setMultiboxThingsValueList(Object[] multiboxThingsValueListIn)
    {
        this.multiboxThingsValueList = multiboxThingsValueListIn;
    }

    /**
     * @return multiboxThingsLabelList Object[]
     */
    public Object[] getMultiboxThingsLabelList()
    {
        return this.multiboxThingsLabelList;
    }

    /**
     * @param multiboxThingsLabelListIn
     */
    public void setMultiboxThingsLabelList(Object[] multiboxThingsLabelListIn)
    {
        this.multiboxThingsLabelList = multiboxThingsLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMultiboxThingsBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.multiboxThingsValueList = null;
        this.multiboxThingsLabelList = null;
        if (items != null)
        {
            this.multiboxThingsValueList = new Object[items.size()];
            this.multiboxThingsLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.multiboxThingsValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.multiboxThingsLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.multiboxThingsLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private String[] multiboxThingsBackingValue;

    /**
     * @param multiboxThingsBackingValueIn
     */
    public void setMultiboxThingsBackingValue(String[] multiboxThingsBackingValueIn)
    {
        this.multiboxThingsBackingValue = multiboxThingsBackingValueIn;
    }

    /**
     * @return multiboxThingsBackingValue
     */
    public String[] getMultiboxThingsBackingValue()
    {
        return this.multiboxThingsBackingValue;
    }


    private Collection tableDataDefaultExportTypes;

    /**
     * 
     * @return tableDataDefaultExportTypes 
     */
    public Collection getTableDataDefaultExportTypes()
    {
        return this.tableDataDefaultExportTypes;
    }

    /**
     * Keeps track of whether or not the value of tableDataDefaultExportTypes has
     * be populated at least once.
     */
    private boolean tableDataDefaultExportTypesSet = false;

    /**
     * Resets the value of the tableDataDefaultExportTypesSet to false
     */
    public void resetTableDataDefaultExportTypesSet()
    {
        this.tableDataDefaultExportTypesSet = false;
    }

    /**
     * Indicates whether or not the value for tableDataDefaultExportTypes has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTableDataDefaultExportTypesSet()
    {
        return this.tableDataDefaultExportTypesSet;
    }

    /**
     * 
     * @param tableDataDefaultExportTypesIn 
     */
    public void setTableDataDefaultExportTypes(Collection tableDataDefaultExportTypesIn)
    {
        this.tableDataDefaultExportTypes = tableDataDefaultExportTypesIn;
        this.tableDataDefaultExportTypesSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] tableDataDefaultExportTypesValueList;

    /**
     * Stores the labels
     */
    private Object[] tableDataDefaultExportTypesLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTableDataDefaultExportTypesBackingList()
    {
        Object[] values = this.tableDataDefaultExportTypesValueList;
        Object[] labels = this.tableDataDefaultExportTypesLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return tableDataDefaultExportTypesValueList
     */
    public Object[] getTableDataDefaultExportTypesValueList()
    {
        return this.tableDataDefaultExportTypesValueList;
    }

    /**
     * @param tableDataDefaultExportTypesValueListIn
     */
    public void setTableDataDefaultExportTypesValueList(Object[] tableDataDefaultExportTypesValueListIn)
    {
        this.tableDataDefaultExportTypesValueList = tableDataDefaultExportTypesValueListIn;
    }

    /**
     * @return tableDataDefaultExportTypesLabelList Object[]
     */
    public Object[] getTableDataDefaultExportTypesLabelList()
    {
        return this.tableDataDefaultExportTypesLabelList;
    }

    /**
     * @param tableDataDefaultExportTypesLabelListIn
     */
    public void setTableDataDefaultExportTypesLabelList(Object[] tableDataDefaultExportTypesLabelListIn)
    {
        this.tableDataDefaultExportTypesLabelList = tableDataDefaultExportTypesLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTableDataDefaultExportTypesBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.tableDataDefaultExportTypesValueList = null;
        this.tableDataDefaultExportTypesLabelList = null;
        if (items != null)
        {
            this.tableDataDefaultExportTypesValueList = new Object[items.size()];
            this.tableDataDefaultExportTypesLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.tableDataDefaultExportTypesValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.tableDataDefaultExportTypesLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.tableDataDefaultExportTypesLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection tableDataDefaultExportTypesBackingValue;

    /**
     * @param tableDataDefaultExportTypesBackingValueIn
     */
    public void setTableDataDefaultExportTypesBackingValue(Collection tableDataDefaultExportTypesBackingValueIn)
    {
        this.tableDataDefaultExportTypesBackingValue = tableDataDefaultExportTypesBackingValueIn;
    }

    /**
     * @return tableDataDefaultExportTypesBackingValue
     */
    public Collection getTableDataDefaultExportTypesBackingValue()
    {
        return this.tableDataDefaultExportTypesBackingValue;
    }


    private Collection tableDataNoExportTypes;

    /**
     * 
     * @return tableDataNoExportTypes 
     */
    public Collection getTableDataNoExportTypes()
    {
        return this.tableDataNoExportTypes;
    }

    /**
     * Keeps track of whether or not the value of tableDataNoExportTypes has
     * be populated at least once.
     */
    private boolean tableDataNoExportTypesSet = false;

    /**
     * Resets the value of the tableDataNoExportTypesSet to false
     */
    public void resetTableDataNoExportTypesSet()
    {
        this.tableDataNoExportTypesSet = false;
    }

    /**
     * Indicates whether or not the value for tableDataNoExportTypes has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTableDataNoExportTypesSet()
    {
        return this.tableDataNoExportTypesSet;
    }

    /**
     * 
     * @param tableDataNoExportTypesIn 
     */
    public void setTableDataNoExportTypes(Collection tableDataNoExportTypesIn)
    {
        this.tableDataNoExportTypes = tableDataNoExportTypesIn;
        this.tableDataNoExportTypesSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] tableDataNoExportTypesValueList;

    /**
     * Stores the labels
     */
    private Object[] tableDataNoExportTypesLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTableDataNoExportTypesBackingList()
    {
        Object[] values = this.tableDataNoExportTypesValueList;
        Object[] labels = this.tableDataNoExportTypesLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return tableDataNoExportTypesValueList
     */
    public Object[] getTableDataNoExportTypesValueList()
    {
        return this.tableDataNoExportTypesValueList;
    }

    /**
     * @param tableDataNoExportTypesValueListIn
     */
    public void setTableDataNoExportTypesValueList(Object[] tableDataNoExportTypesValueListIn)
    {
        this.tableDataNoExportTypesValueList = tableDataNoExportTypesValueListIn;
    }

    /**
     * @return tableDataNoExportTypesLabelList Object[]
     */
    public Object[] getTableDataNoExportTypesLabelList()
    {
        return this.tableDataNoExportTypesLabelList;
    }

    /**
     * @param tableDataNoExportTypesLabelListIn
     */
    public void setTableDataNoExportTypesLabelList(Object[] tableDataNoExportTypesLabelListIn)
    {
        this.tableDataNoExportTypesLabelList = tableDataNoExportTypesLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTableDataNoExportTypesBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.tableDataNoExportTypesValueList = null;
        this.tableDataNoExportTypesLabelList = null;
        if (items != null)
        {
            this.tableDataNoExportTypesValueList = new Object[items.size()];
            this.tableDataNoExportTypesLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.tableDataNoExportTypesValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.tableDataNoExportTypesLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.tableDataNoExportTypesLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection tableDataNoExportTypesBackingValue;

    /**
     * @param tableDataNoExportTypesBackingValueIn
     */
    public void setTableDataNoExportTypesBackingValue(Collection tableDataNoExportTypesBackingValueIn)
    {
        this.tableDataNoExportTypesBackingValue = tableDataNoExportTypesBackingValueIn;
    }

    /**
     * @return tableDataNoExportTypesBackingValue
     */
    public Collection getTableDataNoExportTypesBackingValue()
    {
        return this.tableDataNoExportTypesBackingValue;
    }


    private Collection tableDataNotSortables;

    /**
     * 
     * @return tableDataNotSortables 
     */
    public Collection getTableDataNotSortables()
    {
        return this.tableDataNotSortables;
    }

    /**
     * Keeps track of whether or not the value of tableDataNotSortables has
     * be populated at least once.
     */
    private boolean tableDataNotSortablesSet = false;

    /**
     * Resets the value of the tableDataNotSortablesSet to false
     */
    public void resetTableDataNotSortablesSet()
    {
        this.tableDataNotSortablesSet = false;
    }

    /**
     * Indicates whether or not the value for tableDataNotSortables has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTableDataNotSortablesSet()
    {
        return this.tableDataNotSortablesSet;
    }

    /**
     * 
     * @param tableDataNotSortablesIn 
     */
    public void setTableDataNotSortables(Collection tableDataNotSortablesIn)
    {
        this.tableDataNotSortables = tableDataNotSortablesIn;
        this.tableDataNotSortablesSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] tableDataNotSortablesValueList;

    /**
     * Stores the labels
     */
    private Object[] tableDataNotSortablesLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTableDataNotSortablesBackingList()
    {
        Object[] values = this.tableDataNotSortablesValueList;
        Object[] labels = this.tableDataNotSortablesLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return tableDataNotSortablesValueList
     */
    public Object[] getTableDataNotSortablesValueList()
    {
        return this.tableDataNotSortablesValueList;
    }

    /**
     * @param tableDataNotSortablesValueListIn
     */
    public void setTableDataNotSortablesValueList(Object[] tableDataNotSortablesValueListIn)
    {
        this.tableDataNotSortablesValueList = tableDataNotSortablesValueListIn;
    }

    /**
     * @return tableDataNotSortablesLabelList Object[]
     */
    public Object[] getTableDataNotSortablesLabelList()
    {
        return this.tableDataNotSortablesLabelList;
    }

    /**
     * @param tableDataNotSortablesLabelListIn
     */
    public void setTableDataNotSortablesLabelList(Object[] tableDataNotSortablesLabelListIn)
    {
        this.tableDataNotSortablesLabelList = tableDataNotSortablesLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTableDataNotSortablesBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.tableDataNotSortablesValueList = null;
        this.tableDataNotSortablesLabelList = null;
        if (items != null)
        {
            this.tableDataNotSortablesValueList = new Object[items.size()];
            this.tableDataNotSortablesLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.tableDataNotSortablesValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.tableDataNotSortablesLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.tableDataNotSortablesLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection tableDataNotSortablesBackingValue;

    /**
     * @param tableDataNotSortablesBackingValueIn
     */
    public void setTableDataNotSortablesBackingValue(Collection tableDataNotSortablesBackingValueIn)
    {
        this.tableDataNotSortablesBackingValue = tableDataNotSortablesBackingValueIn;
    }

    /**
     * @return tableDataNotSortablesBackingValue
     */
    public Collection getTableDataNotSortablesBackingValue()
    {
        return this.tableDataNotSortablesBackingValue;
    }


    private int first;

    /**
     * 
     * @return first 
     */
    public int getFirst()
    {
        return this.first;
    }

    /**
     * Keeps track of whether or not the value of first has
     * be populated at least once.
     */
    private boolean firstSet = false;

    /**
     * Resets the value of the firstSet to false
     */
    public void resetFirstSet()
    {
        this.firstSet = false;
    }

    /**
     * Indicates whether or not the value for first has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFirstSet()
    {
        return this.firstSet;
    }

    /**
     * 
     * @param firstIn 
     */
    public void setFirst(int firstIn)
    {
        this.first = firstIn;
        this.firstSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] firstValueList;

    /**
     * Stores the labels
     */
    private Object[] firstLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFirstBackingList()
    {
        Object[] values = this.firstValueList;
        Object[] labels = this.firstLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return firstValueList
     */
    public Object[] getFirstValueList()
    {
        return this.firstValueList;
    }

    /**
     * @param firstValueListIn
     */
    public void setFirstValueList(Object[] firstValueListIn)
    {
        this.firstValueList = firstValueListIn;
    }

    /**
     * @return firstLabelList Object[]
     */
    public Object[] getFirstLabelList()
    {
        return this.firstLabelList;
    }

    /**
     * @param firstLabelListIn
     */
    public void setFirstLabelList(Object[] firstLabelListIn)
    {
        this.firstLabelList = firstLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFirstBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.firstValueList = null;
        this.firstLabelList = null;
        if (items != null)
        {
            this.firstValueList = new Object[items.size()];
            this.firstLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.firstValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.firstLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.firstLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String third;

    /**
     * 
     * @return third 
     */
    public String getThird()
    {
        return this.third;
    }

    /**
     * Keeps track of whether or not the value of third has
     * be populated at least once.
     */
    private boolean thirdSet = false;

    /**
     * Resets the value of the thirdSet to false
     */
    public void resetThirdSet()
    {
        this.thirdSet = false;
    }

    /**
     * Indicates whether or not the value for third has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isThirdSet()
    {
        return this.thirdSet;
    }

    /**
     * 
     * @param thirdIn 
     */
    public void setThird(String thirdIn)
    {
        this.third = thirdIn;
        this.thirdSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] thirdValueList;

    /**
     * Stores the labels
     */
    private Object[] thirdLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getThirdBackingList()
    {
        Object[] values = this.thirdValueList;
        Object[] labels = this.thirdLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return thirdValueList
     */
    public Object[] getThirdValueList()
    {
        return this.thirdValueList;
    }

    /**
     * @param thirdValueListIn
     */
    public void setThirdValueList(Object[] thirdValueListIn)
    {
        this.thirdValueList = thirdValueListIn;
    }

    /**
     * @return thirdLabelList Object[]
     */
    public Object[] getThirdLabelList()
    {
        return this.thirdLabelList;
    }

    /**
     * @param thirdLabelListIn
     */
    public void setThirdLabelList(Object[] thirdLabelListIn)
    {
        this.thirdLabelList = thirdLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setThirdBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.thirdValueList = null;
        this.thirdLabelList = null;
        if (items != null)
        {
            this.thirdValueList = new Object[items.size()];
            this.thirdLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.thirdValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.thirdLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.thirdLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String two;

    /**
     * 
     * @return two 
     */
    public String getTwo()
    {
        return this.two;
    }

    /**
     * Keeps track of whether or not the value of two has
     * be populated at least once.
     */
    private boolean twoSet = false;

    /**
     * Resets the value of the twoSet to false
     */
    public void resetTwoSet()
    {
        this.twoSet = false;
    }

    /**
     * Indicates whether or not the value for two has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTwoSet()
    {
        return this.twoSet;
    }

    /**
     * 
     * @param twoIn 
     */
    public void setTwo(String twoIn)
    {
        this.two = twoIn;
        this.twoSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] twoValueList;

    /**
     * Stores the labels
     */
    private Object[] twoLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTwoBackingList()
    {
        Object[] values = this.twoValueList;
        Object[] labels = this.twoLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return twoValueList
     */
    public Object[] getTwoValueList()
    {
        return this.twoValueList;
    }

    /**
     * @param twoValueListIn
     */
    public void setTwoValueList(Object[] twoValueListIn)
    {
        this.twoValueList = twoValueListIn;
    }

    /**
     * @return twoLabelList Object[]
     */
    public Object[] getTwoLabelList()
    {
        return this.twoLabelList;
    }

    /**
     * @param twoLabelListIn
     */
    public void setTwoLabelList(Object[] twoLabelListIn)
    {
        this.twoLabelList = twoLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTwoBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.twoValueList = null;
        this.twoLabelList = null;
        if (items != null)
        {
            this.twoValueList = new Object[items.size()];
            this.twoLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.twoValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.twoLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.twoLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String second;

    /**
     * 
     * @return second 
     */
    public String getSecond()
    {
        return this.second;
    }

    /**
     * Keeps track of whether or not the value of second has
     * be populated at least once.
     */
    private boolean secondSet = false;

    /**
     * Resets the value of the secondSet to false
     */
    public void resetSecondSet()
    {
        this.secondSet = false;
    }

    /**
     * Indicates whether or not the value for second has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isSecondSet()
    {
        return this.secondSet;
    }

    /**
     * 
     * @param secondIn 
     */
    public void setSecond(String secondIn)
    {
        this.second = secondIn;
        this.secondSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] secondValueList;

    /**
     * Stores the labels
     */
    private Object[] secondLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getSecondBackingList()
    {
        Object[] values = this.secondValueList;
        Object[] labels = this.secondLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return secondValueList
     */
    public Object[] getSecondValueList()
    {
        return this.secondValueList;
    }

    /**
     * @param secondValueListIn
     */
    public void setSecondValueList(Object[] secondValueListIn)
    {
        this.secondValueList = secondValueListIn;
    }

    /**
     * @return secondLabelList Object[]
     */
    public Object[] getSecondLabelList()
    {
        return this.secondLabelList;
    }

    /**
     * @param secondLabelListIn
     */
    public void setSecondLabelList(Object[] secondLabelListIn)
    {
        this.secondLabelList = secondLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setSecondBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.secondValueList = null;
        this.secondLabelList = null;
        if (items != null)
        {
            this.secondValueList = new Object[items.size()];
            this.secondLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.secondValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.secondLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.secondLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private int formParam1;

    /**
     * 
     * @return formParam1 
     */
    public int getFormParam1()
    {
        return this.formParam1;
    }

    /**
     * Keeps track of whether or not the value of formParam1 has
     * be populated at least once.
     */
    private boolean formParam1Set = false;

    /**
     * Resets the value of the formParam1Set to false
     */
    public void resetFormParam1Set()
    {
        this.formParam1Set = false;
    }

    /**
     * Indicates whether or not the value for formParam1 has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFormParam1Set()
    {
        return this.formParam1Set;
    }

    /**
     * 
     * @param formParam1In 
     */
    public void setFormParam1(int formParam1In)
    {
        this.formParam1 = formParam1In;
        this.formParam1Set = true;
    }

    /**
     * Stores the values.
     */
    private Object[] formParam1ValueList;

    /**
     * Stores the labels
     */
    private Object[] formParam1LabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFormParam1BackingList()
    {
        Object[] values = this.formParam1ValueList;
        Object[] labels = this.formParam1LabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return formParam1ValueList
     */
    public Object[] getFormParam1ValueList()
    {
        return this.formParam1ValueList;
    }

    /**
     * @param formParam1ValueListIn
     */
    public void setFormParam1ValueList(Object[] formParam1ValueListIn)
    {
        this.formParam1ValueList = formParam1ValueListIn;
    }

    /**
     * @return formParam1LabelList Object[]
     */
    public Object[] getFormParam1LabelList()
    {
        return this.formParam1LabelList;
    }

    /**
     * @param formParam1LabelListIn
     */
    public void setFormParam1LabelList(Object[] formParam1LabelListIn)
    {
        this.formParam1LabelList = formParam1LabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFormParam1BackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.formParam1ValueList = null;
        this.formParam1LabelList = null;
        if (items != null)
        {
            this.formParam1ValueList = new Object[items.size()];
            this.formParam1LabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.formParam1ValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.formParam1LabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.formParam1LabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String formParam2;

    /**
     * 
     * @return formParam2 
     */
    public String getFormParam2()
    {
        return this.formParam2;
    }

    /**
     * Keeps track of whether or not the value of formParam2 has
     * be populated at least once.
     */
    private boolean formParam2Set = false;

    /**
     * Resets the value of the formParam2Set to false
     */
    public void resetFormParam2Set()
    {
        this.formParam2Set = false;
    }

    /**
     * Indicates whether or not the value for formParam2 has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFormParam2Set()
    {
        return this.formParam2Set;
    }

    /**
     * 
     * @param formParam2In 
     */
    public void setFormParam2(String formParam2In)
    {
        this.formParam2 = formParam2In;
        this.formParam2Set = true;
    }

    /**
     * Stores the values.
     */
    private Object[] formParam2ValueList;

    /**
     * Stores the labels
     */
    private Object[] formParam2LabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFormParam2BackingList()
    {
        Object[] values = this.formParam2ValueList;
        Object[] labels = this.formParam2LabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return formParam2ValueList
     */
    public Object[] getFormParam2ValueList()
    {
        return this.formParam2ValueList;
    }

    /**
     * @param formParam2ValueListIn
     */
    public void setFormParam2ValueList(Object[] formParam2ValueListIn)
    {
        this.formParam2ValueList = formParam2ValueListIn;
    }

    /**
     * @return formParam2LabelList Object[]
     */
    public Object[] getFormParam2LabelList()
    {
        return this.formParam2LabelList;
    }

    /**
     * @param formParam2LabelListIn
     */
    public void setFormParam2LabelList(Object[] formParam2LabelListIn)
    {
        this.formParam2LabelList = formParam2LabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFormParam2BackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.formParam2ValueList = null;
        this.formParam2LabelList = null;
        if (items != null)
        {
            this.formParam2ValueList = new Object[items.size()];
            this.formParam2LabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.formParam2ValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.formParam2LabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.formParam2LabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String parameterWithDefaultValue = "aDefaultValue";

    /**
     * 
     * @return parameterWithDefaultValue 
     */
    public String getParameterWithDefaultValue()
    {
        return this.parameterWithDefaultValue;
    }

    /**
     * Keeps track of whether or not the value of parameterWithDefaultValue has
     * be populated at least once.
     */
    private boolean parameterWithDefaultValueSet = false;

    /**
     * Resets the value of the parameterWithDefaultValueSet to false
     */
    public void resetParameterWithDefaultValueSet()
    {
        this.parameterWithDefaultValueSet = false;
    }

    /**
     * Indicates whether or not the value for parameterWithDefaultValue has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isParameterWithDefaultValueSet()
    {
        return this.parameterWithDefaultValueSet;
    }

    /**
     * 
     * @param parameterWithDefaultValueIn 
     */
    public void setParameterWithDefaultValue(String parameterWithDefaultValueIn)
    {
        this.parameterWithDefaultValue = parameterWithDefaultValueIn;
        this.parameterWithDefaultValueSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] parameterWithDefaultValueValueList;

    /**
     * Stores the labels
     */
    private Object[] parameterWithDefaultValueLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getParameterWithDefaultValueBackingList()
    {
        Object[] values = this.parameterWithDefaultValueValueList;
        Object[] labels = this.parameterWithDefaultValueLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return parameterWithDefaultValueValueList
     */
    public Object[] getParameterWithDefaultValueValueList()
    {
        return this.parameterWithDefaultValueValueList;
    }

    /**
     * @param parameterWithDefaultValueValueListIn
     */
    public void setParameterWithDefaultValueValueList(Object[] parameterWithDefaultValueValueListIn)
    {
        this.parameterWithDefaultValueValueList = parameterWithDefaultValueValueListIn;
    }

    /**
     * @return parameterWithDefaultValueLabelList Object[]
     */
    public Object[] getParameterWithDefaultValueLabelList()
    {
        return this.parameterWithDefaultValueLabelList;
    }

    /**
     * @param parameterWithDefaultValueLabelListIn
     */
    public void setParameterWithDefaultValueLabelList(Object[] parameterWithDefaultValueLabelListIn)
    {
        this.parameterWithDefaultValueLabelList = parameterWithDefaultValueLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setParameterWithDefaultValueBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.parameterWithDefaultValueValueList = null;
        this.parameterWithDefaultValueLabelList = null;
        if (items != null)
        {
            this.parameterWithDefaultValueValueList = new Object[items.size()];
            this.parameterWithDefaultValueLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.parameterWithDefaultValueValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.parameterWithDefaultValueLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.parameterWithDefaultValueLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String fourth;

    /**
     * 
     * @return fourth 
     */
    public String getFourth()
    {
        return this.fourth;
    }

    /**
     * Keeps track of whether or not the value of fourth has
     * be populated at least once.
     */
    private boolean fourthSet = false;

    /**
     * Resets the value of the fourthSet to false
     */
    public void resetFourthSet()
    {
        this.fourthSet = false;
    }

    /**
     * Indicates whether or not the value for fourth has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFourthSet()
    {
        return this.fourthSet;
    }

    /**
     * 
     * @param fourthIn 
     */
    public void setFourth(String fourthIn)
    {
        this.fourth = fourthIn;
        this.fourthSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] fourthValueList;

    /**
     * Stores the labels
     */
    private Object[] fourthLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFourthBackingList()
    {
        Object[] values = this.fourthValueList;
        Object[] labels = this.fourthLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return fourthValueList
     */
    public Object[] getFourthValueList()
    {
        return this.fourthValueList;
    }

    /**
     * @param fourthValueListIn
     */
    public void setFourthValueList(Object[] fourthValueListIn)
    {
        this.fourthValueList = fourthValueListIn;
    }

    /**
     * @return fourthLabelList Object[]
     */
    public Object[] getFourthLabelList()
    {
        return this.fourthLabelList;
    }

    /**
     * @param fourthLabelListIn
     */
    public void setFourthLabelList(Object[] fourthLabelListIn)
    {
        this.fourthLabelList = fourthLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFourthBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.fourthValueList = null;
        this.fourthLabelList = null;
        if (items != null)
        {
            this.fourthValueList = new Object[items.size()];
            this.fourthLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.fourthValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.fourthLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.fourthLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String thisOneShouldbeNamedFirst;

    /**
     * 
     * @return thisOneShouldbeNamedFirst 
     */
    public String getThisOneShouldbeNamedFirst()
    {
        return this.thisOneShouldbeNamedFirst;
    }

    /**
     * Keeps track of whether or not the value of thisOneShouldbeNamedFirst has
     * be populated at least once.
     */
    private boolean thisOneShouldbeNamedFirstSet = false;

    /**
     * Resets the value of the thisOneShouldbeNamedFirstSet to false
     */
    public void resetThisOneShouldbeNamedFirstSet()
    {
        this.thisOneShouldbeNamedFirstSet = false;
    }

    /**
     * Indicates whether or not the value for thisOneShouldbeNamedFirst has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isThisOneShouldbeNamedFirstSet()
    {
        return this.thisOneShouldbeNamedFirstSet;
    }

    /**
     * 
     * @param thisOneShouldbeNamedFirstIn 
     */
    public void setThisOneShouldbeNamedFirst(String thisOneShouldbeNamedFirstIn)
    {
        this.thisOneShouldbeNamedFirst = thisOneShouldbeNamedFirstIn;
        this.thisOneShouldbeNamedFirstSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] thisOneShouldbeNamedFirstValueList;

    /**
     * Stores the labels
     */
    private Object[] thisOneShouldbeNamedFirstLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getThisOneShouldbeNamedFirstBackingList()
    {
        Object[] values = this.thisOneShouldbeNamedFirstValueList;
        Object[] labels = this.thisOneShouldbeNamedFirstLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return thisOneShouldbeNamedFirstValueList
     */
    public Object[] getThisOneShouldbeNamedFirstValueList()
    {
        return this.thisOneShouldbeNamedFirstValueList;
    }

    /**
     * @param thisOneShouldbeNamedFirstValueListIn
     */
    public void setThisOneShouldbeNamedFirstValueList(Object[] thisOneShouldbeNamedFirstValueListIn)
    {
        this.thisOneShouldbeNamedFirstValueList = thisOneShouldbeNamedFirstValueListIn;
    }

    /**
     * @return thisOneShouldbeNamedFirstLabelList Object[]
     */
    public Object[] getThisOneShouldbeNamedFirstLabelList()
    {
        return this.thisOneShouldbeNamedFirstLabelList;
    }

    /**
     * @param thisOneShouldbeNamedFirstLabelListIn
     */
    public void setThisOneShouldbeNamedFirstLabelList(Object[] thisOneShouldbeNamedFirstLabelListIn)
    {
        this.thisOneShouldbeNamedFirstLabelList = thisOneShouldbeNamedFirstLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setThisOneShouldbeNamedFirstBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.thisOneShouldbeNamedFirstValueList = null;
        this.thisOneShouldbeNamedFirstLabelList = null;
        if (items != null)
        {
            this.thisOneShouldbeNamedFirstValueList = new Object[items.size()];
            this.thisOneShouldbeNamedFirstLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.thisOneShouldbeNamedFirstValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.thisOneShouldbeNamedFirstLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.thisOneShouldbeNamedFirstLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String unknownParameter;

    /**
     * 
     * @return unknownParameter 
     */
    public String getUnknownParameter()
    {
        return this.unknownParameter;
    }

    /**
     * Keeps track of whether or not the value of unknownParameter has
     * be populated at least once.
     */
    private boolean unknownParameterSet = false;

    /**
     * Resets the value of the unknownParameterSet to false
     */
    public void resetUnknownParameterSet()
    {
        this.unknownParameterSet = false;
    }

    /**
     * Indicates whether or not the value for unknownParameter has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isUnknownParameterSet()
    {
        return this.unknownParameterSet;
    }

    /**
     * 
     * @param unknownParameterIn 
     */
    public void setUnknownParameter(String unknownParameterIn)
    {
        this.unknownParameter = unknownParameterIn;
        this.unknownParameterSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] unknownParameterValueList;

    /**
     * Stores the labels
     */
    private Object[] unknownParameterLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getUnknownParameterBackingList()
    {
        Object[] values = this.unknownParameterValueList;
        Object[] labels = this.unknownParameterLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return unknownParameterValueList
     */
    public Object[] getUnknownParameterValueList()
    {
        return this.unknownParameterValueList;
    }

    /**
     * @param unknownParameterValueListIn
     */
    public void setUnknownParameterValueList(Object[] unknownParameterValueListIn)
    {
        this.unknownParameterValueList = unknownParameterValueListIn;
    }

    /**
     * @return unknownParameterLabelList Object[]
     */
    public Object[] getUnknownParameterLabelList()
    {
        return this.unknownParameterLabelList;
    }

    /**
     * @param unknownParameterLabelListIn
     */
    public void setUnknownParameterLabelList(Object[] unknownParameterLabelListIn)
    {
        this.unknownParameterLabelList = unknownParameterLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setUnknownParameterBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.unknownParameterValueList = null;
        this.unknownParameterLabelList = null;
        if (items != null)
        {
            this.unknownParameterValueList = new Object[items.size()];
            this.unknownParameterLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.unknownParameterValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.unknownParameterLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.unknownParameterLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String thisParameterNameDoesNotExistAsTableColumn;

    /**
     * 
     * @return thisParameterNameDoesNotExistAsTableColumn 
     */
    public String getThisParameterNameDoesNotExistAsTableColumn()
    {
        return this.thisParameterNameDoesNotExistAsTableColumn;
    }

    /**
     * Keeps track of whether or not the value of thisParameterNameDoesNotExistAsTableColumn has
     * be populated at least once.
     */
    private boolean thisParameterNameDoesNotExistAsTableColumnSet = false;

    /**
     * Resets the value of the thisParameterNameDoesNotExistAsTableColumnSet to false
     */
    public void resetThisParameterNameDoesNotExistAsTableColumnSet()
    {
        this.thisParameterNameDoesNotExistAsTableColumnSet = false;
    }

    /**
     * Indicates whether or not the value for thisParameterNameDoesNotExistAsTableColumn has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isThisParameterNameDoesNotExistAsTableColumnSet()
    {
        return this.thisParameterNameDoesNotExistAsTableColumnSet;
    }

    /**
     * 
     * @param thisParameterNameDoesNotExistAsTableColumnIn 
     */
    public void setThisParameterNameDoesNotExistAsTableColumn(String thisParameterNameDoesNotExistAsTableColumnIn)
    {
        this.thisParameterNameDoesNotExistAsTableColumn = thisParameterNameDoesNotExistAsTableColumnIn;
        this.thisParameterNameDoesNotExistAsTableColumnSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] thisParameterNameDoesNotExistAsTableColumnValueList;

    /**
     * Stores the labels
     */
    private Object[] thisParameterNameDoesNotExistAsTableColumnLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getThisParameterNameDoesNotExistAsTableColumnBackingList()
    {
        Object[] values = this.thisParameterNameDoesNotExistAsTableColumnValueList;
        Object[] labels = this.thisParameterNameDoesNotExistAsTableColumnLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return thisParameterNameDoesNotExistAsTableColumnValueList
     */
    public Object[] getThisParameterNameDoesNotExistAsTableColumnValueList()
    {
        return this.thisParameterNameDoesNotExistAsTableColumnValueList;
    }

    /**
     * @param thisParameterNameDoesNotExistAsTableColumnValueListIn
     */
    public void setThisParameterNameDoesNotExistAsTableColumnValueList(Object[] thisParameterNameDoesNotExistAsTableColumnValueListIn)
    {
        this.thisParameterNameDoesNotExistAsTableColumnValueList = thisParameterNameDoesNotExistAsTableColumnValueListIn;
    }

    /**
     * @return thisParameterNameDoesNotExistAsTableColumnLabelList Object[]
     */
    public Object[] getThisParameterNameDoesNotExistAsTableColumnLabelList()
    {
        return this.thisParameterNameDoesNotExistAsTableColumnLabelList;
    }

    /**
     * @param thisParameterNameDoesNotExistAsTableColumnLabelListIn
     */
    public void setThisParameterNameDoesNotExistAsTableColumnLabelList(Object[] thisParameterNameDoesNotExistAsTableColumnLabelListIn)
    {
        this.thisParameterNameDoesNotExistAsTableColumnLabelList = thisParameterNameDoesNotExistAsTableColumnLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setThisParameterNameDoesNotExistAsTableColumnBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.thisParameterNameDoesNotExistAsTableColumnValueList = null;
        this.thisParameterNameDoesNotExistAsTableColumnLabelList = null;
        if (items != null)
        {
            this.thisParameterNameDoesNotExistAsTableColumnValueList = new Object[items.size()];
            this.thisParameterNameDoesNotExistAsTableColumnLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.thisParameterNameDoesNotExistAsTableColumnValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.thisParameterNameDoesNotExistAsTableColumnLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.thisParameterNameDoesNotExistAsTableColumnLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    /**
     * Resets all the "isSet" flags.
     */
     public void resetIsSetFlags()
     {
         this.resetTableDatasSet();
         this.resetMultiboxThingsSet();
         this.resetTableDataDefaultExportTypesSet();
         this.resetTableDataNoExportTypesSet();
         this.resetTableDataNotSortablesSet();
         this.resetFirstSet();
         this.resetThirdSet();
         this.resetTwoSet();
         this.resetSecondSet();
         this.resetFormParam1Set();
         this.resetFormParam2Set();
         this.resetParameterWithDefaultValueSet();
         this.resetFourthSet();
         this.resetThisOneShouldbeNamedFirstSet();
         this.resetUnknownParameterSet();
         this.resetThisParameterNameDoesNotExistAsTableColumnSet();
     }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String, DateFormat> dateTimeFormatters =
        new HashMap<String, DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String, DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private transient Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();


    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (this.jsfMessages != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        if (this.jsfMessages == null)
        {
            this.jsfMessages = new LinkedHashMap<String, FacesMessage>();
        }
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage: messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 2385526135196919787L;
}