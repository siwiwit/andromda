// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\FormImpl.java.vsl) on 07/30/2011 09:32:35-0300
package org.andromda.cartridges.jsf.tests.tables.notablelink;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.faces.application.FacesMessage;
import javax.faces.event.ActionEvent;
import javax.faces.event.FacesEvent;
import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import org.apache.commons.beanutils.PropertyUtils;

/**
 * 
 */
public class NoTableLinkActivityFormImpl
    implements Serializable
{
    /**
     * Default constructor
     */
    public NoTableLinkActivityFormImpl()
    {
        final DateFormat customTablesThreeDateFormatter = new SimpleDateFormat("dd/MMM/yy");
        customTablesThreeDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("customTables.three", customTablesThreeDateFormatter);
        // - setup the default java.util.Date.toString() formatter
        final DateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);
    }

    private transient FacesEvent event;

    /**
     * @param eventIn
     */
    public void setEvent(FacesEvent eventIn)
    {
        this.event = eventIn;
    }

    /**
     * @return ValueChangeEvent
     */
    public ValueChangeEvent getValueChangeEvent()
    {
        return this.event instanceof ValueChangeEvent
            ? (ValueChangeEvent)this.event : null;
    }

    /**
     * @return ActionEvent
     */
    public ActionEvent getActionEvent()
    {
        return this.event instanceof ActionEvent
            ? (ActionEvent)this.event : null;
    }

    // Action no-table-link-activity-load-table-data formFields

    private Collection tableDatas;

    /**
     * 
     * @return tableDatas 
     */
    public Collection getTableDatas()
    {
        return this.tableDatas;
    }

    /**
     * Keeps track of whether or not the value of tableDatas has
     * be populated at least once.
     */
    private boolean tableDatasSet = false;

    /**
     * Resets the value of the tableDatasSet to false
     */
    public void resetTableDatasSet()
    {
        this.tableDatasSet = false;
    }

    /**
     * Indicates whether or not the value for tableDatas has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTableDatasSet()
    {
        return this.tableDatasSet;
    }

    /**
     * 
     * @param tableDatasIn 
     */
    public void setTableDatas(Collection tableDatasIn)
    {
        this.tableDatas = tableDatasIn;
        this.tableDatasSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] tableDatasValueList;

    /**
     * Stores the labels
     */
    private Object[] tableDatasLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTableDatasBackingList()
    {
        Object[] values = this.tableDatasValueList;
        Object[] labels = this.tableDatasLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return tableDatasValueList
     */
    public Object[] getTableDatasValueList()
    {
        return this.tableDatasValueList;
    }

    /**
     * @param tableDatasValueListIn
     */
    public void setTableDatasValueList(Object[] tableDatasValueListIn)
    {
        this.tableDatasValueList = tableDatasValueListIn;
    }

    /**
     * @return tableDatasLabelList Object[]
     */
    public Object[] getTableDatasLabelList()
    {
        return this.tableDatasLabelList;
    }

    /**
     * @param tableDatasLabelListIn
     */
    public void setTableDatasLabelList(Object[] tableDatasLabelListIn)
    {
        this.tableDatasLabelList = tableDatasLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTableDatasBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.tableDatasValueList = null;
        this.tableDatasLabelList = null;
        if (items != null)
        {
            this.tableDatasValueList = new Object[items.size()];
            this.tableDatasLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.tableDatasValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.tableDatasLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.tableDatasLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection tableDatasBackingValue;

    /**
     * @param tableDatasBackingValueIn
     */
    public void setTableDatasBackingValue(Collection tableDatasBackingValueIn)
    {
        this.tableDatasBackingValue = tableDatasBackingValueIn;
    }

    /**
     * @return tableDatasBackingValue
     */
    public Collection getTableDatasBackingValue()
    {
        return this.tableDatasBackingValue;
    }


    private CustomTableRow[] customTables;

    /**
     * 
     * @return customTables 
     */
    public CustomTableRow[] getCustomTables()
    {
        return this.customTables;
    }

    /**
     * Keeps track of whether or not the value of customTables has
     * be populated at least once.
     */
    private boolean customTablesSet = false;

    /**
     * Resets the value of the customTablesSet to false
     */
    public void resetCustomTablesSet()
    {
        this.customTablesSet = false;
    }

    /**
     * Indicates whether or not the value for customTables has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isCustomTablesSet()
    {
        return this.customTablesSet;
    }

    /**
     * 
     * @param customTablesIn 
     */
    public void setCustomTables(CustomTableRow[] customTablesIn)
    {
        this.customTables = customTablesIn;
        this.customTablesSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] customTablesValueList;

    /**
     * Stores the labels
     */
    private Object[] customTablesLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCustomTablesBackingList()
    {
        Object[] values = this.customTablesValueList;
        Object[] labels = this.customTablesLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return customTablesValueList
     */
    public Object[] getCustomTablesValueList()
    {
        return this.customTablesValueList;
    }

    /**
     * @param customTablesValueListIn
     */
    public void setCustomTablesValueList(Object[] customTablesValueListIn)
    {
        this.customTablesValueList = customTablesValueListIn;
    }

    /**
     * @return customTablesLabelList Object[]
     */
    public Object[] getCustomTablesLabelList()
    {
        return this.customTablesLabelList;
    }

    /**
     * @param customTablesLabelListIn
     */
    public void setCustomTablesLabelList(Object[] customTablesLabelListIn)
    {
        this.customTablesLabelList = customTablesLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCustomTablesBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.customTablesValueList = null;
        this.customTablesLabelList = null;
        if (items != null)
        {
            this.customTablesValueList = new Object[items.size()];
            this.customTablesLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.customTablesValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.customTablesLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.customTablesLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private CustomTableRow[] customTablesBackingValue;

    /**
     * @param customTablesBackingValueIn
     */
    public void setCustomTablesBackingValue(CustomTableRow[] customTablesBackingValueIn)
    {
        this.customTablesBackingValue = customTablesBackingValueIn;
    }

    /**
     * @return customTablesBackingValue
     */
    public CustomTableRow[] getCustomTablesBackingValue()
    {
        return this.customTablesBackingValue;
    }

    // customTables attributes

    /**
     * Stores the values.
     */
    private Object[] customTablesOneValueList;

    /**
     * Stores the labels
     */
    private Object[] customTablesOneLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCustomTablesOneBackingList()
    {
        Object[] values = this.customTablesOneValueList;
        Object[] labels = this.customTablesOneLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return customTablesOneValueList
     */
    public Object[] getCustomTablesOneValueList()
    {
        return this.customTablesOneValueList;
    }

    /**
     * @param customTablesOneValueListIn
     */
    public void setCustomTablesOneValueList(Object[] customTablesOneValueListIn)
    {
        this.customTablesOneValueList = customTablesOneValueListIn;
    }

    /**
     * @return customTablesOneLabelList Object[]
     */
    public Object[] getCustomTablesOneLabelList()
    {
        return this.customTablesOneLabelList;
    }

    /**
     * @param customTablesOneLabelListIn
     */
    public void setCustomTablesOneLabelList(Object[] customTablesOneLabelListIn)
    {
        this.customTablesOneLabelList = customTablesOneLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCustomTablesOneBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.customTablesOneValueList = null;
        this.customTablesOneLabelList = null;
        if (items != null)
        {
            this.customTablesOneValueList = new Object[items.size()];
            this.customTablesOneLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.customTablesOneValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.customTablesOneLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.customTablesOneLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] customTablesTwoValueList;

    /**
     * Stores the labels
     */
    private Object[] customTablesTwoLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCustomTablesTwoBackingList()
    {
        Object[] values = this.customTablesTwoValueList;
        Object[] labels = this.customTablesTwoLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return customTablesTwoValueList
     */
    public Object[] getCustomTablesTwoValueList()
    {
        return this.customTablesTwoValueList;
    }

    /**
     * @param customTablesTwoValueListIn
     */
    public void setCustomTablesTwoValueList(Object[] customTablesTwoValueListIn)
    {
        this.customTablesTwoValueList = customTablesTwoValueListIn;
    }

    /**
     * @return customTablesTwoLabelList Object[]
     */
    public Object[] getCustomTablesTwoLabelList()
    {
        return this.customTablesTwoLabelList;
    }

    /**
     * @param customTablesTwoLabelListIn
     */
    public void setCustomTablesTwoLabelList(Object[] customTablesTwoLabelListIn)
    {
        this.customTablesTwoLabelList = customTablesTwoLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCustomTablesTwoBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.customTablesTwoValueList = null;
        this.customTablesTwoLabelList = null;
        if (items != null)
        {
            this.customTablesTwoValueList = new Object[items.size()];
            this.customTablesTwoLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.customTablesTwoValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.customTablesTwoLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.customTablesTwoLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] customTablesThreeValueList;

    /**
     * Stores the labels
     */
    private Object[] customTablesThreeLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCustomTablesThreeBackingList()
    {
        Object[] values = this.customTablesThreeValueList;
        Object[] labels = this.customTablesThreeLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return customTablesThreeValueList
     */
    public Object[] getCustomTablesThreeValueList()
    {
        return this.customTablesThreeValueList;
    }

    /**
     * @param customTablesThreeValueListIn
     */
    public void setCustomTablesThreeValueList(Object[] customTablesThreeValueListIn)
    {
        this.customTablesThreeValueList = customTablesThreeValueListIn;
    }

    /**
     * @return customTablesThreeLabelList Object[]
     */
    public Object[] getCustomTablesThreeLabelList()
    {
        return this.customTablesThreeLabelList;
    }

    /**
     * @param customTablesThreeLabelListIn
     */
    public void setCustomTablesThreeLabelList(Object[] customTablesThreeLabelListIn)
    {
        this.customTablesThreeLabelList = customTablesThreeLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCustomTablesThreeBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.customTablesThreeValueList = null;
        this.customTablesThreeLabelList = null;
        if (items != null)
        {
            this.customTablesThreeValueList = new Object[items.size()];
            this.customTablesThreeLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.customTablesThreeValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.customTablesThreeLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.customTablesThreeLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] customTablesNoColumnForThisAttributeValueList;

    /**
     * Stores the labels
     */
    private Object[] customTablesNoColumnForThisAttributeLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCustomTablesNoColumnForThisAttributeBackingList()
    {
        Object[] values = this.customTablesNoColumnForThisAttributeValueList;
        Object[] labels = this.customTablesNoColumnForThisAttributeLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return customTablesNoColumnForThisAttributeValueList
     */
    public Object[] getCustomTablesNoColumnForThisAttributeValueList()
    {
        return this.customTablesNoColumnForThisAttributeValueList;
    }

    /**
     * @param customTablesNoColumnForThisAttributeValueListIn
     */
    public void setCustomTablesNoColumnForThisAttributeValueList(Object[] customTablesNoColumnForThisAttributeValueListIn)
    {
        this.customTablesNoColumnForThisAttributeValueList = customTablesNoColumnForThisAttributeValueListIn;
    }

    /**
     * @return customTablesNoColumnForThisAttributeLabelList Object[]
     */
    public Object[] getCustomTablesNoColumnForThisAttributeLabelList()
    {
        return this.customTablesNoColumnForThisAttributeLabelList;
    }

    /**
     * @param customTablesNoColumnForThisAttributeLabelListIn
     */
    public void setCustomTablesNoColumnForThisAttributeLabelList(Object[] customTablesNoColumnForThisAttributeLabelListIn)
    {
        this.customTablesNoColumnForThisAttributeLabelList = customTablesNoColumnForThisAttributeLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCustomTablesNoColumnForThisAttributeBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.customTablesNoColumnForThisAttributeValueList = null;
        this.customTablesNoColumnForThisAttributeLabelList = null;
        if (items != null)
        {
            this.customTablesNoColumnForThisAttributeValueList = new Object[items.size()];
            this.customTablesNoColumnForThisAttributeLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.customTablesNoColumnForThisAttributeValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.customTablesNoColumnForThisAttributeLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.customTablesNoColumnForThisAttributeLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    /**
     * Resets all the "isSet" flags.
     */
     public void resetIsSetFlags()
     {
         this.resetTableDatasSet();
         this.resetCustomTablesSet();
     }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String, DateFormat> dateTimeFormatters =
        new HashMap<String, DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String, DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private transient Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();


    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (this.jsfMessages != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        if (this.jsfMessages == null)
        {
            this.jsfMessages = new LinkedHashMap<String, FacesMessage>();
        }
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage: messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 8406701110595000677L;
}