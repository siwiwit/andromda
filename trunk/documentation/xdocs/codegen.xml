<?xml version="1.0" encoding="iso-8859-1"?>

<document>

  <properties>
    <author email="mbohlen@mbohlen.de">Matthias Bohlen</author>
    <title>AndroMDA - Generating code</title>
    <gennews>yes</gennews>
  </properties>

  <body>

    <section name="Code generation with AndroMDA">

      <p class="std">
        AndroMDA with its current template set follows a particular
        pattern to generate the classes which are necessary for a
        complete Enterprise JavaBean. This chapter describes the
        pattern.
      </p>
      <p class="std">
        <b>Which files are generated?</b>
      </p>
      <p class="std">
        Currently, there are templates for session beans and for entity
        beans. Let's start with the more complex case: the entity bean classes.
        When you model a class <code>Customer</code> and give it the stereotype
        <code>&lt;&lt;Entity&gt;&gt;</code>, you will get the following classes
        generated by AndroMDA using the EJB cartridge (similar but different
        things apply to the Hibernate or other cartridges):
      </p>
      <img src="../images/CustomerClasses.gif" width="331" height="760" />
      <p class="std">
        <b><a href="../java2html/CustomerBean.java.html">CustomerBean</a> - the bean class</b>
      </p>
      <p class="std">
        AndroMDA generates the following items for this class:
      </p>
      <ul>
        <li class="std">
          import statements for referenced classes that are contained
          in another java package
        </li>
        <li class="std">
          a class header with all the necessary definitions,
          so that XDoclet can generate all the interfaces, value object class
          and deployment descriptor. This includes ejbref's to other beans
          and the EJB-QL statements for the finder methods.
        </li>
        <li class="std">
          for each attribute: one abstract getter and setter with @tags
          to generate it as a CMP 2.0 persistent field
        </li>
        <li class="std">
          for each method: one abstract method with the same
          signature, to be implemented in the implementation class,
          with a throws-clause that lists the exception class
          for this component
        </li>
        <li class="std">
          for each persistent association to other entity beans:
          one abstract getter and setter with @tags
          to generate it as a CMR relationship
        </li>
        <li class="std">
          one pair of ejbCreate()/ejbPostCreate() methods with all
          attributes necessary to initialize the bean (except the primary key)
        </li>
        <li class="std">
          one pair of ejbCreate()/ejbPostCreate() methods that accept
          the value object as an argument
        </li>
        <li class="std">
          for each dependency that is marked with an &lt;&lt;EntityRef&gt;&gt; or &lt;&lt;ServiceRef&gt;&gt;
          stereotype: one lookup method for the home interface of the
          other class.
        </li>
        
      </ul>
      
      <p class="std">
        <b><a href="../java2html/CustomerBeanImpl.java.html">CustomerBeanImpl</a> - the implementation class</b>
      </p>
      <p class="std">
        AndroMDA generates the following items for this class:
      </p>
      <ul>
        <li class="std">
          a simple header without @tags, letting this class
          derive from CustomerBean
        </li>
        <li class="std">
          for each method: one concrete method that you can implement here
        </li>
        <li class="std">
          the other EJB-related methods that you can implement here:
          setEntityContext, unsetEntityContext, ejbRemove, ejbLoad, ejbStore,
          ejbPassivate, ejbActivate
        </li>
      </ul>
      
      <p class="std">
        <b><a href="../java2html/CustomerBeanCMP.java.html">CustomerBeanCMP</a> - CMP 2.0 support class</b>
      </p>
      <p class="std">
        Normally, this class would be unnecessary. However, JBoss does not
        handle derived classes 100% correctly and complains when the leaf
        class does not contain the EJB-related methods mentioned above
        AND all the abstract getters/setters. So this class collects the
        items once more.
      </p>
      
      <p class="std">
        <b>
          <a href="../java2html/CustomerServiceBean.java.html">CustomerServiceBean</a>
          and <a href="../java2html/CustomerServiceBeanImpl.java.html">CustomerServiceBeanImpl</a>
          - the same thing for session beans
        </b>
      </p>

      <img src="../images/CustomerServiceClasses.gif" width="360" height="365" />

      <p class="std">
        All the stuff above also applies to session bean classes
        with the following exceptions:
      </p>
      <ul>
        <li class="std">
          Stateless session beans do not have attributes.
        </li>
        <li class="std">
          Stateless session beans do not need CMP support classes.
        </li>
        <li class="std">
          Stateless session beans look much simpler in general.
        </li>
      </ul>
      
    </section>

    <news name="What is CMP?" href="http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/CMP.html">
      <p>
        An entity bean with container-managed persistence offers important
        advantages to the bean developer. First, the EJB container handles
        all database storage and retrieval calls. Second, the container
        manages the relationships between the entity beans. Because of
        these services, you don't have to code the database access calls
        in the entity bean. Instead, you specify settings in the bean's
        deployment descriptor. Not only does this approach save you time,
        but it makes the bean portable across various database servers.
      </p>
      <p>
        Want to know more? Read SUN's J2EE tutorial!
      </p>
    </news>


  </body>
</document>
