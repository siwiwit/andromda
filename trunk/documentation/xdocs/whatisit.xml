<?xml version="1.0" encoding="UTF-8"?>

<document>

    <properties>
        <author email="mbohlen@mbohlen.de">Matthias Bohlen</author>
        <author email="cwbrandon@users.sourceforge.net">Chad Brandon</author>
        <author email="draftdog@users.sourceforge.net">Wouter Zoons</author>
        <title>AndroMDA - What is it?</title>
    </properties>

    <body>

        <section name="What is AndroMDA?">

            <p>
          In short, AndroMDA is an open source
                <a href="http://www.klasse.nl/english/mda/mda-faq.html">MDA</a>
          framework - it takes any number of models 
          (usually UML models stored in XMI produced from case-tools) combined with any 
          number of andromda plugins (cartridge and translation-libraries) and produces
          any number of custom components.  You can generate components for any language you want,
          Java, .Net, HTML, PHP, anything really, you just write (or customize existing) plugins 
          to support it and you're good to go.
            </p>
            <p>
                <b>Tell me a little bit more about MDA and code generation</b>
            </p>
            <p>
                In the classical way of software engineering one would first
                try to determine how the system should be working, this is
                the analysis phase. In this step the developer or architect has
                something in mind that should be translated into a formal and platform
                specific computer code, it will require an actual person to implement
                this translation using a language such as ASM, C, C++, Java, ...
            </p>
            <p>
                In MDA we will try to simplify the job of the developer/architect, we
                can achieve this by making it easier for him to digitalize the ideas
                he has in mind (the <i>Mental Model</i> or <i>MM</i>): we let him create the
                <i>Platform Independent Model</i> or <i>PIM</i>, this model
                is a one-or-one mapping of the MM into a more formal language
                such as UML. This approach has several
                obvious advantages:
            </p>
            <p>
                <ul>
                    <li>It is a very straightforward translation process</li>
                    <li>The developer/architect keeps focus on the business logic, not the underlying technology</li>
                    <li>The PIM can be reused later, it is not bound to any existing platform</li>
                    <li>The PIM is a useful medium to communicate ideas to others</li>
                </ul>
            </p>
            <p>
                The next step is to have a way to transform the PIM into program code,
                the MDA way of doing this is to gradually refine the model into a more
                <i>Platform Specific Model</i> or <i>PSM</i> and marshall this model
                into the code that would actually be written manually.
            </p>
            <p>
                This is where AndroMDA kicks in: different cartridges exist that will
                analyze the given PIM and construct a PSM with which templates are used
                to produce code. You'll see that a lot of code often is boilerplate and will
                never require a manual change, if some code does require a change
                there are a few different ways of elegantly solving that problem.
            </p>
            <p>
                A very important thing to know about AndroMDA is that the transformation
                process is controlled using plugins called <i>cartridges</i> and each cartridge
                is very easy to tune: you will never encounter a case where you will not be
                able to have <i>your</i> specific code generated from the model. Any type
                of customization is possible and you'll never get stuck.
            </p>
            <p>
                On the other hand it is very important to realize AndroMDA is here to help
                you out with boring and repetitive tasks, and is not meant to be a
                <i>Silver Bullet</i> solution where the computer takes over your job and you just
                sit back on stop thinking.
            </p>
            <p>
                <b>Why would you want to use it?</b>
            </p>
            <p>
          You would want to use AndroMDA for a number of reasons:
                <ol>
                    <li>
                It elimates the need to write redundant code.
                    </li>
                    <li>
                Your project models
                        <strong>WILL</strong> reflect your code.
                    </li>
                    <li>
                Projects are documented/diagrammed in a standard platform independant way 
                making it much easier/faster to adapt to ever rapidly changing technologies.
                    </li>
                    <li>
                You'll have artifacts (your models) that allow much easier communication 
                with the business side of things.
                    </li>
                </ol>
            </p>
            <p>
                <b>Okay, that all sounds fine, but what can AndroMDA do for me *now* ?</b>
            </p>
            <p>
                At the time of this writing AndroMDA is mostly used by developers working with J2EE technologies.
                Out-of-the-box AndroMDA can setup a new J2EE project from scratch, in which code is generated from a UML
                model. You can choose to generate code for
                <a href="andromda-hibernate-cartridge/index.html">Hibernate</a>,
                <a href="andromda-ejb-cartridge/index.html">EJB</a>,
                <a href="andromda-spring-cartridge/index.html">Spring</a>,
                <a href="andromda-webservice-cartridge/index.html">WebServices</a>,
                and <a href="andromda-bpm4struts-cartridge/index.html">Struts</a>.
                The generated code is automatically integrated into the build process. In doing so you will only need
                to spend a little time getting to know AndroMDA and you're good to go, you will see it is very efficient
                to have the code generated for you, while keeping your focus on business logic.
            </p>
            <p>
                Additionally AndroMDA ships with a few tools to make your life easier:
            </p>
            <p>
                <ul>
                    <li>As already mentioned, we have a tool to generate project templates such as for J2EE:
                        <a href="maven-andromdapp-plugin/index.html">andromdapp:generate</a>,
                        this is a maven plugin.</li>
                    <li><a href="andromda-schema2xmi/index.html">Schema2XMI</a>
                        is able to read your database and build an XMI file from it,
                        which can then be used to load as a UML model.</li>
                    <li>Admin-Console is a web application that can be used for the maintenance of your database
                        tables. It allows to list, insert, update and delete rows from your database.
                        It is very configurable so you can present your data in a way that suits the users best.
                        You could deploy this tool together with your own application and easily and quickly perform
                        CRUD operations (this tool is still under development and is only available through CVS)</li>
                </ul>
            </p>
            <p>
                <b>How does AndroMDA work?</b>
            </p>
            <p>
                AndroMDA reads models into memory making these object models available to its
                plugins.  These plugins define exactly what AndroMDA will and will 
                NOT generate.  Each plugin is completely customizable to a project's specific needs.
            </p>
            <p>
                We invite you to get to know AndroMDA, here are three links that will point you in the right direction:
            </p>
            <p>
                <ul>
                    <li><a href="starting.html">Getting started</a></li>
                    <li><a href="samples.html">AndroMDA Samples</a></li>
                    <li><a href="releases.html">Releases</a></li>
                </ul>
            </p>
        </section>
    </body>
</document>
